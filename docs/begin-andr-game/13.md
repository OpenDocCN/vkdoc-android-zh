# 十三、与 NDK 一起走向原生

在过去三章的 3D 铺张浪费之后，是时候来看看为 Android 编程游戏的另一个方面了。虽然就执行速度而言，Java 和 Dalvik VM 对于许多游戏类型来说已经足够了，但是有时候你需要更强的能力。这对于物理模拟、复杂的 3D 动画、碰撞检测等尤其如此。这种类型的代码最好用更“金属”的语言编写，如 C/C++ 甚至汇编语言。Android 本地开发套件(NDK)让我们做到了这一点。

用 C/C++ 实现 3D 动画或物理引擎超出了本书的范围。然而，在第八章中，我们发现了一个可以用一点本地代码修复的瓶颈。在 Android 上，将浮点数组复制到 ByteBuffer 非常慢。我们的一些 OpenGL ES 类依赖于这种机制。在这一章中，我们将研究用一些 C/C++ 代码来解决这个问题！

**注意**下面几节将向您展示如何从您的 Java 应用中与 C/C++ 代码交互。如果你对进入这个话题没有信心，就跳过这一章，如果你想知道更多，就回到这一章。

什么是安卓 NDK？

NDK 是对 Android SDK 的补充，它允许您编写 C/C++ 和汇编代码，然后您可以将它们集成到您的 Android 应用中。NDK 包括一组特定于 Android 的 C 库、一个基于 GNU 编译器集合(GCC)的交叉编译器工具链，该工具链可以编译 Android 支持的所有不同的 CPU 架构(ARM、x86 和 MIPS)，以及一个定制的构建系统，与编写自己的 makefiles 相比，该系统应该可以使编译 C/C++ 代码更加容易。

在 NDK 的早期版本中，用 Eclipse 的调试器调试本机代码不是官方支持的功能。现在有一些官方的新工具正在工作中，使本地调试变得更加容易。在撰写本文时，这个功能是全新的，还没有经过测试，但是当您读到这些文字时，它可能已经更加成熟了。所以如果你需要调试你的本地代码，我们建议你快速搜索一下 **Eclipse NDK 插件** ，看看有什么可用的。

NDK 没有公开大多数 Androids APIs，比如 UI 工具包。它主要是通过用 C/C++ 重写缓慢的 Java 方法并从 Java 内部调用它们来加速它们。从 Android 2.3 开始，使用 NativeActivity 类代替 Java activities，几乎可以完全绕过 Java。NativeActivity 类是专门为全窗口控制的游戏设计的，但它根本不提供对 Java 的访问，所以它不能与其他基于 Java 的 Android 库一起使用。许多来自 iOS 的游戏开发人员选择这条路线，因为这让他们可以重用 Android 上的大部分 C/C++，而不必深入研究 Android Java APIs。然而，诸如脸书认证或 ads 之类的服务的集成仍然需要用 Java 来完成，所以将游戏设计成在 Java 中启动并通过 JNI 调用 C++ 通常是最兼容的方式。也就是说，如何使用 JNI 呢？

Java 本地接口

Java 本地接口(JNI)是让虚拟机(以及 Java 代码)与 C/C++ 代码通信的一种方式。这是双向的；可以从 Java 调用 C/C++ 代码，也可以从 C/C++ 调用 Java 方法。Android 的许多库使用这种机制来公开本机代码，如 OpenGL ES 或音频解码器。

一旦使用了 JNI，您的应用就由两部分组成:Java 代码和 C/C++ 代码。在 Java 端，您通过添加一个名为 native 的特殊限定符来声明要在本机代码中实现的类方法。这可能看起来像这样:

```java
package com.badlogic.androidgames.ndk;

public class MyJniClass {
    public native int add(int a,int b);
}
```

如您所见，我们声明的方法没有方法体。当运行 Java 代码的 VM 在方法上看到这个限定符时，它知道相应的实现是在共享库中找到的，而不是在 JAR 文件或 APK 文件中。

共享库非常类似于 Java JAR 文件。它包含编译的 C/C++ 代码，任何加载这个共享库的程序都可以调用这些代码。在 Windows 上，这些共享库通常带有后缀。dll 在 Unix 系统上，它们以. so 结尾。

在 C/C++ 方面，我们有许多头文件和源文件，它们定义了 C 中本地方法的签名，并包含实际的实现。在前面的代码中，我们的类的头文件看起来像这样:

```java
 /* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_badlogic_androidgames_ndk_MyJniClass */

#ifndef _Included_com_badlogic_androidgames_ndk_MyJniClass
#define _Included_com_badlogic_androidgames_ndk_MyJniClass
#ifdef __cplusplus 
extern "C" {
#endif 
/*
 * Class:     com_badlogic_androidgames_ndk_MyJniClass
 * Method:    add
 * Signature: (II)I
 */
JNIEXPORT jint JNICALL Java_com_badlogic_androidgames_ndk_MyJniClass_add
  (JNIEnv *, jobject, jint, jint);

#ifdef __cplusplus 
}
#endif 
#endif
```

这个头文件是用一个叫做 javah 的 JDK 工具生成的。该工具将一个 Java 类作为输入，并为它找到的任何本机方法生成一个 C 函数签名。这里发生了很多事情，因为 C 代码需要遵循特定的命名模式，并且需要能够将 Java 类型封送到它们对应的 C 类型(例如，Java 的 int 变成了 C 中的 jint)。我们还获得了 JNIEnv 和 jobject 类型的两个附加参数。第一个可以被认为是虚拟机的句柄。它包含与 VM 通信的方法，比如调用类实例的方法。第二个参数是调用该方法的类实例的句柄。我们可以将它与 JNIEnv 参数结合使用，从 C 代码中调用这个类实例的其他方法。

这个头文件还不包含函数的实现。我们需要一个实现该功能的相应 C/C++ 源文件:

```java
#include "myjniclass.h"

JNIEXPORT jint JNICALL Java_com_badlogic_androidgames_ndk_MyJniClass_add
    (JNIEnv * env, jobject obj, jint a, jint b) {
    return a + b;
}
```

这些 C/C++ 源代码被编译到一个共享库中，然后我们通过一个特定的 Java API 加载这个库，这样 VM 就可以找到我们的 Java 类的本地方法的实现:

```java
 System.loadLibrary("myjnitest");
int result = new MyJniClass().add(12, 32);
```

对 System.loadLibrary()的调用采用共享库的名称。它如何找到相应的文件在某种程度上取决于 VM 实现。这个方法只在启动时调用一次，这样 VM 就知道在哪里可以找到任何本地库的实现。如您所见，我们可以像调用任何其他 Java 类方法一样调用 MyJniClass.add()方法！

说够了。让我们用 Android 上的一点 C 代码来弄脏我们的手吧！我们将编写一些简单的 C 函数，希望从我们的 Java 应用中调用这些函数。我们将指导您完成编译共享库、加载它以及调用本机方法的过程。

设置 NDK

开始之前，我们必须安装 NDK。这其实是一个相当简单的过程。

1.  前往[`developer.android.com/tools/sdk/ndk/index.html`](http://developer.android.com/tools/sdk/ndk/index.html)，为你的平台选择归档。
2.  将存档文件解压到您喜欢的位置，并记下它的位置。
3.  Add the base NDK directory to your system path:

    a.在 Linux 或 Mac OS X 上，打开一个 shell，将 NDK 安装目录的路径添加到＄PATH 环境变量中。一般是在。配置文件，该行如下所示:导出路径= $ PATH:/PATH/to/your/ndk/installation

    b.在 Windows 上，选择控制面板![image](img/arrow.jpg)系统和安全![image](img/arrow.jpg)系统![image](img/arrow.jpg)高级系统设置![image](img/arrow.jpg)环境变量![image](img/arrow.jpg)系统变量，在系统变量列表中选择 Path，点击编辑，将目录添加到变量值的末尾，以分号开头(如；c:\安卓 _NDK)。

4.  要验证您的 NDK 是否已经成功安装，请在您的终端中发出命令 ndk-build。它应该吐出一些关于缺少一个 Android 项目的评论。
5.  在第二章中，我们设置了 JDK，并将它的 bin/目录添加到我们的路径中。通过发出 javah 命令，确保该目录中的工具仍然可用。它应该打印出该工具的使用信息。我们以后会需要它。

建立 NDK Android 项目

与前面的编码章节一样，您必须创建一个新的 Android 项目。复制第十二章的所有框架代码。然后，创建一个名为 com.badlogic.androidgames.ndk 的新包，将前面章节中的一个 starter 活动的副本放入其中，将其重命名为 NdkStarter，并使其成为启动器活动。和往常一样，记住向清单文件和启动活动添加任何新的测试。

为了使事情变得简单，您应该现在打开您的终端并导航到那个新项目的根目录。确保您的路径仍然包含正确的条目，以便可以调用 ndk-build 和 javah 工具。

创建 Java 本地方法

正如我们之前看到的，指定 Java 类的哪些方法在本机代码中实现是相当简单的。然而，在定义传递给方法的类型和从方法中得到的返回类型时，我们需要小心。

虽然我们可以将任何 Java 类型传递给本机方法，但有些类型比其他类型更难处理。最容易处理的类型是基本类型，如 int、byte、boolean、C 等等，它们直接对应于等价的 C 类型。在 C/C++ 端，下一个最容易处理的类型是基元类型的一维数组，比如 int[]或 float[]。这些数组可以用我们前面看到的 JNIEnv 类型提供的方法转换成 C 数组或指针。接下来是直接 ByteBuffer 实例。和数组一样，它们可以很容易地转换成指针。根据不同的用例，字符串也可以很容易使用。对象和多维数组更难处理。在 C/C++ 端使用这些 API 类似于在 Java 端使用反射 API。

我们也可以从本地方法返回任何 Java 类型。原始类型也很容易处理。返回其他类型通常涉及在 C/C++ 端创建该类型的实例，这可能相当复杂。

我们将只研究传递基本类型、数组、ByteBuffer 实例和字符串。如果你想知道更多关于如何通过 JNI 处理类型的信息，我们建议你参考(在线)书籍 *Java Native Interface 5.0 规范*，在[`docs . Oracle . com/javase/1 . 5 . 0/docs/guide/JNI/spec/jnitoc . html`](http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/jniTOC.html)。

对于我们的 JNI 实验，我们将创建两个方法。一个将把 float[]复制到 C 代码中的 direct ByteBuffer，另一个将把一个字符串打印到 LogCat。清单 13-1 显示了我们的 JniUtils 类。

***清单 13-1 。****【JniUtils.java】；我们保持简单*

```java
package com.badlogic.androidgames.ndk;

import java.nio.ByteBuffer;

public class JniUtils {
    static {
        System.loadLibrary("jniutils");
    }
    public static native void log(String tag, String message);

    public static native void copy(ByteBuffer dst,float[] src,int offset,int len);

}
```

该类从一个静态块开始。该块中的代码将在 VM 第一次遇到对 JNIUtils 类的引用时被调用。这是调用 System.loadLibrary()的最佳位置，它将加载我们稍后将编译的共享库。我们传递给方法的参数是共享库的纯名称。正如我们将在后面看到的，实际的文件名为 libjniutils.so。该方法将自己解决这个问题。

log()方法模仿 Android Java Log.logd()方法。它需要一个标签和一条消息，这条消息将被打印到 LogCat。

copy()方法其实很有用。在第八章中，我们研究了 FloatBuffer.put()方法的性能问题。我们求助于使用一个纯 Java 实现，该实现使用了 IntBuffer 和一些令人讨厌的技巧，这样我们可以加速将一个浮点数组复制到 Vertices 类中的一个直接 ByteBuffer。我们现在将实现一个方法，该方法采用一个直接 ByteBuffer 和一个 float 数组，并将该数组复制到缓冲区。这比使用相应的 Java APIs 要快得多。我们可以稍后修改我们的顶点和顶点 3 类来使用这个新功能。

请注意，这两种方法都是静态方法，而不是实例方法。这意味着我们可以在没有 JniTest 类实例的情况下调用它们！这也对我们的 C 签名有很小的影响，我们稍后会看到。

创建 C/C++ 头文件并实现

当我们开始编写 C/C++ 代码时，我们做的第一件事是通过 Java JDK 命令行工具生成头文件。它需要几个对我们有用的参数:

*   输出文件的名称，在我们的例子中是 jni/jniutils.h。如果 jni/文件夹还不存在，javah 工具将为我们创建它。
*   包含的路径。应该为其生成 C 头文件的 Java 类的类文件。如果我们从项目的根目录调用 javah，这将是 bin/classes。这是 Eclipse 编译器编译我们的 Android 项目的任何源文件时的输出路径。
*   该类的完全限定名，在我们的例子中是 com . bad logic . androidgames . ndk . jniutils。

打开终端或命令提示符，导航到 Android 项目的根文件夹。如前所述，确保 NDK 和 JDK 位于您的$PATH 中。现在执行以下命令:

```java
javah -o jni/jniutils.h -classpath bin/classes com.badlogic.androidgames.ndk.JniUtils
```

这将在我们的 Android 项目的 jni/文件夹中创建一个名为 jniutils.h 的文件。清单 13-2 显示了它的内容。

***清单 13-2 。*** *jniutils.h，包含实现我们本地方法的 C 函数*

```java
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_badlogic_androidgames_ndk_JniUtils */

#ifndef _Included_com_badlogic_androidgames_ndk_JniUtils
#define _Included_com_badlogic_androidgames_ndk_JniUtils
#ifdef __cplusplus 
extern "C" {
#endif 
/*
 * Class:     com_badlogic_androidgames_ndk_JniUtils
 * Method:    log
 * Signature: (Ljava/lang/String;Ljava/lang/String;)V
 */
JNIEXPORT void JNICALL Java_com_badlogic_androidgames_ndk_JniUtils_log
  (JNIEnv *, jclass, jstring, jstring);
/*
 * Class:     com_badlogic_androidgames_ndk_JniUtils
 * Method:    copy
 * Signature: (Ljava/nio/ByteBuffer;FII)V
 */
JNIEXPORT void JNICALL Java_com_badlogic_androidgames_ndk_JniUtils_copy
  (JNIEnv *, jclass, jobject, jfloatArray, jint, jint);

#ifdef __cplusplus 
}
#endif 
#endif
```

是时候实现这些功能了。首先，我们在 jni/文件夹中创建一个名为 jniutils.cpp 的新文件。清单 13-3 显示了它的内容。

***[清单 13-3 。*** *jniutils.cpp，jniutils 原生方法的实现*

```java
#include <android/log.h>
#include <string.h>
#include "jniutils.h"
```

我们需要几个 C includes，即 log.h，它是由 NDK、string.h 和我们自己的 jniutils.h 提供的。第一个 include 让我们可以使用原生的 Android 日志功能。第二个 include 让我们使用 memcpy()。最后一个导入我们本地方法的签名以及 jni.h，它包含 JNI API。

```java
JNIEXPORT void JNICALL Java_com_badlogic_androidgames_ndk_JniUtils_log
  (JNIEnv *env, jclass clazz, jstring tag, jstring message) {
   const char *cTag = env-> GetStringUTFChars(tag, 0);
   const char *cMessage = env-> GetStringUTFChars(message, 0);

   __android_log_print(ANDROID_LOG_VERBOSE, cTag, cMessage);
   env-> ReleaseStringUTFChars(tag, cTag);
   env-> ReleaseStringUTFChars(message, cMessage);
}
```

该函数实现 JniUtils.log()方法，该方法将一个 JNIEnv 和一个 jclass 作为前两个参数。env 参数允许我们直接使用 JVM。jclass 参数表示 JniUtils 类。记住我们的方法是静态方法。与前面的例子不同，我们得到了一个 jobject，而是一个类。标签和消息参数是我们从 Java 传入的两个字符串。

log.h 头定义了一个名为 __android_log_print 的函数，类似于标准的 C printf 函数。它采用一个日志级别和两个表示标记和消息的 char*指针。我们的标记和消息参数具有 jstring 类型，不能转换为 char*指针。相反，我们必须通过 env 参数公开的方法将它们临时转换成 char*指针。这是通过调用 env-> GetStringUTFChars()在函数的前两行中完成的。

接下来，我们简单地调用 logging 方法，传入参数。最后，我们需要清理转换后的字符串，这样我们就不会泄漏内存。这是通过 env-> ReleaseStringUTFChars()完成的。

```java
JNIEXPORT void JNICALL Java_com_badlogic_androidgames_ndk_JniUtils_copy
  (JNIEnv *env, jclass clazz, jobject dst, jfloatArray src, jint offset, jint len) {
    unsigned char* pDst = (unsigned char* )env-> GetDirectBufferAddress(dst);
    float* pSrc = (float* )env-> GetPrimitiveArrayCritical(src, 0);
    memcpy(pDst, pSrc + offset, len * 4);
    env-> ReleasePrimitiveArrayCritical(src, pSrc, 0);
}
```

第二个函数接受一个直接的 ByteBuffer、一个 float 数组、一个 float 数组的偏移量以及我们想要复制的 float 的数量。注意，ByteBuffer 的类型是 jobject！无论何时传入除基本类型或数组之外的任何东西，都会得到一个 jobject。您的 C/C++ 代码需要知道预期的类型！在我们的例子中，我们知道我们得到了一个 ByteBuffer 实例。ByteBuffer 实例只是本机内存区域周围的薄薄的包装。它们在 C 语言中非常容易处理；我们可以简单地通过 env-> GetDirectBufferAddress()获取指向它们的内存地址的指针。

我们的浮点数组有点难以处理。env-> GetPrimitiveArrayCritical()方法将锁定数组并返回指向其第一个元素的指针。使用该功能是危险的；您不应该尝试在 Java 中同时修改数组。从这一点开始，也禁止调用任何其他 JNI 方法。否则，您将在 C/C++ 代码中得到难以调试的行为！

一旦有了指针，我们只需使用 memcpy()将 float 数组的内容复制到 ByteBuffer。注意，我们不执行任何类型的边界检查，这意味着调用该方法的 Java 代码必须是防弹的。试图将比我们分配的更多的浮点复制到 ByteBuffer 中可能会导致严重的分段错误。当我们在传入的浮点数组之外指定偏移量和长度时，情况也是如此。总的来说，当你使用 JNI 和 NDK 时，你必须知道你在做什么。如果不这样做，您的应用将会出现难以调试的错误！

在函数的最后，我们通过调用 env-> ReleasePrimitiveArrayCritical()再次解锁浮点数组。在任何情况下都必须调用此方法；否则你会遇到各种各样的问题。

有了 C/C++ 头文件和源文件，就该构建共享库了。

构建共享库

如前所述，NDK 有自己的构建系统。虽然它仍然使用标准的 makefiles，但是作为用户，您不必处理它们的复杂性。相反，您需要编写两个文件:一个 Application.mk 文件，指定您希望针对的 CPU 架构；另一个 Android.mk 文件，定义您希望链接到的其他库、要编译的源文件以及最终共享库的调用方式。

Application.mk 文件放在 jni/文件夹中。清单 13-4 显示了它的内容。

***清单 13-4 。*** *Application.mk，定义我们要瞄准的 CPUs】*

```java
APP_ABI := armeabi armeabi-v7a x86 mips
```

这就是全部了！它定义了我们的本地代码应该运行的四种架构。ARM 架构是最常见的目标——几乎所有当前的 Android 设备都有 ARM CPU。据传闻，x86 架构可以在即将发布的英特尔设备中找到。也有一些仿真器镜像支持这种架构。MIPS 架构目前被少数低端 Android 平板电脑使用。

定义了架构之后，我们现在可以转到 Android.mk 文件，该文件指定了我们的本机代码应该如何构建。这个文件也位于 jni/文件夹中。清单 13-5 显示了内容。

***清单 13-5 。*** *Android.mk，指定我们的构建*

```java
LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)

LOCAL_MODULE    := jniutils
LOCAL_LDLIBS := − llog
LOCAL_ARM_MODE  := arm
LOCAL_SRC_FILES := jniutils.cpp
include $(BUILD_SHARED_LIBRARY)

The first two lines are prettyThe first two lines are pretty The first two lines are pretty
```

前两行几乎是样板文件。它们确保路径被正确处理，并且各种变量被重置。

下一行定义了我们共享库的名称，在本例中是 jniutils。

接下来，我们指定要链接的库。我们使用原生的 Android 日志记录工具，所以我们链接到 NDK 提供的 liblog 库。

下一行特定于 ARM 架构。它告诉构建系统我们想要生成非 thumb 代码。ARM 处理器有两种工作模式，thumb 和 32 位 ARM。前者会产生更小的代码，但通常会更慢。对于我们的 C/C++ 代码来说，这并不重要，但是启用这个选项是一个很好的实践。

接下来，我们指定应该编译的 C/C++ 源文件。我们只有一份文件。要指定附加文件，只需将它们添加到同一行，用空格隔开，或者添加到新的一行。如果您选择第二个选项，您必须在前一行的末尾追加一个反斜杠。

最后一行告诉构建系统生成一个共享库。我们也可以让它生成一个静态库，然后我们将它编译成一个与其他静态库共享的库。这是更复杂的 JNI 项目使用的机制。我们对一个简单的共享库很满意。

注意 NDK 的建造系统是一个非常复杂的系统。使用 Android.mk 和 Application.mk 文件，您几乎可以修改构建代码的任何方面。如果您想了解关于构建系统的更多信息，请查看您的 NDK 安装的 doc/文件夹。

现在是时候建立我们的共享库了。为此，打开终端，确保 PATH 环境变量正常，导航到项目的根目录，发出以下命令:

```java
ndk-build
```

如果一切顺利，您应该会看到以下输出:

```java
Compile++ arm    : jniutils <= jniutils.cpp
In file included from jni/jniutils.h:2:0,
                 from jni/jniutils.cpp:2:
D:/workspaces/book/android-ndk-r8b/platforms/android-14/arch-arm/usr/include/jni.h:592:13: note: the mangling of 'va_list' has changed in GCC 4.4
StaticLibrary  : libstdc++.a
SharedLibrary  : libjniutils.so
Install        : libjniutils.so => libs/armeabi/libjniutils.so
Compile++ arm    : jniutils <= jniutils.cpp
In file included from jni/jniutils.h:2:0,
                 from jni/jniutils.cpp:2:
D:/workspaces/book/android-ndk-r8b/platforms/android-14/arch-arm/usr/include/jni.h:592:13: note: the mangling of 'va_list' has changed in GCC 4.4
StaticLibrary  : libstdc++.a
SharedLibrary  : libjniutils.so
Install        : libjniutils.so => libs/armeabi-v7a/libjniutils.so
Compile++ x86    : jniutils <= jniutils.cpp
StaticLibrary  : libstdc++.a
SharedLibrary  : libjniutils.so
Install        : libjniutils.so => libs/x86/libjniutils.so
Compile++ mips   : jniutils <= jniutils.cpp
StaticLibrary  : libstdc++.a
SharedLibrary  : libjniutils.so
Install        : libjniutils.so => libs/mips/libjniutils.so
```

这个神秘的输出告诉我们一些事情。首先，我们的代码分别针对四种 CPU 架构进行了编译。生成的共享库都称为 libjniutils.so，它们放在 libs/文件夹中。每个架构都有一个子目录(例如 armeabi 或 x86)。当我们编译我们的 APK 时，这些共享库被打包到我们的应用中。当我们调用 System.loadLibrary()时，如清单 13-1 中的所示，Android 知道在哪里为我们的应用当前运行的架构找到正确的共享库。太好了，让我们来测试一下！

**注意**每次修改 C/C++ 代码时，您都必须调用 ndk-build 来重建共享库。如果您有多个源文件，并且只修改了文件的一个子集，构建工具将只重新编译发生更改的文件，从而减少编译时间。如果需要确保所有源文件都被重新编译，只需调用 ndk-build clean。

把这一切放在一起

我们现在已经准备好测试我们的本地方法了。让我们创建一个调用两个 JniUtils 方法的测试。我们调用 JniUtilsTest 类，它扩展了 GLGame 类，并像往常一样包含一个 GLScreen 实现。它只是将一个 float[]数组复制到一个直接的 ByteBuffer 中，然后通过另一个本地方法将 ByteBuffer 的内容输出到 LogCat。清单 13-6 显示了完整的代码。不要忘记将它添加到 NdkStarter 类和清单文件中。

***清单 13-6 。****JniUtilsTest.java，测试我们的原生方法*

```java
package com.badlogic.androidgames.ndk;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;

import com.badlogic.androidgames.framework.Game;
import com.badlogic.androidgames.framework.Screen;
import com.badlogic.androidgames.framework.impl.GLGame;
import com.badlogic.androidgames.framework.impl.GLScreen;

public class JniUtilsTestextends GLGame {

    public Screen getStartScreen() {
        return new JniUtilsScreen(this);
    }

    class JniUtilsScreenextends GLScreen {
        public JniUtilsScreen(Game game) {
            super (game);
            float[] values = { 1.231f, 554.3f, 348.6f, 499.3f };
            ByteBuffer buffer = ByteBuffer.allocateDirect(3 * 4);
            buffer.order(ByteOrder.nativeOrder());

            JniUtils.copy(buffer, values, 1, 3);
            FloatBuffer floatBuffer = buffer.asFloatBuffer();
            for (int i = 0; i < 3; i++) {
                JniUtils.log("JniUtilsTest", Float.toString(floatBuffer.get(i)));
            }
        }
        @Override
        public void update(float deltaTime) {
        }
        @Override
        public void present(float deltaTime) {
        }

        @Override
        public void pause() {
        }
        @Override

        public void resume() {
        }

        @Override
        public void dispose() {
        }
    }
}
```

所有重要的事情都发生在屏幕的构造函数中。我们首先创建一个小型 float[]数组，其中包含一些虚拟值和一个直接 ByteBuffer 实例，该实例可以容纳 12 个字节，即 4 个浮点数。我们还确保 ByteBuffer 实例使用本机字节顺序，这样当我们将它传递给 C/C++ 代码时就不会遇到一些令人讨厌的问题。

然后，我们从 float[]数组复制三个浮点数，从索引 1 开始，到 ByteBuffer 实例。最后几行通过我们的本地日志记录方法输出复制的浮点。

在设备上执行此代码将在 LogCat 中输出以下内容:

```java
08–15 17:28:31.953: V/JniUtilsTest(1901): 554.3
08–15 17:28:31.953: V/JniUtilsTest(1901): 348.6
08–15 17:28:31.953: V/JniUtilsTest(1901): 499.3
```

正是我们所期待的。让我们快速修改 Vertices 和 Vertices3 类，以使用我们新的、更快的 copy()方法。

修改 vertices 类从一个问题开始:JniUtils 类不在 com . bad logic . androidgames . framework 包中；而是在 com.badlogic.androidgames.ndk 包中。让我们把它移到框架包中，这样我们就可以重用它了。

这就引出了一个新问题。我们的 C/C++ 头文件和源文件依赖于 JniUtils 类在 ndk 包中这一事实。既然我们已经将它移动到框架包中，我们必须相应地修改头文件和源文件。我们需要做的第一件事是再次调用 javah。这将更新 jniutils.h 文件。接下来，我们必须将新的函数名复制到 jniutils.cpp 文件中。最后，我们需要通过调用 ndk-build 来重新编译共享库。这么小的变化要做相当多的工作。

**注意**如果您在命令行上重建共享库，Eclipse 和 ADT 插件本身不会选择新的共享库。如果你在编译完共享库后立即运行你的应用，它仍然会使用旧的共享库！要解决这个问题，请在 Eclipse 的 Package Explorer 视图中选择您的 Android 项目，然后按 F5。

既然我们已经固定了 JniUtils 类的位置，我们可以修改 Vertices 和 Vertices3 类了。两者都有一个名为 IntBuffer 类型的顶点的字段。我们现在可以将这些字段改为 ByteBuffer 实例。我们还可以去掉两个类中的 tmpBuffer 字段，因为我们不再需要转换任何东西。我们需要做的就是修改构造函数，以便它们可以再次编译，并修改 setVertices()方法，以便它们可以使用我们的本地方法。清单 13-7 和清单 13-8 分别显示了顶点和顶点 3 发生变化的部分。

***清单 13-7 。****【Vertices.java】节选，用 JniUtils*

```java
public class Vertices {
    final GLGraphics glGraphics;
    final boolean hasColor;
    final boolean hasTexCoords;
    final int vertexSize;
    final ByteBuffer vertices;
    final ShortBuffer indices;

    public Vertices(GLGraphics glGraphics,int maxVertices,int maxIndices,boolean hasColor,boolean hasTexCoords) {
        this .glGraphics = glGraphics;
        this .hasColor = hasColor;
        this .hasTexCoords = hasTexCoords;
        this .vertexSize = (2 + (hasColor?4:0) + (hasTexCoords?2:0)) * 4;

        this .vertices = ByteBuffer.allocateDirect(maxVertices * vertexSize);
        this .vertices.order(ByteOrder.nativeOrder());

        if (maxIndices > 0) {
            ByteBuffer buffer = ByteBuffer.allocateDirect(maxIndices * Short.SIZE / 8);
            buffer.order(ByteOrder.nativeOrder());
            this. indices = buffer.asShortBuffer();
        }else {
            this .indices = null;
        }
    }
    public void setVertices(float[] vertices,int offset,int length) {
        this .vertices.clear();
        JniUtils.copy(this .vertices, vertices, offset, length);
        this .vertices.position(length * 4);
    }
    public void bind() {
        GL10 gl = glGraphics.getGL();

        gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
        vertices.position(0);
        gl.glVertexPointer(2, GL10.GL_FLOAT, vertexSize, vertices);

        if (hasColor) {
            gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
            vertices.position(8);
            gl.glColorPointer(4, GL10.GL_FLOAT, vertexSize, vertices);
        }

        if (hasTexCoords) {
            gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
            vertices.position(hasColor?24:8);
            gl.glTexCoordPointer(2, GL10.GL_FLOAT, vertexSize, vertices);
        }
    }
// rest as before
```

***清单 13-8 。****【Vertices3.java】节选，用 JniUtils*

```java
public class Vertices3 {
    final GLGraphics glGraphics;
    final boolean hasColor;
    final boolean hasTexCoords;
    final boolean hasNormals;
    final int vertexSize;
    final ByteBuffer vertices;
    final ShortBuffer indices;

    public Vertices3(GLGraphics glGraphics,int maxVertices,int maxIndices,
            boolean hasColor,boolean hasTexCoords,boolean hasNormals) {
        this .glGraphics = glGraphics;
        this .hasColor = hasColor;
        this .hasTexCoords = hasTexCoords;
        this .hasNormals = hasNormals;
        this .vertexSize = (3 + (hasColor ? 4 : 0) + (hasTexCoords ? 2 : 0) + (hasNormals ? 3  : 0)) * 4;

        this .vertices = ByteBuffer.allocateDirect(maxVertices * vertexSize);
        this .vertices.order(ByteOrder.nativeOrder());

        if (maxIndices > 0) {
            ByteBuffer buffer = ByteBuffer.allocateDirect(maxIndices * Short.SIZE / 8);
            buffer.order(ByteOrder.nativeOrder());
            this .indices = buffer.asShortBuffer();
        }else {
            this .indices = null;
        }
    }
    public void setVertices(float[] vertices,int offset,int length) {
        this .vertices.clear();
        JniUtils.copy(this .vertices, vertices, offset, length);
        this .vertices.position(length * 4);
    }
    public void bind() {
        GL10 gl = glGraphics.getGL();

        gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
        vertices.position(0);
        gl.glVertexPointer(3, GL10.GL_FLOAT, vertexSize, vertices);

        if (hasColor) {
            gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
            vertices.position(12);
            gl.glColorPointer(4, GL10.GL_FLOAT, vertexSize, vertices);
        }

        if (hasTexCoords) {
            gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
            vertices.position(hasColor ? 28 : 12);
            gl.glTexCoordPointer(2, GL10.GL_FLOAT, vertexSize, vertices);
        }

        if (hasNormals) {
            gl.glEnableClientState(GL10.GL_NORMAL_ARRAY);
            int offset = 12;
            if (hasColor)
                offset += 16;
            if (hasTexCoords)
                offset += 8;
            vertices.position(offset);
            gl.glNormalPointer(GL10.GL_FLOAT, vertexSize, vertices);
        }
    }
// rest as before
```

最大的变化在 setVertices()和 bind()中。在 setVertices()中，我们现在使用 JniUtils 类将 float[]数组复制到直接 ByteBuffer 实例。注意，我们手动设置缓冲器的极限和位置。这是必要的，因为我们的 JNI 方法不操纵缓冲区的位置和限制字段。但是，我们将缓冲区传递给的 OpenGL ES 方法可能会使用该信息。

在 bind()中，我们必须修改位置偏移量，因为我们现在是以字节而不是整数计数。

**注意**如果你注意的话，你会发现我们可以对 ByteBuffer 的索引做同样的事情。这需要向 JniUtils 添加一个新的本机方法，该方法采用一个短数组。试试看！

通过使用我们的 native copy()方法，我们可以获得相当大的速度，特别是当我们通过 SpriteBatcher 类绘制许多精灵时。每一帧都必须将顶点从 CPU 移动到 GPU 会降低性能，而通过先制作副本然后将所有内容转换为 int 来这样做甚至更糟。我们新的 JniUtils 大大减少了复制的数量，同时也比我们之前使用的 IntBuffer 技巧更快！

要测试我们的实现，只需复制 SpriteBatcherTest 和 ObjTest 以及前面章节中所有必要的素材。将它们与 NdkStarter 活动联系起来，并在您的 Android 设备上试用它们。

摘要

我们仅仅触及了 NDK 的皮毛。但是，正如您所看到的，即使是轻量级使用 NDK 也能获得可观的回报。我们的 copy()方法实现起来很简单，但是通过比旧的基于 Java 的实现快得多，我们可以每帧显示更多的精灵。这是 NDK 开发中一个反复出现的主题:识别瓶颈，在本机端只实现非常小的代码片段。不要走极端，因为调用本机方法有开销。仅仅让所有东西都成为本机方法不可能提高应用的性能。

现在是时候考虑我们游戏的营销因素了。*