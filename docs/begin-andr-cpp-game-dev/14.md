# 十四、附录 C：C++ 编程

C++ 是一种编程语言，它为解决问题提供了几乎无限多的选项。这本书使用了一些初学者可能不熟悉的技术。本附录旨在介绍一些更高级的语言特性。

朋友关键字

C++ 类可以包含不同范围的字段和方法。这些可用的作用域是公共的、私有的和受保护的。

*   公共范围确保所有的字段和方法都可以从类本身的外部访问。
*   私有字段和方法只能从在同一个类中声明的方法中访问。
*   受保护的字段和方法类似于 private，但也可以由派生类访问。

人们通常希望能够从类外部访问私有字段或方法，但只能在受限制的地方访问。这些受限的地方可能是其他的类或者函数。实现这一点的一种方法是公开这些字段和方法；然而，这允许任何类或函数访问。另一个选择是使用`friend`关键字。考虑清单 C-1 中的类。

[***清单 C-1。***](#_list1) 一`Simple`类

```cpp
class Simple
{
private:
       void Interact();
}

```

如您所见，`Interact`方法是私有的，因此只能从同一个类中的其他方法访问。如果我们有另一个我们希望能够访问这个方法的类，我们可以让它成为朋友，如清单 C-2 中的[所示。](#list2)

[***清单 C-2。***](#_list2) `Simple`类‘朋友’

```cpp
class SimpleFriend
{
public:
       void Interact(Simple* pSimple)
       {
              pSimple->Interact();
       }
}

class Simple
{
       friend class SimpleFriend;

private:
       void Interact();
}

```

[清单 C-2](#list2) 展示了我们如何使用`friend`关键字为特定的类提供对私有字段和数据的访问。

模板

C++ 是一种类型安全的语言。这意味着编译器在编译时必须知道所有变量的预期类型。有时，这种对类型的严格使用会导致大量的重复代码，而这些代码只是为了提供相同的功能来处理不同类型的对象。幸运的是，C++ 以模板的形式提供了一个解决方案。

模板允许我们创建通用的代码实现，并在代码中需要时指定特定的类型。

[清单 C-3](#list3) 展示了返回两个数的最小值的两种方法。

[***清单 C-3。***](#_list3) min 功能

```cpp
inline int min(int a, int b)
{
       return (a<b) ? a : b;
}

inline float min(float a, float b)
{
       return (a<b) ? a : b;
}

```

如果我们继续沿着这条路走下去，我们将不得不为 C++ 支持的每种类型提供不同版本的`min`。相反，[清单 C-4](#list4) 展示了我们如何使用模板实现`min`。

[***清单 C-4。***](#_list4) 临时化最小

```cpp
template<class T>
inline const T& min(const T& a, const T& b)
{
       return (a < b) ? a : b;
}

```

这里你可以看到我们没有指定函数的多个版本，类型已经被替换为`T`。`T`来自第一行，它告诉编译器这个方法是一个模板，并使用`T`来代替特定的类型。如果您将`T`更改为不同的东西，您还需要在函数本身中进行更改。这个模板的另一个不同之处是函数参数和返回值是通过引用传递的。最初的`int`和`float`方法返回内置类型，因此是简单的四字节副本。由于该模板可能用于类，所以通过引用传递以确保不会在这些对象上调用复制构造函数是很重要的。

现在来看使用清单 C-5 中的模板的代码。

[***清单 C-5。***](#_list5) 使用模板

```cpp
min<int>(1, 2);
min<float>(1.0f, 2.0f);

```

这里的代码显示，我们现在可以指定我们希望在需要的地方和时间使用的`min`的类型。C++ 将只为我们在代码中实际使用的类型创建特定版本的`min`。

单一模式

本书提供的代码示例利用了 singleton 模式。模式的具体实现可以在样本代码中看到，样本代码可以从本书附带的网站`http://www.apress.com/9781430258308`获得。

singleton 模式用于在整个代码中提供对单个对象实例的全局访问。许多人不同意使用全局对象；然而，它们可以在游戏开发中提供有用的特性。例如，渲染器和音频管理器是我们在游戏开发中经常只需要一个实例的对象。

通过使用单例，我们可以确保我们有这些对象的单个实例，我们可以从代码中的任何地方访问它们。以一种我们仍然必须在对象上调用 new 和 delete 的方式实现单例也意味着我们可以控制如何以及在哪里为对象分配内存。对象唯一的全局特征是静态指针，我们用它来访问我们的实例。

所使用的 singleton 类的原作者是 Scott Bilas。Scott 在他的网站`http://scottbilas.com/publications/gem-singleton/`上有该技术的完整源代码和详细解释。