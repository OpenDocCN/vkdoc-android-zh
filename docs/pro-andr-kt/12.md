# 12.沟通

通信是指通过组件、应用或设备边界发送数据。一个或多个应用的组件相互通信的标准方式是使用*广播*，这在第 [5](05.html) 章中讨论过。

在一个设备上进行应用程序间通信的另一种可能性是使用`ResultReceiver`对象，这些对象通过意图传递。不管它们的名字是什么，它们不仅可以在被调用的组件完成它的工作时，而且可以在它还活着的任何时候将数据发送回调用者。我们在这本书的几个地方使用了它们，但是在这一章中，我们将复习如何使用它们来实现所有的交流方式。

对于通过设备边界的通信，选项是众多的，如果我们可以使用基于云的通信平台，则更是如此。我们将讨论使用基于云的服务和通过互联网直接通信的应用程序间通信。

## 结果接收器类

通过将一个`ResultReceiver`对象分配给一个 intent，它可以从任何一个组件传递到另一个组件，因此您可以使用它在任何类型的组件之间发送数据，只要它们位于相同的设备上。

我们首先子类化一个`ResultReceiver`，它稍后将从一个被调用的组件接收消息，并编写以下代码:

```java
class MyResultReceiver : ResultReceiver(null) {
  companion object {
    val INTENT_KEY = "my.result.receiver"
    val DATA_KEY = "data.key"
  }
  override fun onReceiveResult(resultCode: Int,
        resultData: Bundle?) {
    super.onReceiveResult(resultCode, resultData)
    val d = resultData?.get(DATA_KEY) as String
    Log.e("LOG", "Received: " + d)
  }
}

```

当然，你可以在它的`onReceiveResult()`函数内部写更多有意义的东西。

为了将一个`MyResultReceiver`的实例传递给一个被调用的组件，我们现在可以编写以下或任何其他方法来调用另一个组件:

```java
Intent(this, CalledActivity::class.java).apply {
    putExtra(MyResultReceiver.INTENT_KEY,
          MyResultReceiver())
}.run{ startActivity(this) }

```

在被调用的组件内部，您现在可以在任何合适的位置通过类似下面的方式向调用组件发送数据:

```java
var myReceiver:ResultReceiver? = null

override fun onCreate(savedInstanceState: Bundle?) {
  super.onCreate(savedInstanceState)
  setContentView(R.layout.activity_called)
  ...
  myReceiver = intent.
        getParcelableExtra<ResultReceiver>(
        MyResultReceiver.INTENT_KEY)
}

fun go(v: View) {
  val bndl = Bundle().apply {
      putString(MyResultReceiver.DATA_KEY,
        "Hello from called component")
  }
  myReceiver?.send(42, bndl) ?:
        throw IllegalStateException("myReceiver is null")
}

```

在生产环境中，您还需要检查接收者是否还活着。为了简洁起见，我省略了这个检查。还要注意，在发送端，实际上不需要对`ResultReceiver`实现的引用；如果您通过应用程序边界进行交流，您可以只写以下内容:

```java
...
val INTENT_KEY = "my.result.receiver"
val DATA_KEY = "data.key"
...
val myReceiver = intent.
    getParcelableExtra<ResultReceiver>(
    INTENT_KEY)
...
val bndl = Bundle().apply {
  putString(DATA_KEY,
    "Hello from called component")
}
myReceiver?.send(42, bndl)

```

## Firebase 云消息传递

Firebase Cloud Messaging (FCM)是一个基于云的消息代理，可以用来发送和接收来自各种设备的消息，包括其他操作系统，如 Apple iOS。想法如下:你在 Firebase 控制台中注册一个应用程序，从此可以在连接的设备上接收和发送消息，包括在其他设备上安装你的应用程序。

### 注意

Firebase 云消息是 Google 云消息(GCM)的继任者。文档说你应该更喜欢 FCM 而不是 GCM。在本书中，我们讨论 FCM 如果你需要关于 GCM 的信息，请参考在线资源。

要从 Android Studio 内部启动 FCM，从您打开的项目进入工具➤ Firebase 的各种向导。选择云消息，然后设置 Firebase 云消息。如果您遵循那里的说明，您将最终使用两个服务。

`FirebaseInstanceIdService`的子类，您将在其中接收消息令牌。这个类基本上是这样的:

```java
class MyFirebaseInstanceIdService :
      FirebaseInstanceIdService() {
  override
  fun onTokenRefresh() {
      // Get updated InstanceID token.
      val refreshedToken =
          FirebaseInstanceId.getInstance().token
      Log.d(TAG, "Refreshed token: " +
          refreshedToken!!)
  }
}

```

它在`AndroidManifest.xml`中有一个对应的条目。

```java
<service
  android:name=".MyFirebaseInstanceIdService"
  android:enabled="true"
  android:exported="true">
    <intent-filter>
      <action android:name=
          "com.google.firebase.INSTANCE_ID_EVENT"/>
    </intent-filter>
</service>

```

当您第一次启动连接到 Firebase 的应用程序时，您在此收到的令牌非常重要；您需要它来使用基于 Firebase 的通信通道。该令牌不经常自动更新，因此您需要找到一种方法，以便在收到该服务中的令牌时可靠地存储该令牌。帮自己一个忙:除非您实现了存储令牌的方法，否则一定要将收到的令牌保存在日志中，因为恢复丢失的令牌会导致烦人的管理工作。

另一个服务负责接收基于 FCM 的消息。其内容如下:

```java
class MyFirebaseMessagingService :
      FirebaseMessagingService() {
  override
  fun onMessageReceived(remoteMessage:
        RemoteMessage) {
    // ...
    // Check if message contains a data payload.
    if (remoteMessage.data.size > 0) {
      Log.d(TAG, "Message data payload: " +
            remoteMessage.data)

    // Implement a logic:
    // For long-running tasks (10 seconds or more)
    // use Firebase Job Dispatcher.
    scheduleJob()
    // ...or else handle message within 10 seconds
    // handleNow()
  }

  // Message contains a notification payload?
    remoteMessage.notification?.run {
      Log.d(TAG, "Message Notification Body: " +
            body)
    }
  }

  private fun handleNow() {
      Log.e("LOG","handleNow()")
  }

  private fun scheduleJob() {
      Log.e("LOG","scheduleJob()")
  }
}

```

这在`AndroidManifest.xml`中也有相应的条目。

```java
<service
    android:name=".MyFirebaseMessagingService"
    android:enabled="true"
    android:exported="true">
  <intent-filter>
    <action android:name=
          "com.google.firebase.MESSAGING_EVENT"/>
  </intent-filter>
</service>

```

要做到这一点，你需要在你的谷歌账户中激活 Firebase。有几种选择，对于高流量的信息服务，你需要购买一个计划。然而，免费版本(截至 2018 年 3 月)将为您提供足够的开发和测试能力。

如果一切设置正确，您可以使用基于 web 的 Firebase 控制台来测试向您正在运行的应用程序发送消息，并在日志中查看到达那里的消息。

### 注意

Firebase 不仅仅是消息传递；请参考您在 Firebase 控制台中找到的在线文档和信息，以及 Android Studio 给您的信息，以了解还可以做些什么。

对于发送消息，建议的解决方案是以应用服务器的形式建立一个可信环境。这超出了本书的范围，但是在线 Firebase 文档为您提供了各种提示。

## 与后端的通信

如前所述，使用像 Firebase 这样的基于云的提供商将你的应用程序连接到其他设备上的其他应用程序，当然有不同的优点。您有一个可靠的消息代理，它有消息备份工具、分析工具等等。

但是使用云也有它的缺点。你的数据，无论是否加密，都将离开你的房子，甚至对于企业应用程序来说也是如此，你不能 100%确定提供商不会在未来某个时候改变 API，迫使你改变你的应用程序。所以，如果你需要更多的控制，你可以放弃云，转而使用直接联网。

对于直接使用网络协议与设备或应用服务器通信，您基本上有两种选择。

*   **使用 javax . net . SSL . http surlcconnection**

    这提供了一个低级的连接，但是包括 TLS、流功能、超时和连接池。从类名可以看出，它是标准 Java API 的一部分，所以你可以在网上找到很多关于它的信息。尽管如此，我们还是在下一节给出了描述。

*   **使用 Android 附带的凌空 API**

    这是基本网络功能的高级包装。使用凌空大大简化了基于网络的开发，因此它通常是在 Android 中使用网络的首选。

在这两种情况下，您都需要在`AndroidManifest.xml`中添加适当的权限。

```java
<uses-permission android:name=
      "android.permission.INTERNET" />
<uses-permission android:name=
      "android.permission.ACCESS_NETWORK_STATE" />

```

## 与 HttpsURLConnection 的通信

在使用网络通信 API 之前，我们需要确保网络操作发生在后台；现代的 Android 版本甚至不允许你在 UI 线程中执行联网。但是即使没有这种限制，也强烈建议总是在后台任务中执行联网。我们在第九章中谈到了后台操作。您想看的第一种方法是在`AsyncTask`中运行网络操作，但是您也可以自由选择其他方法。下面几节假设这里展示的代码片段在后台运行。

使用基于类`HttpsURLConnection`的通信可以归结为以下几点:

```java
fun convertStreamToString(istr: InputStream): String {
  val s = Scanner(istr).useDelimiter("\\A")
  return if (s.hasNext()) s.next() else ""
}

// This is a convention for emulated devices
// addressing the host (development PC)
val HOST_IP = "10.0.2.2"

val url = "https://${HOST_IP}:6699/test/person"
var stream: InputStream? = null
var connection: HttpsURLConnection? = null
var result: String? = null
try {
  connection = (URL(uri.toString()).openConnection()
        as HttpsURLConnection).apply {

    // ! ONLY FOR TESTING ! No SSL hostname verification
    class TrustAllHostNameVerifier : HostnameVerifier {
      override
      fun verify(hostname: String, session: SSLSession):
            Boolean = true
    }
    hostnameVerifier = TrustAllHostNameVerifier()

    // Timeout for reading InputStream set to 3000ms
    readTimeout = 3000
    // Timeout for connect() set to 3000ms.
    connectTimeout = 3000
    // For this use case, set HTTP method to GET.
    requestMethod = "GET"
    // Already true by default, just telling. Needs to
    // be true since this request is carrying an input
    // (response) body.
    doInput = true
    // Open communication link
    connect()
    responseCode.takeIf {
          it != HttpsURLConnection.HTTP_OK }?.run {
      throw IOException("HTTP error code: $this")
    }
    // Retrieve the response body
    stream = inputStream?.also {
      result = it.let { convertStreamToString(it) }
    }
  }
} finally {
  stream?.close()
  connection?.disconnect()
}

Log.e("LOG", result)

```

这个例子试图访问一个针对您的开发 PC 的 GET URL`https://10.0.2.2:6699/test/person`,并在日志中打印结果。

注意，如果您的服务器碰巧持有 SSL 的自签名证书，您必须在初始化位置，比如在`onCreate()`回调中，添加以下内容:

```java
val trustAllCerts =
      arrayOf<TrustManager>(object : X509TrustManager {
    override
    fun getAcceptedIssuers():
      Array<java.security.cert.X509Certificate>? = null
    override
    fun checkClientTrusted(
      certs: Array<java.security.cert.X509Certificate>,
      authType: String) {
    }
    override
    fun checkServerTrusted(
      certs: Array<java.security.cert.X509Certificate>,
      authType: String) {
    }
})

SSLContext.getInstance("SSL").apply {
  init(null, trustAllCerts, java.security.SecureRandom())
}.apply {
  HttpsURLConnection.setDefaultSSLSocketFactory(
        socketFactory)
}

```

否则，前面的代码将会报错并失败。当然，与生产代码中的自签名证书相比，您更喜欢官方签名证书。

## 与凌空联网

凌空是一个网络库，简化了 Android 的网络。第一，凌空自己把作品发到后台；你不用管这个。凌空提供的其他好处如下:

*   调度机制

*   并行处理多个请求

*   JSON 请求和响应的处理

*   贮藏

*   诊断工具

要开始使用凌空开发，将依赖项添加到模块的`build.gradle`文件中，如下所示:

```java
dependencies {
  ...
  implementation 'com.android.volley:volley:1.1.0'
}

```

接下来要做的事情是设置一个`RequestQueue`,凌空使用它在后台处理请求。最简单的方法是在活动中写下以下内容:

```java
val queue = Volley.newRequestQueue(this)

```

但是您也可以定制一个`RequestQueue`的创建，改为编写以下代码:

```java
val CACHE_CAPACITY = 1024 * 1024 // 1MB
val cache = DiskBasedCache(cacheDir, CACHE_CAPACITY)
// ... or a different implementation

val network = BasicNetwork(HurlStack())
// ... or a different implementation

val requestQueue = RequestQueue(cache, network).apply {
  start()
}

```

问题是，在哪个范围下定义请求队列最好？我们可以在活动的范围内创建并运行请求队列，这意味着每次活动重新创建自己时，都需要重新创建队列。这是一个有效的选项，但是文档建议使用应用程序范围来减少缓存的重新创建。推荐的方法是使用`Singleton`模式，其结果如下:

```java
class RequestQueueSingleton
      constructor (context: Context) {
  companion object {
    @Volatile
    private var INSTANCE: RequestQueueSingleton? = null
    fun getInstance(context: Context) =
        INSTANCE ?: synchronized(this) {
            INSTANCE ?: RequestQueueSingleton(context)
        }
  }
  val requestQueue: RequestQueue by lazy {
    val alwaysTrusting = object : HurlStack() {
      override
      fun createConnection(url: URL): HttpURLConnection {
        fun getHostnameVerifier():HostnameVerifier {
          return object : HostnameVerifier {
            override
            fun verify(hostname:String,
                  session:SSLSession):Boolean = true
          }
        }
        return (super.createConnection(url) as
              HttpsURLConnection).apply {
          hostnameVerifier = getHostnameVerifier()
        }
      }
  }
  // Using the Application context is important.
  // This is for testing:
  Volley.newRequestQueue(context.applicationContext,
          alwaysTrusting)
    // ... for production use:
    // Volley.newRequestQueue(context.applicationContext)
  }
}

```

出于开发和测试目的，添加了一个 accept-all SSL 主机名验证器。

因此，不像前面那样写`val queue = Volley.newRequestQueue(this)`或`val requestQueue = RequestQueue(...)`，而是使用下面的代码:

```java
val queue = RequestQueueSingleton(this).requestQueue

```

现在，要发送一个字符串请求，您必须编写以下内容:

```java
// This is a convention for emulated devices
// addressing the host (development PC)
val HOST_IP = "10.0.2.2"

val stringRequest =
    StringRequest(Request.Method.GET,
          "https://${HOST_IP}:6699/test/person",
          Response.Listener<String> { response ->
            val shortened =
                response.substring(0,
                      Math.min(response.length, 500))
            tv.text = "Response is: ${shortened}"
          },
          Response.ErrorListener { err ->
            Log.e("LOG", err.toString())
            tv.text = "That didn't work!"
          })
queue.add(stringRequest)

```

这里，`tv`指向一个`TextView` UI 元素。为此，你需要一个响应`https://localhost:6699/test/person`的服务器。请注意，响应侦听器自动运行在 UI 线程上，因此您不必亲自处理。

要取消单个请求，在请求对象的任何地方使用`cancel()`。您也可以取消一组请求。像在`val stringRequest = ... .apply {tag = "TheTag"}`中那样给每个有问题的请求添加一个标签，然后写下`queue?.cancelAll( "TheTag" )`。一旦请求被取消，凌空确保响应监听器永远不会被调用。

要请求 JSON 对象或 JSON 数组，您必须替换以下内容:

```java
val request =
    JsonArrayRequest(Request.Method.GET, ...)

```

或者下面是我们之前使用的`StringRequest`:

```java
val request =
    JsonObjectRequest(Request.Method.GET, ...)

```

例如，对于 JSON 请求和 POST 方法，您可以编写以下代码:

```java
val reqObj:JSONObject =
      JSONObject("""{"a":7, "b":"Hello"}""")
val json1 = JsonObjectRequest(Request.Method.POST,
      "https://${HOST_IP}:6699/test/json",
      reqObj,
      Response.Listener<JSONObject> { response ->
          Log.e("LOG", "Response: ${response}")
      },
      Response.ErrorListener{ err ->
          Log.e("LOG", "Error: ${err}")
      })

```

凌空可以为你做更多；您可以使用其他 HTTP 方法，如`PUT`，也可以编写定制的请求处理并返回其他数据类型。有关更多详细信息，请参阅凌空的在线文档或其 API 文档。

## 设置测试服务器

这不是一个真正的 Android 主题，甚至也不是任何与 Kotlin 有关的东西，但是为了测试通信，您需要运行某种 web 服务器。为了简单起见，我通常基于 Groovy 和 Spark(不是 Apache Spark，而是来自 [`http://sparkjava.com`](http://sparkjava.com) `/`的 Java Spark)配置一个简单而强大的服务器。

要在 Eclipse 中使用它，首先要安装 Groovy 插件。然后创建一个 Maven 项目并添加依赖项，如下所示:

```java
<dependency>
  <groupId>com.sparkjava</groupId>
  <artifactId>spark-core</artifactId>
  <version>2.7.2</version>
</dependency>
<dependency>
  <groupId>org.slf4j</groupId>
  <artifactId>slf4j-simple</artifactId>
  <version>1.7.25</version>
  <scope>test</scope>
</dependency>

```

之后，创建一个 Java keystore 文件，编写一个 Groovy 脚本，并启动它。

```java
import static spark.Spark.*

def keystoreFilePath = "keystore.jks"
def keystorePassword = "passw7%d"
def truststoreFilePath = null
def truststorePassword = null

secure(keystoreFilePath, keystorePassword,
      truststoreFilePath, truststorePassword)
port(6699)

get("/test/person", { req, res -> "Hello World" })

post("/test/json", { req, res ->
    println(req.body())
    '{ "msg":"Hello World", "val":7 }'
})

```

### 警告

为了避免 Servlet API 版本冲突，请在 Groovy 设置对话框中删除对 Servlet API 的依赖，该对话框是通过右键单击项目中的 Groovy 库并选择 Properties 打开的。

要在 Linux 下创建一个 keystore 文件，可以使用如下 Bash 脚本，并修改 Java 路径:

```java
#!/bin/bash
export JAVA_HOME=/opt/jdk
$JAVA_HOME/bin/keytool -genkey -keyalg RSA \
  -alias selfsigned -keystore keystore.jks \
  -storepass passw7%d -validity 360 -keysize 2048

```

## 安卓和 NFC

NFC 用于在支持 NFC 的设备之间传输小数据包的短程无线连接。通信伙伴之间的范围被限制在几厘米。这些是典型的使用案例:

*   连接，然后读取或写入 NFC 标签

*   连接并与其他支持 NFC 的设备通信(点对点模式)

*   通过连接并与 NFC 读卡器和写卡器通信来模拟 NFC 卡

要开始开发一款支持 NFC 的应用，你需要在`AndroidManifest.xml`内部获得许可。

```java
<uses-permission android:name="android.permission.NFC" />

```

要限制 Google Play 商店中的可见性，请将以下内容添加到同一个文件中:

```java
<uses-feature android:name="android.hardware.nfc"
      android:required="true" />

```

## 与 NFC 标签对话

一旦启用 NFC 的设备在附近发现 NFC 标签，它会尝试根据某种算法来调度标签。如果系统确定了一个 NDEF 数据并找到了一个能够处理 NDEF 的意图过滤器，那么相应的组件就会被调用。如果标签没有展示 NDEF 数据，但是通过提供关于技术和/或有效载荷的信息来识别自身，则这组数据被映射到“技术”记录，并且系统试图找到能够处理它的组件。如果两者都失败，则发现信息仅限于发现了 NFC 标签这一事实。在这种情况下，系统试图找到一个组件，该组件可以在没有 NDEF 和没有“技术”类型数据的情况下处理 NFC 标签。

基于在 NFC 标签上找到的信息，Android 还创建了一个 URI 和一个 MIME 类型，您可以将其用于意图过滤器。Android 在线开发者文档的“NFC 基础知识”页面上有更详细的描述；在你最喜欢的搜索引擎中输入 *android develop nfc basics* 即可找到。

要编写适当的意图过滤器，请参见第 [3](03.html) 章，此外，对于“技术”风格的发现，您需要在`<activity>`中添加特定的`<meta-data>`元素，如下所示:

```java
<meta-data android:name="android.nfc.action.
 TECH_DISCOVERED"
  android:resource="@xml/nfc_tech_filter" />

```

这指向了在`res/xml`中的一个名为`nfc_tech_filter.xml`的文件，包含以下内容或其子集:

```java
<resources xmlns:xliff=
      "urn:oasis:names:tc:xliff:document:1.2">
  <tech-list>
      <tech>android.nfc.tech.IsoDep</tech>
      <tech>android.nfc.tech.NfcA</tech>
      <tech>android.nfc.tech.NfcB</tech>
      <tech>android.nfc.tech.NfcF</tech>
      <tech>android.nfc.tech.NfcV</tech>
      <tech>android.nfc.tech.Ndef</tech>
      <tech>android.nfc.tech.NdefFormatable</tech>
      <tech>android.nfc.tech.MifareClassic</tech>
      <tech>android.nfc.tech.MifareUltralight</tech>
  </tech-list>
</resources>

```

您需要添加到意图过滤器中以有助于 NFC 分派过程的操作如下:

*   对于 NDEF 探索风格，使用以下:

    ```java
    <intent-filter>
      <action android:name=
            "android.nfc.action.NDEF_DISCOVERED"/>
      ...more filter specs...
    </intent-filter>

    ```

*   对于技术探索风格，使用以下:

    ```java
    <intent-filter>
      <action android:name=
            "android.nfc.action.TECH_DISCOVERED"/>
    </intent-filter>
    <meta-data android:name=
          "android.nfc.action.TECH_DISCOVERED"
          android:resource="@xml/nfc_tech_filter" />

    ```

*   对于故障回复发现方式，请使用以下命令:

    ```java
    <intent-filter>
      <action android:name=
            "android.nfc.action.TAG_DISCOVERED"/>
      ...more filter specs...
    </intent-filter>

    ```

一旦与 NFC 相关的意图被分派，匹配活动就可以从意图中提取 NFC 信息。为此，请通过以下一种或多种方法获取额外的意向数据:

*   `NfcAdapter.EXTRA_TAG`。必需的；返回一个`android.nfc.Tag`对象。

*   `NfcAdapter.EXTRA_NDEF_MESSAGES`。可选；来自标签的 NDEF 消息。您可以通过以下方式检索它们:

    ```java
    val rawMessages : Parcelable[] =
        intent.getParcelableArrayExtra(
        NfcAdapter.EXTRA_NDEF_MESSAGES)

    ```

*   `NfcAdapter.EXTRA_ID`。可选；标签的低级 ID。

如果你想写 NFC 标签，在 Android 在线开发者文档的“NFC 基础知识”一页中有描述。

## 点对点 NFC 数据交换

Android 允许两个 Android 设备通过其*光束*技术进行 NFC 通信。过程如下:让支持 NFC 的设备的活动扩展`CreateNdefMessageCallback`并实现方法`createNdefMessage( event : NfcEvent ) : NdefMessage`。在这个方法中，创建并返回一个`NdefMessage`，如下所示:

```java
val text = "A NFC message at " +
           System.currentTimeMillis().toString()
val msg = NdefMessage( arrayOf(
        NdefRecord.createMime(
             "application/vnd.com.example.android.beam",
             text.toByteArray() )
) )

/*
 * When a device receives an NFC message with an Android
 * Application Record (AAR) added, the application
 * specified in the AAR is guaranteed to run. The AAR
 * thus overrides the tag dispatch system.
 */
//val msg = NdefMessage( arrayOf(
//      NdefRecord.createMime(
//           "application/vnd.com.example.android.beam",
//           text.toByteArray() ),
//      NdefRecord.createApplicationRecord(
//           "com.example.android.beam")
//) )
return msg

```

然后，NFC 数据接收应用可以在其`onResume()`回调中检测它是否由 NFC 发现动作发起。

```java
override
fun onResume() {
    super.onResume()
    // Check to see that the Activity started due to an
    // Android Beam event
    if (NfcAdapter.ACTION_NDEF_DISCOVERED ==
          intent.action) {
        processIntent(intent)
    }
}

```

## NFC 卡仿真

让 Android 设备像带有 NFC 芯片的智能卡一样工作需要复杂的设置和编程任务。如果您考虑安全性，这尤其有意义；一些 Android 设备可能包含一个*安全元件*，它在硬件基础上执行与读卡器的通信。一些其他设备可能应用*基于主机的卡仿真*来让设备 CPU 执行通信。NFC 卡仿真的所有细节的详尽描述超出了本书的范围，但是如果您打开 Android 在线开发人员指南中的“基于主机的卡仿真”页面，您可以在网上找到相关信息。

也就是说，我们从一个基于主机的卡仿真开始描述基本的工件。该示例基于 Android 开发人员指南提供的 HCE 示例，但它被转换为 Kotlin，并归结为仅与 NFC 相关的重要方面(该示例在 Apache 许可下运行； [`www.apache.org/licenses/LICENSE-2.0`](http://www.apache.org/licenses/LICENSE-2.0) 见)。代码内容如下:

```java
/**
 * This is a sample APDU Service which demonstrates how
 * to interface with the card emulation support added
 * in Android 4.4, KitKat.
 *
 * This sample replies to any requests sent with the
 * string "Hello World". In real-world situations, you
 * would need to modify this code to implement your
 * desired communication protocol.
 *
 * This sample will be invoked for any terminals
 * selecting AIDs of 0xF11111111, 0xF22222222, or
 * 0xF33333333\. See src/main/res/xml/aid:list.xml for
 * more details.
 *
 * Note: This is a low-level interface. Unlike the
 * NdefMessage many developers are familiar with for
 * implementing Android Beam in apps, card emulation
 * only provides a byte-array based communication
 * channel. It is left to developers to implement
 * higher level protocol support as needed.
 */
class CardService : HostApduService() {

```

如果与 NFC 卡的连接丢失，则调用`onDeactivated()`回调，让应用程序知道连接断开的原因(或者是丢失的链接，或者是读卡器选择的另一个辅助设备)。

```java
/**
 * Called if the connection to the NFC card is lost.
 * @param reason Either DEACTIVATION_LINK_LOSS or
 *     DEACTIVATION_DESELECTED
 */
override fun onDeactivated(reason: Int) {}

```

当收到 APDU 命令时，将调用`processCommandApdu()`方法。在这个方法中，可以通过返回一个字节数组来直接提供响应 APDU。一般来说，响应 APDUs 必须尽快发送，因为当调用此方法时，用户很可能将设备放在 NFC 读取器上。如果有多个服务在其元数据条目中注册了相同的辅助，则只有当用户明确选择了您的服务时，您才会被调用，无论是作为默认服务还是仅用于下一次点击。该方法运行在应用程序的主线程上。如果您不能立即返回一个响应 APDU，返回`null`并稍后使用`sendResponseApdu()`方法。

```java
/**
 * This method will be called when a command APDU has
 * been received from a remote device.
 *
 * @param commandApdu The APDU that received from the
 *     remote device
 * @param extras A bundle containing extra data. May
 *     be null.
 * @return a byte-array containing the response APDU,
 *     or null if no response APDU can be sent
 *     at this point.
*/
override
fun processCommandApdu(commandApdu: ByteArray,
      extras: Bundle): ByteArray {
    Log.i(TAG, "Received APDU: " +
          byteArrayToHexString(commandApdu))
    // If the APDU matches the SELECT AID command for
    // this service, send the loyalty card account
    // number, followed by a SELECT_OK status trailer
    // (0x9000).
    if (Arrays.equals(SELECT_APDU, commandApdu)) {
        val account = AccountStorage.getAccount(this)
        val accountBytes = account!!.toByteArray()
        Log.i(TAG, "Sending account number: $account")
        return concatArrays(accountBytes, SELECT_OK_SW)
    } else {
    return UNKNOWN_CMD_SW
  }
}

```

companion 对象包含几个常量和实用函数。

```java
companion object {
    private val TAG = "CardService"
    // AID for our loyalty card service.
    private val SAMPLE_LOYALTY_CARD_AID = "F222222222"
    // ISO-DEP command HEADER for selecting an AID.
    // Format: [Class | Instruction | Parameter 1 |
    //          Parameter 2]
    private val SELECT_APDU_HEADER = "00A40400"
    // "OK" status word sent in response to SELECT AID
    // command (0x9000)
    private val SELECT_OK_SW =
          hexStringToByteArray("9000")
    // "UNKNOWN" status word sent in response to
    // invalid APDU command (0x0000)
    private val UNKNOWN_CMD_SW =
          hexStringToByteArray("0000")
    private val SELECT_APDU =
          buildSelectApdu(SAMPLE_LOYALTY_CARD_AID)

/**
 * Build APDU for SELECT AID command. This command
 * indicates which service a reader is
 * interested in communicating with. See
 * ISO 7816-4.
 *
 * @param aid Application ID (AID) to select
 * @return APDU for SELECT AID command
 */
fun buildSelectApdu(aid: String): ByteArray {
    // Format: [CLASS | INSTRUCTION |
    //          PARAMETER 1 | PARAMETER 2 |
    //          LENGTH | DATA]
    return hexStringToByteArray(
          SELECT_APDU_HEADER +
          String.format("%02X",
                aid.length / 2) +
                aid)
          }

          /**
           * Utility method to convert a byte array to a
           * hexadecimal string.
           */
          fun byteArrayToHexString(bytes: ByteArray):
                String {
              val hexArray = charArrayOf('0', '1', '2', '3',
                    '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F')
              val hexChars = CharArray(bytes.size * 2)
              var v: Int
              for (j in bytes.indices) {
                  v = bytes[j].toInt() and 0xFF
                  // Cast bytes[j] to int, treating as
                  // unsigned value
                  hexChars[j * 2] = hexArray[v.ushr(4)]
                  // Select hex character from upper nibble
                  hexChars[j * 2 + 1] = hexArray[v and 0x0F]
                  // Select hex character from lower nibble
              }
              return String(hexChars)
          }

          /**
           * Utility method to convert a hexadecimal string
           * to a byte string.
           *
           * Behavior with input strings containing
           * non-hexadecimal characters is undefined.
           */
          fun hexStringToByteArray(s: String): ByteArray {
              val len = s.length
              if (len % 2 == 1) {
                  // TODO, throw exception
              }
              val data = ByteArray(len / 2)
              var i = 0
              while (i < len) {
                   // Convert each character into a integer
                   // (base-16), then bit-shift into place
              data[i / 2] =
                  ((Character.digit(s[i], 16) shl 4) +
                  Character.digit(s[i + 1], 16)).
                  toByte()
              i += 2
          }
          return data
    }

    /**
     * Utility method to concatenate two byte arrays.
     */
    fun concatArrays(first: ByteArray,
          vararg rest: ByteArray): ByteArray {
        var totalLength = first.size
        for (array in rest) {
            totalLength += array.size
        }
        val result =
              Arrays.copyOf(first, totalLength)
        var offset = first.size
        for (array in rest) {
            System.arraycopy(array, 0,
                  result, offset, array.size)
            offset += array.size
        }
        return result
    }
  }
}

```

`AndroidManifest.xml`中相应的服务声明如下:

```java
<service android:name=".CardService"
         android:exported="true"
         android:permission=
               "android.permission.BIND_NFC_SERVICE">
    <!-- Intent filter indicating that we support
         card emulation. -->
    <intent-filter>
        <action android:name=
              "android.nfc.cardemulation.action.
              HOST_APDU_SERVICE"/>
    <category android:name=
              "android.intent.category.DEFAULT"/>
    </intent-filter>
    <!-- Required XML configuration file, listing the
         AIDs that we are emulating cards
         for. This defines what protocols our card
         emulation service supports. -->
    <meta-data android:name=
         "android.nfc.cardemulation.host_apdu_service"
         android:resource="@xml/aid:list"/>
</service>

```

并且我们需要在`res/xml`里面有一个名为`aid:list.xml`的文件。

```java
<?xml version="1.0" encoding="utf-8"?>
<!-- This file defines which AIDs this application
   should emulate cards for.

   Vendor-specific AIDs should always start with an "F",
   according to the ISO 7816 spec. We recommended
   vendor-specific AIDs be at least 6 characters long,
   to provide sufficient uniqueness. Note, however, that
   longer AIDs may impose a burden on non-Android NFC
   terminals. AIDs may not exceed 32 characters
    (16 bytes).

   Additionally, AIDs must always contain an even number
   of characters, in hexadecimal format.

   In order to avoid prompting the user to select which
   service they want to use when the device is scanned,
   this app must be selected as the default handler for
   an AID group by the user, or the terminal must
   select *all* AIDs defined in the category
   simultaneously ("exact match").
-->
<host-apdu-service
      xmlns:android=
          "http://schemas.android.com/apk/res/android"
      android:description="@string/service_name"
      android:requireDeviceUnlock="false">
  <!--
  If category="payment" is used for any aid-groups, you
  must also add an android:apduServiceBanner attribute
  above, like so:
  android:apduServiceBanner="@drawable/settings_banner"

   apduServiceBanner should be 260x96 dp. In pixels,
   that works out to...
    -  drawable-xxhdpi: 780x288 px
    -  drawable-xhdpi:  520x192 px
    -  drawable-hdpi:   390x144 px
    -  drawable-mdpi:   260x96  px

  The apduServiceBanner is displayed in the "Tap & Pay"
  menu in the system Settings app, and is only displayed
  for apps which implement the "payment" AID category.

  Since this sample is implementing a non-standard card
  type (a loyalty card, specifically), we do not need
  to define a banner.

  Important: category="payment" should only be used for

      industry-standard payment cards. If you are
      implementing a closed-loop payment system (e.g.
      stored value cards for a specific merchant or
      transit system), use category="other". This is
      because only one "payment" card may be active at
      a time, whereas all "other" cards are active
      simultaneously (subject to AID dispatch).
  -->

  <aid-group android:description=
        "@string/card_title" android:category="other">
      <aid-filter android:name="F222222222"/>
  </aid-group>
</host-apdu-service>

```

服务类别还依赖于对象`AccountStorage`，例如，如下所示:

```java
/**
 * Utility class for persisting account numbers to disk.
 *
 * The default SharedPreferences instance is used as
 * the backing storage. Values are cached in memory for
 * performance.
 */
object AccountStorage {
  private val PREF_ACCOUNT_NUMBER = "account_number"
  private val DEFAULT_ACCOUNT_NUMBER = "00000000"
  private val TAG = "AccountStorage"
  private var sAccount: String? = null
  private val sAccountLock = Any()

  fun setAccount(c: Context, s: String) {
      synchronized(sAccountLock) {
          Log.i(TAG, "Setting account number: $s")
          val prefs = PreferenceManager.
              getDefaultSharedPreferences(c)
          prefs.edit().
                putString(PREF_ACCOUNT_NUMBER, s).
                commit()
          sAccount = s
      }
  }

  fun getAccount(c: Context): String? {

      synchronized(sAccountLock) {
          if (sAccount == null) {
              val prefs = PreferenceManager.
                    getDefaultSharedPreferences(c)
              val account = prefs.getString(
                    PREF_ACCOUNT_NUMBER,
                    DEFAULT_ACCOUNT_NUMBER)
              sAccount = account
          }
          return sAccount
      }
  }
}

```

## 安卓和蓝牙

Android 允许你添加自己的蓝牙功能。详尽地描述蓝牙的所有需求超出了本书的范围，但要了解如何做到以下几点，请参阅 Android 中蓝牙的在线文档:

*   扫描可用的本地蓝牙设备(如果您有多个设备)

*   扫描配对的远程蓝牙设备

*   扫描远程设备提供的服务

*   建立沟通渠道

*   在本地和远程设备之间传输数据

*   使用配置文件

*   在您的 Android 设备上添加蓝牙服务器

我们将在这里描述 RfComm 通道的实现，以在您的智能手机和外部蓝牙服务之间传输串行数据。通过这个用例，您已经拥有了一个强大的蓝牙通信工具。例如，你可以用它来控制机器人或智能家居设备。

## 蓝牙 RfComm 服务器

令人惊讶的是，在网上很难找到关于设置蓝牙服务器的有价值的信息。然而，对于开发来说，有必要实现一个蓝牙服务器，这样您就可以测试 Android 应用程序。这样的测试服务器也可以作为您可能想到的真实场景的基础。

BlueCove 是蓝牙服务器技术的一个很好的候选者，它是一个开源项目。它的一部分是在 Apache License V2.0 下许可的，其他部分是在 GPL 下许可的，所以虽然它很容易合并到您自己的项目中，但是您需要检查对于商业项目，该许可是否适合您的需要。在下面的段落中，我将描述如何使用 BlueCove 和 Groovy 在 Linux 上设置 RfComm 蓝牙服务器。对于 Windows，您必须修改启动脚本并使用 DLL 库来代替。

从下载和安装 Groovy 开始。任何现代版本都可以。接下来，下载 BlueCove。我测试的版本是 2.1.0，但是您也可以尝试更新的版本。你需要文件`bluecove-2.1.0.jar`、`bluecove-emu-2.1.0.jar`和`bluecove-gpl-2.1.0.jar`。暂时将 jar 文件解压为 zip 文件，并创建一个文件夹结构，如下所示:

```java
libbluecove.jnilib
startRfComm.sh
libbluecove.so
libbluecove_x64.so
libs/
    bluecove-2.1.0.jar
    bluecove-emu-2.1.0.jar
    bluecove-gpl-2.1.0.jar
scripts/
    rfcomm.groovy

```

### 注意

根据您使用的 Linux 发行版，您可能需要添加一个符号链接，如下所示:

`cd /usr/lib/x86_64-linux-gnu/`

`ln -s libbluetooth.so.3 libbluetooth.so`

您必须以 root 用户身份执行此操作。

### 注意

此外，仍然以 root 用户身份执行以下操作:

`mkdir /var/run/sdb`

`chmod 777 /var/run/sdp`

### 注意

此外，为了解决兼容性问题，您必须调整蓝牙服务器流程，如下所示:

`cd/etc/systemd/system/bluetooth.target.wants/`

里面的变化`bluetooth.service`像这样:

`ExecStart=/usr/lib/bluetooth/bluetoothd →`

`ExecStart=/usr/lib/bluetooth/bluetoothd -C`

然后在终端中输入以下内容

`systemctl daemon-reload` **和** `systemctl restart bluetooth`

文件`startRfComm.sh`是启动脚本。创建它，并在里面编写以下内容，相应地固定路径:

```java
#!/bin/bash

export JAVA_HOME=/opt/jdk8
export GROOVY_HOME=/opt/groovy

$GROOVY_HOME/bin/groovy \
 -cp libs/bluecove-2.1.0.jar:libs/bluecove-emu-2.1.0.jar
:libs/bluecove-gpl-2.1.0.jar \
 -Dbluecove.debug=true \
 -Djava.library.path=. \
scripts/rfcomm.groovy

```

服务器代码位于`scripts/rfcomm.groovy`中。创建它并插入以下内容:

```java
import javax.bluetooth.*
import javax.obex.*
import javax.microedition.io.*
import groovy.transform.Canonical

// Run server as root!

// setup the server to listen for connection
// retrieve the local Bluetooth device object
LocalDevice local = LocalDevice.getLocalDevice()
local.setDiscoverable(DiscoveryAgent.GIAC)

UUID uuid = new UUID(80087355)
String url = "btspp://localhost:" + uuid.toString() +
      ";name=RemoteBluetooth"
println("URI: " + url)
StreamConnectionNotifier notifier = Connector.open(url)
// waiting for connection
while(true) {
  println("waiting for connection...")
  StreamConnection connection = notifier.acceptAndOpen()
  InputStream inputStream = connection.openInputStream()
  println("waiting for input")
  while (true) {
    int command = inputStream.read()
    if(command == -1) break
    println("Command: " + command)
  }
}

```

服务器必须以 root 用户身份启动。在安装了蓝牙适配器的系统上调用`sudo ./startRfComm.sh`后，去掉时间戳的输出应该如下所示:

```java
Java 1.4+ detected: 1.8.0_60; Java HotSpot(TM) 64-Bit
   Server VM; Oracle Corporation
...
localDeviceID 0
...
BlueCove version 2.1.0 on bluez
URI: btspp://localhost:04c6093b00001000800000805f9b34fb;
   name=RemoteBluetooth
open using BlueCove javax.microedition.io.Connector
...
connecting btspp://localhost:04
   c6093b00001000800000805f9b34fb;name=RemoteBluetooth
...
created SDPSession 139982379587968
...
BlueZ major verion 4 detected
...
function sdp_extract_pdu of bluez major version 4 is called
...
waiting for connection...

```

## Android RfComm 客户端

随着前面小节中的 RfComm 蓝牙服务器进程的运行，我们现在将为 Android 平台开发客户机。它应该执行以下操作:

*   提供一个活动来选择要连接的远程蓝牙设备

*   提供另一个活动来启动连接，并向 Bluetooth RfConn 服务器发送消息

从一个新项目开始，不要忘记添加 Kotlin 支持。将文件`AndroidManifest.xml`修改如下:

```java
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android=
      "http://schemas.android.com/apk/res/android"
    package="de.pspaeth.bluetooth">

  <uses-permission android:name=
        "android.permission.BLUETOOTH_ADMIN"/>
  <uses-permission android:name=
        "android.permission.BLUETOOTH"/>
  <application
      android:allowBackup="true"
      android:icon="@mipmap/ic_launcher"
      android:label="@string/app_name"
      android:roundIcon="@mipmap/ic_launcher_round"
      android:supportsRtl="true"
      android:theme="@style/AppTheme">
      <activity android:name=".MainActivity">
          <intent-filter>
              <action android:name=
                    "android.intent.action.MAIN"/>
              <category android:name=
                    "android.intent.category.LAUNCHER"/>
          </intent-filter>
      </activity>
      <activity
          android:name=".DeviceListActivity"
          android:configChanges=
                "orientation|keyboardHidden"
          android:label="Select Device"
          android:theme=
                "@android:style/Theme.Holo.Dialog"/>
  </application>
</manifest>

```

接下来在`res/layout`中创建三个布局文件。第一个是`activity_main.xml`，包含一个状态行和两个按钮。

```java
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
  xmlns:android=
        "http://schemas.android.com/apk/res/android"
  xmlns:app="http://schemas.android.com/apk/res-auto"
  xmlns:tools="http://schemas.android.com/tools"
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  tools:context=".MainActivity"
  android:orientation="vertical">

  <LinearLayout
      android:layout_width="match_parent"
      android:layout_height="wrap_content"
      android:orientation="horizontal">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="State: " />
    <TextView
        android:id="@+id/state"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"/>
  </LinearLayout>

  <Button
      android:layout_width="match_parent"
      android:layout_height="wrap_content"
      android:text="Scan Devices"
      android:onClick="scanDevices"/>
  <Button
      android:layout_width="match_parent"
      android:layout_height="wrap_content"
      android:text="RfComm"
      android:onClick="rfComm"/>
</LinearLayout>

```

### 注意

为了简单起见，我添加了文本作为文字。在生产环境中，您当然应该使用字符串资源。

下一个布局文件`device_list.xml`用于远程设备选择器活动:

```java
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android=
      "http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

  <TextView
      android:id="@+id/title_paired_devices"
      android:layout_width="match_parent"
      android:layout_height="wrap_content"
      android:background="#666"
      android:paddingLeft="5dp"
      android:text="Paired Devices"
      android:textColor="#fff"
      android:visibility="gone"
      />

  <ListView
      android:id="@+id/paired_devices"
      android:layout_width="match_parent"
      android:layout_height="wrap_content"
      android:layout_weight="1"
      android:stackFromBottom="true"
      />

  <TextView
      android:id="@+id/title_new_devices"
      android:layout_width="match_parent"
      android:layout_height="wrap_content"
      android:background="#666"
      android:paddingLeft="5dp"
      android:text="Other Devices"
      android:textColor="#fff"
      android:visibility="gone"
      />

  <ListView
      android:id="@+id/new_devices"
      android:layout_width="match_parent"
      android:layout_height="wrap_content"
      android:layout_weight="2"
      android:stackFromBottom="true"
      />

  <Button
      android:id="@+id/button_scan"
      android:layout_width="match_parent"
      android:layout_height="wrap_content"
      android:text="Scan"
      />
</LinearLayout>

```

最后一个是`device_name.xml`，用于布置设备列表器活动中的列表项:

```java
<?xml version="1.0" encoding="utf-8"?>
<TextView xmlns:android=
        "http://schemas.android.com/apk/res/android"
      android:layout_width="match_parent"
      android:layout_height="wrap_content"
      android:padding="5dp"
      android:textSize="18sp" />

```

`DeviceListActvity`类是 Android 开发人员文档中蓝牙聊天示例的 device lister 活动的改编版本。

```java
/**
 * This Activity appears as a dialog. It lists any
 * paired devices and devices detected in the area after
 * discovery. When a device is chosen by the user, the
 * MAC address of the device is sent back to the parent
 * Activity in the result Intent.
 */
class DeviceListActivity : Activity() {
  companion object {
      private val TAG = "DeviceListActivity"
      var EXTRA_DEVICE_ADDRESS = "device_address"
  }

  private var mBtAdapter: BluetoothAdapter? = null
  private var mNewDevicesArrayAdapter:
        ArrayAdapter<String>? = null

```

`OnItemClickListener`是在 Kotlin 中实现一个*单一方法接口*的例子。

```java
private val mDeviceClickListener =
      AdapterView.OnItemClickListener {
            av, v, arg2, arg3 ->
     // Cancel discovery because it's costly and we're
     // about to connect
     mBtAdapter!!.cancelDiscovery()

     // Get the device MAC address, which is the last
     // 17 chars in the View
     val info = (v as TextView).text.toString()
     val address = info.substring(info.length - 17)

     // Create the result Intent and include the MAC
     // address
     val intent = Intent()
     intent.putExtra(EXTRA_DEVICE_ADDRESS, address)

     // Set result and finish this Activity
     setResult(Activity.RESULT_OK, intent)
     finish()
}

```

`BroadcastReceiver`监听发现的设备，并在发现完成时更改标题。

```java
/**
 * Listening for discovered devices.
 */
private val mReceiver = object : BroadcastReceiver() {
    override
    fun onReceive(context: Context, intent: Intent) {
        val action = intent.action

        // When discovery finds a device
        if (BluetoothDevice.ACTION_FOUND == action) {
            // Get the BluetoothDevice object from
            // the Intent
            val device = intent.
                  getParcelableExtra<BluetoothDevice>(
                  BluetoothDevice.EXTRA_DEVICE)
            // If it's already paired, skip it,
            // because it's been listed already
            if (device.bondState !=
                  BluetoothDevice.BOND_BONDED) {
                mNewDevicesArrayAdapter!!.add(
                      device.name + "\n" +
                      device.address)
            }
            // When discovery is finished, change the
            // Activity title
        } else if (BluetoothAdapter.
              ACTION_DISCOVERY_FINISHED == action) {
            setProgressBarIndeterminateVisibility(
                  false)
            setTitle("Select Device")
            if (mNewDevicesArrayAdapter!!.count
                  == 0) {
            val noDevices = "No device"
            mNewDevicesArrayAdapter!!.add(
                  noDevices)
        }
     }
  }
}

```

像往常一样，`onCreate()`回调方法设置用户界面。

```java
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    // Setup the window
    requestWindowFeature(Window.
          FEATURE_INDETERMINATE_PROGRESS)
    setContentView(R.layout.activity_device_list)

    // Set result CANCELED in case the user backs out
    setResult(Activity.RESULT_CANCELED)

    // Initialize the button to perform device
    // discovery
    button_scan.setOnClickListener { v ->
        doDiscovery()
        v.visibility = View.GONE
    }

    // Initialize array adapters. One for already
    // paired devices and one for newly discovered
    // devices
    val pairedDevicesArrayAdapter =
          ArrayAdapter<String>(this,
                R.layout.device_name)
    mNewDevicesArrayAdapter =
          ArrayAdapter(this,
                R.layout.device_name)

    // Find and set up the ListView for paired devices
    val pairedListView = paired_devices as ListView
    pairedListView.adapter = pairedDevicesArrayAdapter
    pairedListView.onItemClickListener =
          mDeviceClickListener

    // Find and set up the ListView for newly

    // discovered devices
    val newDevicesListView = new_devices as ListView
    newDevicesListView.adapter =
          mNewDevicesArrayAdapter
    newDevicesListView.onItemClickListener =
          mDeviceClickListener

    // Register for broadcasts when a device is
    // discovered
    var filter =
          IntentFilter(BluetoothDevice.ACTION_FOUND)
    this.registerReceiver(mReceiver, filter)

    // Register for broadcasts when discovery has
    // finished
    filter = IntentFilter(BluetoothAdapter.
          ACTION_DISCOVERY_FINISHED)
    this.registerReceiver(mReceiver, filter)

    // Get the local Bluetooth adapter
    mBtAdapter = BluetoothAdapter.getDefaultAdapter()

    // Get a set of currently paired devices
    val pairedDevices = mBtAdapter!!.bondedDevices

    // If there are paired devices, add each one to
    // the ArrayAdapter
    if (pairedDevices.size > 0) {
        title_paired_devices.visibility = View.VISIBLE
        for (device in pairedDevices) {
            pairedDevicesArrayAdapter.add(
                  device.name + "\n" + device.address)
        }
    } else {
        val noDevices = "No devices"
        pairedDevicesArrayAdapter.add(noDevices)
    }
}

```

`onDestroy()`回调方法用于清理东西。最后，`doDiscovery()`方法执行实际的发现工作。

```java
override fun onDestroy() {
    super.onDestroy()

    // Make sure we're not doing discovery anymore
    if (mBtAdapter != null) {
        mBtAdapter!!.cancelDiscovery()
    }

    // Unregister broadcast listeners
    this.unregisterReceiver(mReceiver)
}

/**
 * Start device discover with the BluetoothAdapter
 */
private fun doDiscovery() {
    Log.d(TAG, "doDiscovery()")

    // Indicate scanning in the title
    setProgressBarIndeterminateVisibility(true)
    setTitle("Scanning")

    // Turn on sub-title for new devices
    title_new_devices.visibility = View.VISIBLE

    // If we're already discovering, stop it
    if (mBtAdapter!!.isDiscovering) {
        mBtAdapter!!.cancelDiscovery()
    }

    // Request discover from BluetoothAdapter
    mBtAdapter!!.startDiscovery()
  }
}

```

`MainActivity`类负责检查和获取权限，并构造一个`BluetoothCommandService`，我们将在后面描述。

```java
class MainActivity : AppCompatActivity() {
  companion object {
      val REQUEST_ENABLE_BT = 42
      val REQUEST_QUERY_DEVICES = 142
}
var mBluetoothAdapter: BluetoothAdapter? = null
var mCommandService:BluetoothCommandService? = null

```

活动中的`onCreate()`回调用于设置用户界面和注册蓝牙适配器。

```java
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)

    val permission1 = ContextCompat.
          checkSelfPermission(
          this, Manifest.permission.BLUETOOTH)
    val permission2 = ContextCompat.
          checkSelfPermission(
          this, Manifest.permission.BLUETOOTH_ADMIN)
    if (permission1 !=
          PackageManager.PERMISSION_GRANTED ||
        permission2 !=
          PackageManager.PERMISSION_GRANTED)
    {
        ActivityCompat.requestPermissions(this,
            arrayOf(
              Manifest.permission.BLUETOOTH,
              Manifest.permission.BLUETOOTH_ADMIN),
            642)
    }

    mBluetoothAdapter =
          BluetoothAdapter.getDefaultAdapter()

    if (mBluetoothAdapter == null) {
        Toast.makeText(this,
              "Bluetooth is not supported",
              Toast.LENGTH_LONG).show()
        finish()
    }

    if (!mBluetoothAdapter!!.isEnabled()) {
        val enableIntent = Intent(
              BluetoothAdapter.ACTION_REQUEST_ENABLE)
        startActivityForResult(
                 enableIntent, REQUEST_ENABLE_BT)
    }
}

```

`scanDevices()`方法用于调用系统的蓝牙设备扫描器。

```java
/**
 * Launch the DeviceListActivity to see devices and
 * do scan
 */
fun scanDevices(v:View) {
    val serverIntent = Intent(
          this, DeviceListActivity::class.java)
    startActivityForResult(serverIntent,
          REQUEST_QUERY_DEVICES)
}

```

方法`rfComm`和`sendMessage()`处理蓝牙消息的发送。

```java
fun rfComm(v: View) {
    sendMessage("The message")
}

/**
 * Sends a message.
 *
 * @param message A string of text to send.
 */
private fun sendMessage(message: String) {
    if (mCommandService?.mState !==
          BluetoothCommandService.Companion.
          State.CONNECTED)
    {
        Toast.makeText(this, "Not connected",
              Toast.LENGTH_SHORT).show()
        return
    }

    // Check that there's actually something to send
    if (message.length > 0) {
        val send = message.toByteArray()
        mCommandService?.write(send)
    }
}

```

到设备的实际连接是从方法`connectDevice()`内部完成的。

```java
private
fun connectDevice(data: Intent, secure: Boolean) {
    val macAddress = data.extras!!
          .getString(
          DeviceListActivity.EXTRA_DEVICE_ADDRESS)
    mBluetoothAdapter?.
          getRemoteDevice(macAddress)?.run {
        val device = this
        mCommandService =
              BluetoothCommandService(
              this@MainActivity, macAddress).apply {
            addStateChangeListener { statex ->
                runOnUiThread {
                  state.text = statex.toString()
                }
            }
            connect(device)
        }
    }
}

private fun fetchUuids(device: BluetoothDevice) {
    device.fetchUuidsWithSdp()
}

```

回调方法`onActivityResult()`处理从系统设备选择器的返回。在这里，我们只需连接到所选的设备。

```java
override
fun onActivityResult(requestCode: Int,
      resultCode: Int, data: Intent) {
    when (requestCode) {
        REQUEST_QUERY_DEVICES -> {
            if (resultCode == Activity.RESULT_OK) {
                connectDevice(data, false)
            }
        }
      }
    }
}

```

Class `BluetoothCommandService`虽然名不副实，但却不是 Android 服务。它处理与蓝牙服务器的通信，读取内容如下:

```java
class BluetoothCommandService(context: Context,
      val macAddress:String) {
  companion object {
      // Unique UUID for this application
      private val MY_UUID_INSECURE = UUID.fromString(
            "04c6093b-0000-1000-8000-00805f9b34fb")

      // Constants that indicate the current connection
      // state
      enum class State {
          NONE,        // we're doing nothing
          LISTEN,      // listening for incoming conns
          CONNECTING,  // initiating an outgoing conn
          CONNECTED    // connected to a remote device
      }
  }

  private val mAdapter: BluetoothAdapter
  private var createSocket: CreateSocketThread? = null
  private var readWrite: SocketReadWrite? = null
  var mState: State = State.NONE

  private var stateChangeListeners =
        mutableListOf<(State)->Unit>()
  fun addStateChangeListener(l:(State)->Unit) {
      stateChangeListeners.add(l)
  }

  init {
      mAdapter = BluetoothAdapter.getDefaultAdapter()
      changeState(State.NONE)
  }

```

它的公共方法用于连接、断开和写入数据。

```java
/**
 * Initiate a connection to a remote device.
 *
 * @param device The BluetoothDevice to connect
 */
fun connect(device: BluetoothDevice) {
    stopThreads()

    // Start the thread to connect with the given
    // device
    createSocket = CreateSocketThread(device).apply {
        start()
    }
}

/**
 * Stop all threads
 */
fun stop() {
    stopThreads()
    changeState(State.NONE)
}

/**
 * Write to the ConnectedThread in an unsynchronized

 * manner
 *
 * @param out The bytes to write
 * @see ConnectedThread.write
 */
fun write(out: ByteArray) {
    if (mState != State.CONNECTED) return
    readWrite?.run { write(out) }
}

```

它的私有方法处理连接线程。

```java
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////

/**
 * Start the ConnectedThread to begin managing a
 * Bluetooth connection
 *
 * @param socket The BluetoothSocket on which the
 *       connection was made
 * @param device The BluetoothDevice that has been
 *       connected
 */
private fun connected(socket: BluetoothSocket,
      device: BluetoothDevice) {
    stopThreads()

    // Start the thread to perform transmissions
    readWrite = SocketReadWrite(socket).apply {
        start()
    }
}

private fun stopThreads() {
    createSocket?.run {
        cancel()
        createSocket = null
    }
    readWrite?.run {
        cancel()
        readWrite = null
   }
}

/**
 * Indicate that the connection attempt failed.
 */
private fun connectionFailed() {
    changeState(State.NONE)

}

/**
 * Indicate that the connection was lost.
 */
private fun connectionLost() {
    changeState(State.NONE)
}

```

连接套接字处理线程本身是一个专用的`Thread`实现。

```java
/**
 * This thread runs while attempting to make an
 * outgoing connection with a device. It runs straight
 * through; the connection either succeeds or fails.
 */
private inner
class CreateSocketThread(
      private val mmDevice: BluetoothDevice) :
      Thread() {
    private val mmSocket: BluetoothSocket?

    init {
        // Get a BluetoothSocket for a connection
        // with the given BluetoothDevice
        mmSocket = mmDevice.
            createInsecureRfcommSocketToServiceRecord(
            MY_UUID_INSECURE)
        changeState(Companion.State.CONNECTING)
    }

    override fun run() {
        name = "CreateSocketThread"

        // Always cancel discovery because it will
        // slow down a connection
        mAdapter.cancelDiscovery()

        // Make a connection to the BluetoothSocket

        try {
            // This is a blocking call and will only
            // return on a successful connection or an
            // exception
            mmSocket!!.connect()
        } catch (e: IOException) {
            Log.e("LOG","Connection failed", e)
            Log.e("LOG", "Maybe device does not " +
                  " expose service " + MY_UUID_INSECURE)
            // Close the socket
            mmSocket!!.close()

            connectionFailed()
                 return
            }

            // Reset the thread because we're done
            createSocket = null

            // Start the connected thread
            connected(mmSocket, mmDevice)
        }

        fun cancel() {
            mmSocket!!.close()
        }
}

```

为了从连接套接字读写数据，我们使用另一个线程。

```java
/**
 * This thread runs during a connection with a
 * remote device. It handles all incoming and outgoing
 * transmissions.
 */
private inner
class SocketReadWrite(val mmSocket: BluetoothSocket) :
      Thread() {
    private val mmInStream: InputStream?
    private val mmOutStream: OutputStream?

    init {
        mmInStream = mmSocket.inputStream
        mmOutStream = mmSocket.outputStream
        changeState(Companion.State.CONNECTED)
    }

    override fun run() {
        val buffer = ByteArray(1024)
        var bytex: Int

        // Keep listening to the InputStream while
        // connected
        while (mState ==
              Companion.State.CONNECTED) {

    try {
        // Read from the InputStream
        bytex = mmInStream!!.read(buffer)
    } catch (e: IOException) {
        connectionLost()
        break
    }
  }
}

   /**
    * Write to the connected OutStream.
    *
    * @param buffer The bytes to write
    */
    fun write(buffer: ByteArray) {
        mmOutStream!!.write(buffer)
    }

    fun cancel() {
        mmSocket.close()
    }
}

```

最后，我们提供了一种方法来告知相关方套接字连接状态何时发生变化。这里，它还发出一个日志记录语句。对于生产代码，您可以删除它，或者以其他方式向用户提供这些信息。

```java
  private fun changeState(newState:State) {
      Log.e("LOG",
            "changing state: ${mState} -> ${newState}")
      mState = newState
      stateChangeListeners.forEach { it(newState) }
  }
}

```

### 注意

伴随对象的 UUID 必须与您在服务器启动日志中看到的 UUID 相匹配。

这个类的作用如下:

*   一旦它的`connect(...)`方法被调用，它就开始连接尝试。

*   如果连接成功，另一个使用 connection 对象初始化输入和输出流的线程就会启动。注意，在这个例子中没有使用输入流；此处仅供参考。

*   凭借它的`mState`成员，客户端可以检查连接状态。

*   如果已连接，可以调用方法`write(...)`通过连接通道发送数据。

要测试连接，请按 UI 上的 RFCOMM 按钮。然后，服务器应用程序应该记录以下内容:

```java
Command: 84
Command: 104
Command: 101
Command: 32
Command: 109
Command: 101
Command: 115
Command: 115
Command: 97
Command: 103
Command: 101

```

这是消息“消息”的数字表示