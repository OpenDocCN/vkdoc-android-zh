第七章

Android 图形设计:概念和技术

在本章中，我们将了解 Android 中数字图像和图形设计的基本概念，以及这些概念如何在 Android 操作系统中实现，以及一些数字图像技术。

我们将了解 android.graphics.drawable 包和 android **drawable 类，以及 Android 支持的多种类型的 Drawable 对象。我们还将学习什么是 **ARGB** ，什么是**阿尔法通道**，以及所有关于数字成像的概念，如**像素**、**色深**、**抖动**、**分辨率**、**纵横比**、**图层**、**混合**、**图像压缩、**和**格式****

然后，我们将应用这些新知识，通过一种称为**合成**的数字成像技术，添加一些与空间相关的背景元素，并确保它们无缝实现，从而将我们迄今为止创建的 Hello World 应用程序提升到一个全新的专业水平，我们也将在本章中了解更多信息。

为了在我们的应用程序中实现所有这些新的数字图像功能，我们将继续学习以新的方式应用 XML 用户界面参数，正如我们从第 2 章开始所做的那样，也正如我们将在本书的其余部分继续做的那样。

本章将更多地涉及图形设计元素、数字成像概念和成像技术，而不是编程概念，因为这些天来，Android 应用程序越来越多地涉及视觉设计、3D、图形设计、动画、数字图像和其他新媒体元素，这使得本章变得非常必要。

让我们从学习 Android **graphics** 包和 **drawable** 类开始，它们让所有这些视觉魔法对我们的最终用户变得生动，并允许我们开发人员以逻辑和结构化的方式在 Java 代码和 XML 标记中实现我们心目中的东西。

Android 图形设计最高水平:Drawable 类

类似于我们在前一章中看到的与 UI 元素或**小部件**相关的 Android **视图**类，Android **Drawable** 类也是与**图形设计**相关的对象的最高级别类，这些对象在 Android 中被称为 **drawables** ，因为它们被绘制到我们的显示屏上。

这就是为什么项目资源文件夹中的一些子文件夹以单词 *drawable* 开头，因为它们包含了应用程序的图形设计元素。到目前为止，我们已经使用了数字图像 drawables，但在我们完成之前，我们还将使用其他几种类型的 drawables，以实现动画或图像交叉淡入淡出效果。

和 View 类一样，Drawable 类通常不直接使用，但是它有无数的子类。与视图子类一样，Drawable 既有**直接子类**又有**间接子类**。这些 Drawable 子类完成了 Android 图形中的所有繁重工作，因此，在本书中，我们将在我们的应用程序中引入并利用其中的许多子类。让我们回顾一下哪些可绘制子类是直接的，哪些是间接的，以及这些可绘制子类对我们的应用程序有什么作用。

Android Drawable 类的直接子类

Drawable 类的**直接子类**本质上等同于我们可以在 Android 应用程序中使用的图形设计元素的类型。

到目前为止，Drawable 类最常用的直接子类被称为 **BitmapDrawable** 子类 ，它用于**数字图像**，例如我们目前在应用程序中使用的 PNG 文件以及 WEBP、JPEG 或 GIF。

**ColorDrawable** 是最基础的关卡 Drawable 类，它用于定义屏幕的**颜色**，就像我们在[第 6 章](06.html)中为我们的攻击星球活动用户界面屏幕定义**黑色**屏幕颜色一样。

**GradientDrawable** 用于创建从一种颜色到另一种颜色的渐变，可以由任何形状定义。Android GradientDrawables 支持的形状有:直线、矩形、椭圆(卵形)、圆形、环形(箍形或环形)，可以画出一个渐变**线性**(直的，任意角度)**径向**(从一个点发出)，或者**扫掠**(线性但绕一个点旋转)。

**ShapeDrawable** 用于在 Android 中创建一个**矢量**形状。向量或形状是定义 2D 体积外部的 2D 线或曲线，如心形或星形。熟悉 Adobe Illustrator 的人会熟悉矢量形状，以及渐变和彩色图形工具。

我们讨论的最后三个 Drawable 子类(ColorDrawable、GradientDrawable 和 ShapeDrawable)为 Android 操作系统提供了许多矢量软件包(如 Illustrator 或 InkScape)将提供的基本功能，只是我们在 Android 中的 Java 代码级别上提供了这些功能。这使我们能够创建与在 InkScape 中创建的相同类型的矢量艺术作品，然后通过 Java 使艺术作品具有交互性或动画效果。

**LayerDrawable** 让我们可以处理多层图像，就像人们在 Photoshop 或 GIMP 数字成像软件中看到的那样，以及它们的图像层功能。这是一个更高级的 drawable，用于高级游戏和实时合成应用。我们将在本章的后面了解更多关于图像**图层**和**合成**，以及它们是如何使用的。

**InsetDrawable** 允许我们使用一个叫做**插图**的屏幕区域或子集来显示图形(可绘制)元素。这用于像窗口小部件这样的东西，它们只使用显示屏的一部分作为它们的应用或目的所需的屏幕区域。设备主屏幕的时钟可能是使用 InsetDrawable 的一个很好的例子。

Android Drawable 类的间接子类

Drawable 的**间接子类**是更复杂或更详细的图形函数，它们利用直接子类来创建更复杂的图形设计效果和运动，如动画。

例如，Android**TransitionDrawable**，其中**交叉淡入淡出**两幅图像以创建图像**过渡**，是 **LayerDrawable** 的子类。因为这些 LayerDrawable 对象处理层中的多个图像，所以它们是创建 TransitionDrawable 类的子类的逻辑类，TransitionDrawable 类获取两个图像并制作它们的 **alpha 通道**值的动画(是的，我们将很快介绍这一点)以创建令人印象深刻且有用的图像交叉淡入淡出效果。

除了 TransitionDrawable 类，我们还将大量使用 Drawable 的**Animation Drawable**，它是 Drawable 的另一个关键的间接子类，在 Android 中实现了**帧动画**。我们将在后面专门关注动画的章节中介绍帧动画和矢量动画。因为我们在这里讨论了主要的 drawable indirect 子类，所以我现在将它放入正确的上下文中。

**LevelListDrawable**用于进度条和类似的应用程序，在这些应用程序中，需要根据某种活动的级别来替换屏幕上的图形元素。类似的 **StateListDrawable** 类 用于根据应用运行时可能遇到的不同状态变化来替换图形元素。StateListDrawable 可以以任何特定的顺序访问图形元素，也就是说，不按顺序，而 LevelListDrawable 则按顺序访问图形，从一个级别到另一个级别。

LevelListDrawable 和 StateListDrawable 都是从 Android**drawable container**direct 子类派生出来的子类，该子类通常不被直接使用或调用，但如果 LevelList 或 StateList drawable 容器不能完全满足您的需求，它可以用于创建您自己的自定义可绘制容器。

因为大多数应用程序(和大多数网站，就此而言)使用**位图**进行图形设计，本章接下来的几节将更详细地介绍**位图图像**的概念和特征，因为它们是创建既美观又专业的 Android 应用程序用户体验的关键。我们将从位图图像的基础开始，即**像素**，并从那里开始构建，就像数字图像本身是一次构建`—`一个像素一样！

数字成像的最低级像素:像素

数字图像是由微小的彩色点组成的；如果你曾经使用过数字成像软件包中的**变焦**功能，比如 GIMP，你可能已经知道了。一张图片的每个元素被称为一个**像素**，它是单词**图片**(在流行俚语中称为 pix)和单词**元素** (el)的变形。我打开了 GIMP 2.8，将我们攻击病毒的 48 像素版本从正常的(100%)放大到 800%，这样你就可以看到[图 7-1](#Fig1) 中组成图像的各个图片元素(像素)。我们将在本书中使用 GIMP 2.8 进行我们的数字成像工作流程，因为它是开源的，我们所有的读者都可以免费下载并安装它(就像我们在第 1 章中所做的那样)。请注意软件底部下拉小部件中的缩放设置，以便轻松访问新设置。还要注意，在屏幕的顶部有关于文件名、颜色深度、图层和分辨率的信息，所有这些我们将在本章接下来的三节中详细讨论。

![9781430257462_Fig07-01.jpg](../Images/9781430257462_Fig07-01.jpg)

[图 7-1。](#_Fig1)我们的攻击病毒图片元素(像素)

像素是使用**位**定义的，作为程序员，我们都知道这些位是代表数据的二进制值，在本例中是颜色值。这就是图像被称为**位图**的原因，因为它们实际上是位值的映射，使用二进制(**十六进制**)数据格式定义每个像素的颜色值。这就是为什么我们有 **8 位**图像(8 位数据用于定义每个像素)和 24 位图像，以及 32 位图像，我们将在本章稍后关于**色深**的章节中很快了解所有这些。

使用像素塑造图像:分辨率和纵横比

在 GIMP 窗口右上角的[图 7-1](#Fig1) 中，你会看到一个 **48x48** 符号。这是以像素为单位的图像的**分辨率** ，即 48 像素宽，48 像素高。图像分辨率用 2D 或二维来表示，即宽度乘以高度。图像体积或图像中的像素数是通过宽度乘以高度来计算的，因此我们的 48x48 像素图像在其体积中包含 2，304 个像素。我们的 Nexus S 模拟器屏幕分辨率为 800x480，包含 384，000 像素。

所以分辨率的概念相当简单，假设你知道如何使用计算器将两个数相乘！这个关于**长宽比** 的新概念有点复杂，因为它涉及到屏幕分辨率的多少像素宽与多少像素高的**比**。

当涉及到**缩放**一幅图像时，纵横比是最重要的，这是指放大或缩小图像的大小。如果您在缩放图像(或视频)时没有**保持**纵横比，您的图像将会失真。这是数字成像和数字视频中常见的错误；我们都见过那些看起来像锥子或者脸看起来有点宽的人的照片。这就是为什么数字图像缩放(调整大小)对话框有一个**保持纵横比锁定**功能，你应该总是选择这个功能。

计算纵横比很像在分数数学中寻找最小公分母，因为纵横比很像分数。纵横比是用宽:高还是宽:高来表示。因此，从技术上来说，我们的 Nexus S 的长宽比为 800:480，但在行业中，这通常会减少到可以显示该比例的最小的两个数字。

所以，让我们逆向工作(这是我如何在我的脑海里做这个计算，不使用计算器)，并删除零。从技术上讲，80:48 也是 800x480 显示器的正确纵横比。因为它们是偶数，所以我们将它们分成两半，得到 40:24，再得到 20:12。现在我们离个位数的数字对越来越近了！既然它们都还是偶数，我们再把它们切成两半，得到 10:6，现在其中一面有个位数。它们仍然是偶数，所以再次将它们分成两半，我们得到 5:3，这是 800x480 屏幕的正确纵横比。

其他常见的宽高比包括 16:9 (HDTV)，自 1920 年以来除以 16 乘以 9 等于 1080，4:3 是所有分辨率的原始计算机显示器宽高比，除了 1280x1024，它是 5:4 的宽高比。另一种流行的 Android 智能手机分辨率(和迷你平板分辨率)是 854x480，也是 16:9。因此，800x480 的屏幕是 5:3，854x480 的屏幕是 16:9，尽管它们在分辨率上看起来很接近，但在 UI 设计方面，它们相差很远，因为它们的纵横比非常不同。我们将在本书后面的第 12 章中处理这两个特别接近(分辨率)但远离(纵横比)的分辨率之间的差异。

请注意，数字越接近相等，图像就越方；我们在[图 7-1](#Fig1) 中的 48x48 像素图像的长宽比为 1:1。2:1 宽高比的图像仅仅意味着图像的宽度是高度的两倍，而 3:1 或 4:1 宽高比的图像可以被称为完全的全景图像！

塑造像素的颜色:色深的概念

现在我们已经讨论了像素、分辨率和长宽比，我们可以进入像素着色本身，并讨论颜色理论。有两种类型的彩色显示，**减色** 用于印刷，其中油墨颜色彼此相减，以及**加色**，用于发光显示(显示使用光)产品，其中颜色值彼此相加。

在减色中，红色和绿色(油墨)值产生紫色，而在加色中，红色和绿色(浅色)值产生黄色。差别很大！减色法，用于印刷行业，遵循一种 **CMYK** 颜色模型 ，代表**青色品红黄色黑色**(我猜他们把黑色这个词的 K 拿错了头)。

加色在消费电子行业用于以显示屏为特色的产品，遵循 RGB 颜色模型 。 **RGB** 代表**红绿蓝**，通过使用这三种颜色的光，可以创造出可见光谱中的任何颜色。不同的颜色是通过改变每个 RGB 颜色**成分**的强度(暗，或完全关闭，到亮，或完全打开)而产生的。

在数字世界中，这些 RGB 颜色中的每一种都可以有 8 位或 256 级的颜色强度。因此，对于红色，0 将完全关闭，或者黑色(完全没有红色值)和 256 将完全打开，或者 100%红色。

由于我们对图像中的每个 RGB 颜色**通道**都有**个 8 位**的颜色值，所以该图像可以说是一个 **24 位颜色**图像 ，也称为**真彩色**图像。Truecolor 图像可以显示 **16，777，216** 种不同的颜色值，可以通过将 256 乘以 256 (65，536 种颜色，也称为 **16 位颜色**)然后将该值再次乘以 256 来计算。

正如我们在上一章中看到的，256 个级别可以用两个字符表示，使用**十六进制**，或以 16 为基数的数字表示，其中不是从 0 计数到 9(以 10 为基数)，而是从 0 计数到 F，给我们一个字符“槽”16 个值因为 16 乘以 16 是 256，所以两个槽给了我们表示 256 个不同值的能力。

为了获得上一章图 6-17 中“入侵行星”选项的**橙色**颜色值，我们使用了十六进制颜色值 **#FFDDBB** ，这意味着红色的全强度(256)，绿色的低强度(196，或 14 乘以 14)，蓝色的更低强度(144，或 12 乘以 12)。

除了 24 位真彩色图像，还有 8 位**索引**彩色图像 。索引的彩色图像使用一个 8 位的**索引**，在**调色板**到**中有 256 种颜色，近似于**图像中的所有颜色。这对于某些图像比其他图像效果更好，例如，在晴朗的蓝天中蓬松的白云的图像可能作为索引颜色图像效果很好，因为使用的 256 个颜色值可以分布在仅使用 256 种颜色而不是 16，777，216 种颜色模拟真彩色图像所需的白色和蓝色阴影上。

索引彩色图像的数据占用空间(文件大小)通常比真彩色图像小得多(压缩前是真彩色图像的三分之一)，可以很好地表现图像中的颜色。我们在第 6 章的[攻击星球 UI 屏幕中使用的图标都使用索引色，正如在截图顶部的](06.html)[图 7-1](#Fig1) 中可以看到的，它指定了索引色。因为我们的病毒细胞使用粉红色、紫色和红色的阴影，所以它是使用索引色模拟真彩色图像质量结果的非常好的候选，使用的数据少得多(2.86 千字节)。

即使图像中有多种不同的颜色，索引彩色图像也能产生令人印象深刻的结果，正如我们在下一节的[图 7-2](#Fig2) 所示的攻击激光图像中所看到的。一般来说，图像的像素分辨率越高，索引颜色的效果就越好。我将在下一节关于 Alpha！的压缩技术中向您展示如何优化索引图像压缩的结果。

![9781430257462_Fig07-02.jpg](../Images/9781430257462_Fig07-02.jpg)

[图 7-2。](#_Fig2)攻击激光数字图像，其阿尔法通道通过棋盘图案显示

定义图像中的透明度:Alpha 通道的概念

24 位图像有三个(RGB)颜色通道**，而 **32 位图像**有四个( **ARGB** )颜色通道。32 位图像中的第四个通道称为 **alpha 通道** 。像图像的每个 RGB 通道一样，alpha 通道也可以有 **256 个级别**，但这 256 个级别不是定义颜色强度，而是定义该像素的**透明度**级别(或半透明)。**

 **对透明度进行微调、逐像素控制的主要用途是**图像合成** ，这是将许多图像**层**合成在一起以创建一个最终图像或特殊效果的过程。攻击激光图像中的 alpha 通道，如图 7-2 所示，在激光炮周围是黑色的(0 或透明),在图像中你看到激光炮的地方是白色的(256 全**不透明**)。GIMP 通过一个**棋盘**图案 来表示透明度，你也可以在[图 7-2](#Fig2) 中看到。

如果你想看看 alpha 通道在将一幅图像合成到任何其他图形上时有多有效，看看[图 7-2](#Fig2) 中屏幕截图的左上角，GIMP 在窗口标题栏上合成了你的激光炮。看起来它是被设计在那里的，不是吗？我们在 Hello World 应用程序中使用的几乎所有图像,`—`行星、激光炮、士兵和炸弹`—`都有一个阿尔法通道，这样当我们将星际机场和等离子云放在它们后面时，背景将完美地显示图像中的每个细节。也就是说，图像无缝地合成了**。**

 **我们已经将 UI 元素参数变得完全透明，在 **#00000000** 的 XML 中使用了 **ARGB** 设置。前两个零指定**不透明度** 为 100%关闭，因此透明度为 100%打开。**不透明**是透明的反义词，因此不透明程度和透明程度彼此相似。如果一个像素 30%透明，那么它 70%不透明。

Alpha 通道在应用程序开发中经常使用，因为我们经常想要使用内容开发引擎(在这里是 Android)作为图像合成工具。在图像合成中，合成中的每个层都带有一个 alpha 通道或 alpha 数据组件，以定义通过该层显示的内容以及该层上的哪些数据将以某种方式应用于最终的图像合成结果(最终的视觉图像)。

除了使用图像层及其 alpha 通道之外，合成还包括在每个层上使用一种**混合算法** ，该算法对像素数据值进行求和(或求差)，基于复杂的算法可以创建图像合成特效，如**叠加**、**屏幕**、**变暗**、**变亮**、**异或**等等。

android 通过 **PorterDuff** 算法 支持这些混合模式，在一个名为**Android . graphics . porter duff**的包和类中，因此，Android 不仅像 InkScape 一样被类固醇；还像打了类固醇的 GIMP 2.8.4！编码混合算法有点超出了像这样的关于 Android 的入门书籍的范围，但是如果你想将 Android 数字成像提升到一个新的水平，它将在我的“Pro Android 图形设计”书中(Apress，11/2013)出现！

Android 中的图像格式支持:PNG8、PNG24、web、JPG、gif

现在我们已经掌握了数字图像中的不同属性，我们可以讨论 Android 支持的一些不同的**文件格式**，因为这些图像文件格式中的每一种都有不同的组合和对颜色深度和 alpha 通道的支持级别。

Android 操作系统对其中一些格式的偏好超过了其他格式，这将决定我在本节中讨论这些格式的顺序。

便携式网络图形(PNG)格式

Android 最喜欢的格式是**便携式网络图形**或 **PNG** (读作 **Ping** )文件格式。PNG 有两种风格， **PNG8** 或索引色 PNG 和 **PNG24** 或真彩色 PNG。因为 PNG24 也可以“携带”一个 alpha 通道，从技术上讲，一个带 alpha 的 24 位 PNG 应该是一个 **PNG32** 。

Android 喜欢 PNG 格式的图像，因为 PNG 使用**无损**图像压缩，产生最高质量的结果，因为 PNG 图像在压缩过程中不会损失任何原始图像质量(或数据)。

联合图像专家组(JPEG)格式

下一个最适合在 Android 中使用的图像格式是 JPEG，它代表 T2 联合图像专家组。这种图像格式采用**有损**图像压缩，即“丢弃”部分原始图像数据以达到更好的压缩效果，但以牺牲图像质量为代价。如果你放大一个 JPEG 图像，你会看到看起来脏或变色的区域；这些是压缩**产物**，也是 JPEG 格式不是 Android 开发首选图像格式的原因之一。

JPEG 图像格式的另一个重要方面是它不能携带 alpha 通道，因此它不能用于图像合成，除非它是图像合成层堆栈中的底层，或者除非 alpha 信息后来在应用程序内部附加到它。

图形信息(GIF)格式

Android 中最不理想的图像格式是 Compuserve **GIF** 格式，它代表**图形信息格式**。GIF 图像仅支持 8 位索引颜色，并且比 PNG8 文件具有更大的数据占用空间(较弱的压缩算法)。除非万不得已，尽量不要在 Android 开发中使用 GIF。

Web 照片(web)格式

自 4.0 (API Level 14 冰淇淋三明治)版本和更高版本以来，Android 操作系统中增加了一种额外的图像格式，称为: **WEBP** 。WEBP 代表**网络照片**，它类似于 PNG32，但数据占用空间要小 25%;即其压缩算法优于 PNG24 和 PNG32。

然而，如果你想将你的 Android 应用交付给数百万使用 Android 1.5 到 3.2 (API 等级 3 到 13)设备的用户，你可能会想使用 PNG24 和 PNG32 格式，以及 PNG8(当它工作良好时)(正如我们在本书中为 Hello World 应用所做的)。

减少图像数据足迹:图像压缩概念

一旦我们定义了我们的图像和 alpha 通道，以及我们将要使用的文件格式，在我们的图像被创建和合成以及任何 alpha 通道被定义和添加之后，我们经历的最后一步是**压缩**图像以获得**最小的文件大小**。

**注意**我们压缩图像的原因是因为我们的 Android 应用程序的总大小是我们所有图像加上我们的 Java 代码和 XML 标记的总和，因为我们都知道文本比像素压缩得更好，所以应用程序的大部分数据足迹反映了我们优化新媒体资产的效果。

在这一节中，我将介绍影响压缩**算法**的关键因素，以及最终应用压缩过程(压缩算法)后，图像文件大小的最终**数据足迹**。

**分辨率**是调整图像以获得更好压缩(文件大小)效果的最大因素。正如我们之前了解到的，要压缩的像素的绝对数量总是归结为像素宽度乘以高度。

如果不进行压缩，图像的原始数据大小将按如下方式计算:像素宽度乘以像素高度乘以 3(对于 RGB)或 4(对于 ARGB)。

因此，对于我们的 ARGB 96 像素激光炮，如图 7-2 所示[，原始未压缩图像数据是**9216**像素(96x96)乘以 **4** (ARGB)，这是**36864**总像素要压缩，或四个图像通道中的每一个都是 9216 像素。36，864 除以 1，024(一千字节数据中的像素数)得到的**原始**文件大小正好是 **36 千字节**，或**36 千字节**。](#Fig2)

我们的 96 像素激光炮图像的最终文件大小为 **4.89KB，**比**小 7.36 倍**(36 除以 4.89)，或**原始数据占用空间的 13.6%** (4.89 除以 36)。100%减去 13.6%会产生 86.4%的压缩率。

我们做了什么来压缩这个图像几乎 87%,它仍然看起来很棒？因为我们无法改变它的分辨率，所以我们改变了它的颜色深度。颜色深度是图像压缩中第二重要的因素。这是因为您必须将像素的数量乘以颜色通道的数量，如果您可以减少这个乘数，您也可以极大地减少结果文件的大小。所以我们没有使用 32 位的 PNG，而是使用了 8 位的 PNG；通过这样做，我们将压缩的像素数量从 36，864 减少到 9，216。

正如你在[图 7-2](#Fig2) 的截屏顶部看到的，attacklaser.png 是一个 8 位索引彩色 PNG 图像，然而它看起来像是一个更高质量的真彩色图像。这是因为我使用了**抖动**，这是 8 位图像压缩的一个关键选项。

抖动包括在 8 位索引调色板中模拟超过 256 种允许的颜色。这是通过使用微妙的点模式来混合两种颜色，形成介于两种颜色之间的第三种颜色。这种技术欺骗眼睛，让它认为有超过 256 种颜色被用来创建图像。由于最近流行的 XXHDPI(超高密度像素图像)Android 屏幕中的像素尺寸较小(像素尺寸称为点距)，抖动是一种有价值的技术。

抖动对 8 位图像特别有用，这些图像表现出一种称为**条纹** 的颜色深度转换特性，因为它可以通过这种技术模拟 512 种颜色来减轻或消除条纹。请注意，图像数据中的抖动模式会稍微增加文件的大小，因此请确保打开和关闭抖动选项，以查看图像质量是否提高到足以值得增加到图像数据占用空间中的那几个额外的数据字节。

提升我们的新行星活动:应用成像概念

现在是时候看看这些概念如何应用到我们的 Android 应用程序开发中了。让我们给我们的新行星活动屏幕添加一个星域背景，这样我们的行星就在它们所属的太空中了。

给我们的 HelloWorld 应用程序 添加一个星星图像背景

我们需要做的第一件事是将这些 starfield 图像资产复制到各自的文件夹中。将 stars320x480.png 复制到 drawable-ldpi 文件夹，将 stars480x800.png 复制到 drawable-mdpi 文件夹，将 stars1024x600.png 复制到 drawable-hdpi 文件夹，最后将 stars1280x720.png 文件复制到 drawable-xhdpi 文件夹。将每个分辨率版本复制到各自的 drawable 文件夹后，请务必将每个版本重命名为简单的**stars.png**。

首先，注意这些是索引的 PNG8 文件，大小从 6KB 到小于 24KB 不等，尽管最大的是 HD 分辨率。星星是用于索引文件格式的最佳图像类型的完美示例，因为有很多黑色区域，没有太多图像细节或颜色变化，所以在这种情况下，PNG8 的压缩结果令人惊讶。

编辑我们的屏幕布局 XML 来引用星星背景图片

接下来打开 **activity_add.xml** 文件，添加一个 **android:background** 参数，通过 **@drawable/stars** 路径寻址机制引用 stars.png 文件，如图[图 7-3](#Fig3) 所示。然后选择 Hello_World 项目文件夹，点击 **F5** 键刷新项目视图，或者右键单击项目文件夹，选择**刷新**菜单选项。然后点击编辑窗格底部的**图形布局**选项卡，预览我们的图像合成结果。正如你在[图 7-4](#Fig4) 中看到的，行星在星空背景下看起来很棒，但是我们的说明文字似乎已经消失了，在我们用户界面屏幕的左侧有一条 22 度倾斜的白色条纹。

![9781430257462_Fig07-03.jpg](../Images/9781430257462_Fig07-03.jpg)

[图 7-3。](#_Fig3)在 activity_add.xml 文件中添加一幅 starfield 背景图像，以合成包含一些恒星的行星

![9781430257462_Fig07-04.jpg](../Images/9781430257462_Fig07-04.jpg)

[图 7-4。](#_Fig4)使用 Eclipse 中的图形布局编辑器选项卡预览我们的 android:background 参数

这不是我们期望的专业用户界面结果，所以我们需要改变我们标签中的几个标签参数，以进行调整，现在我们有了深色的星空背景，而不是白色的背景色(见[图 7-4](#Fig4) )。

调整我们的 XML 标签参数以适应新的星星背景图片

这里发生的事情是，我们已经在我们的 RelativeLayout 布局容器中使用了 **marginLeft** 参数来将行星作为一个组居中；现在我们已经为布局容器设置了背景图像，marginLeft 参数也将背景图像推过 22 度，从而在左侧产生白色条纹。

Android 操作系统使用白色的默认应用程序背景颜色，就像它对所有布局容器的默认颜色值一样。这就是所显示的，因为我们通过 android:marginLeft="22dp "参数推动整个布局容器。

为了纠正这一点，我们将从相对布局容器标签中移除参数 **marginLeft** ，取而代之的是，我们将把它放入我们的每个 ImageView 标签中，以相同的量推动它们，如图[图 7-5](#Fig5) 所示。

![9781430257462_Fig07-05.jpg](../Images/9781430257462_Fig07-05.jpg)

[图 7-5。](#_Fig5)修改我们的 TextView 和 Button 标签，添加白色文本颜色参数和 MarginLeft 参数

我们还需要将 marginLeft 参数的另一个副本放入 TextView，并将其推回，这样它就不会触及用户界面屏幕的左边缘。

调整我们的 TextView 标签的 textColor 参数 来增加对比度

接下来，我们需要向 TextView 和 Button 标签添加一个设置为 **#FFFFFF** (白色)的 **android:textColor** 参数，这样我们就可以在 stars.png 背景下看到标题和按钮标签。在数字成像理论中，我们需要学习的另一个重要概念是**对比度**，为了获得可读的文本，我们需要高对比度，即深色背景下的亮色文本。该标签参数添加如[图 7-5](#Fig5) 所示。

现在我们已经对需要它们的标签进行了 android:marginLeft 和 android:textColor 参数更改，是时候使用**作为 android 应用程序**运行并调用 Nexus S 模拟器，并实际查看我们新升级的添加行星用户界面屏幕看起来是什么样子。

正如你在[图 7-6](#Fig6) 中看到的，由于白色文本和深色 starfield 背景之间的**高对比度**，文本现在是可读的，按钮看起来也不错。你有没有注意到，当我们把 stars.png 的图像放在后面时，按钮的背景变暗了？这是因为按钮背景不仅是灰色的，它也是透明的，事实上，你可以看到一个小星星就在按钮的顶部，透过这种透明显示出来。

![9781430257462_Fig07-06.jpg](../Images/9781430257462_Fig07-06.jpg)

[图 7-6。](#_Fig6)在 Nexus S 模拟器中预览我们的图像合成结果

这是一个**混合**的例子，我之前提到过，其中按钮背景颜色是通过算法添加到每个背景像素颜色中的。这允许您将按钮放在图像上，以获得更专业的视觉效果。注意，这个混合量也可以在 XML 参数或 Java 代码中更改。

因为这看起来很好，让我们继续将 stars.png 图像添加到 AttackPlanet 用户界面屏幕背景。在应用程序中多次使用图像资产是从图像资产中获得更多收益的好方法，这有助于使应用程序的数据足迹更小。

升级我们的 TravelPlanet UI:为我们的攻击病毒 创建阿尔法通道

在我们将 android:background 参数添加到 activity_attack.xml 文件之前，就像上一节添加行星屏幕一样，我们需要为 UI 的一个图标图像创建一个 alpha 通道。您可能已经注意到，在将图标复制到项目子文件夹中时，其中一个图像，attackvirus.png，在病毒周围有一个实心的黑色背景，而不是像其他四个图标那样具有透明度。

让我们使用 GIMP 开源图像编辑软件来完成纠正这一问题的工作流程，这样您就知道这是如何完成的了，因此稍后，我们可以在任何背景上放置病毒，并获得无缝的结果。

添加透明度:创建一个阿尔法通道蒙版

启动 GIMP 2.8.4，然后使用**文件![image](../Images/arrow.jpg)打开**菜单序列打开位于项目资源 **drawable-xhdpi** 文件夹中的**attackvirus.png**文件(见[图 7-7](#Fig7) )，因为该文件的分辨率为 **96 像素**。在数字成像中，我们总是从最高分辨率开始，然后逐渐降低以避免任何像素化。

![9781430257462_Fig07-07.jpg](../Images/9781430257462_Fig07-07.jpg)

[图 7-7。](#_Fig7)打开 drawable-xhdpi 文件夹中的 attackvirus.png 文件，然后调用“按颜色选择”工具

点击**选择**菜单和【按颜色 T2】图像区域选择工具，这将使您进入**连续颜色选择模式**，该模式将选择包含具有相同 RGB 颜色值的像素集合的颜色区域。

一旦进入工具模式，将**阈值**(选择灵敏度)设置为 **40** ，并点击图像四个角之一的**黑色像素**。由于我们的病毒细胞本身有几种不同的颜色值，所以选择病毒细胞中**而不是**的颜色，而不是试图选择病毒细胞的颜色，这是一个更合理的工作过程。一旦你的**选择框**(行进的蚂蚁轮廓)看起来像在[图 7-8](#Fig8) 中一样，使用键盘上的**删除**键删除黑色像素。

![9781430257462_Fig07-08.jpg](../Images/9781430257462_Fig07-08.jpg)

[图 7-8。](#_Fig8)通过显示选择和选项对话框的颜色选择框进行选择，阈值设置为 40

一旦你按下 Delete 键，你会看到 GIMP 中使用的白色背景色(就像 Android 使用的作为其 app 背景色一样)，这将使我们的 alpha 通道图像**蒙版**的进一步编辑(清理)更加容易([图 7-9](#Fig9) )。

![9781430257462_Fig07-09.jpg](../Images/9781430257462_Fig07-09.jpg)

[图 7-9。](#_Fig9)删除选中的黑色值，显示 GIMP 默认的白色背景色

遮罩定义了将要在图像合成中显示或使用的图像部分，因此，我们在此进行的过程称为**将攻击病毒细胞从攻击病毒细胞的图像中掩蔽**。

接下来，再次下拉**选择**菜单，选择**无**选项，确保在我们编辑图像之前，图像中没有任何内容被选中。然后选择**橡皮擦**工具(在你的工具面板中寻找一个老派橡皮擦)并将工具设置为 **1 像素**、**方形纵横比** (0 值)和**角度**设置为 0(与屏幕成直角)，并从**动态**下拉菜单中选择**铅笔通用**。使用橡皮擦工具，单击未被选中的边缘黑色像素，因为它们与您单击以调用该工具的黑色像素值不够接近。

这个过程被称为**清理你的遮罩**，这样做是为了让你在攻击病毒图像对象周围获得一个更紧密的选择区域，我们稍后将在我们的 Android 应用程序中使用该区域进行合成效果。

通过比较[图 7-9](#Fig9) 和[图 7-10](#Fig10) 可以看出这次黑色像素清理过程的前后对比。请确保在边缘留下一些暗像素，以更好地混合我们将在 Hello World 应用程序中使用的暗背景。

![9781430257462_Fig07-10.jpg](../Images/9781430257462_Fig07-10.jpg)

[图 7-10。](#_Fig10)使用橡皮擦工具清理我们的面具，准备创建一个阿尔法通道

反转 Alpha 通道选择病毒

现在，我们将再次使用**按颜色选择**工具，并点击当前图像角落的白色区域，通过刚刚清理的蒙版重新选择我们的新对象。这更精确地选择了病毒(或者更确切地说不是病毒)，正如你在[图 7-11](#Fig11) 中看到的。接下来调用**选择![image](../Images/arrow.jpg)反转**菜单操作，将我们的选择从非病毒改为病毒本身。

![9781430257462_Fig07-11.jpg](../Images/9781430257462_Fig07-11.jpg)

[图 7-11。](#_Fig11)使用选择![image](../Images/arrow.jpg)反转来反转选择

继续操作**反转**你的选择蒙版，得到一个正确选择的最终攻击病毒对象像素集合。现在，我们将使用**编辑**![image](../Images/arrow.jpg)T5】复制来复制攻击病毒像素到我们的系统剪贴板。

现在我们已经选择了攻击病毒图像对象的像素并将其复制到剪贴板，我们可以将它们粘贴到一个新文件中。当我们这样做时，GIMP 将在没有任何像素的像素位置放置一个 alpha 通道(透明)。

GIMP 2.8 还根据系统剪贴板中选择数据所使用的水平和垂直像素数，自动设置新的图像像素分辨率。在这种情况下，这是 90 乘 89，如在截图左下方带有 alpha 通道的新攻击病毒图像的窗口标题中的[图 7-12](#Fig12) 所示。在屏幕截图的右边，你还会看到新图像的 **ARGB 通道**，以及通过**粘贴为![image](../Images/arrow.jpg)新图像**为我们创建的阿尔法通道。

![9781430257462_Fig07-12.jpg](../Images/9781430257462_Fig07-12.jpg)

[图 7-12。](#_Fig12)使用粘贴为![image](../Images/arrow.jpg)新图像创建新图像(左下)与阿尔法通道(右上)

在图 7-11 和图 7-12[中注意到同样重要的是，如果你把你的鼠标放在一个菜单项或者一个工具箱图标上，GIMP 会弹出一个工具提示，告诉你如果你选择使用它，这个工具会做什么。这是探索 GIMP 能做什么和了解它的特性的一个重要途径。](#Fig12)

在[图 7-12](#Fig12) 中，不仅显示了我们将从下一个操作中生成的新的无标题图像，还显示了操作菜单选项(为了节省空间，我创建了一个二合一截图)，您将看到**编辑**菜单有一个**粘贴为**子菜单，它本身有一个包含**新图像**粘贴功能的子子菜单，该功能将把剪贴板中复制的攻击病毒像素粘贴到一个全新的图像文件工具提示说:**从剪贴板的内容中创建一个新图像**。工具提示没有说明的是:GIMP 会在剪贴板中没有像素的像素位置自动创建 alpha 通道。

注意在图 7-12 右上角的 alpha 通道中，GIMP 在病毒所在的地方使用白色像素(开或可见)，在我们最初编辑选择蒙版的地方使用黑色像素(关或透明)。还要注意，在图像通道上方，通道图标被表示为三维的 RBG 值层；这是考虑颜色通道的一个很好的方法，尽管最终是数学将这些 ARGB 值相加来定义每个像素的颜色和半透明级别。

以 GIMP XCF 本地格式 保存我们到目前为止的工作

因为我们的新图像是**未命名的**让我们使用**文件![image](../Images/arrow.jpg)另存为**菜单序列给我们的带有 alpha 的新图像命名，并保存它，这样我们不会丢失所有的工作。我将文件命名为: **attackvirusnew.xcf** (GIMP 原生格式)用 attackvirusnew.xcf 放入 **drawable-xhdpi** ，如图[图 7-13](#Fig13) 所示。

![9781430257462_Fig07-13.jpg](../Images/9781430257462_Fig07-13.jpg)

[图 7-13。](#_Fig13)将新的无标题图像保存为 attackvirusnew.xcf，这样我们的工作就被保存了

下一件事，我们想做的是把我们新掩盖的攻击病毒放回 96x96 像素图像容器的中心。我们需要在创建此图像资产的其他三个较低分辨率版本之前完成此操作，我们需要在 Android 项目资源可绘制子文件夹结构内的其他三个分辨率图像文件夹中使用这些图像资产。

使用画布大小工具将我们新蒙版的图像 重新居中

我们将使用**图像![image](../Images/arrow.jpg)画布大小**菜单序列重新调整蒙版图像的中心，这将调用 GIMP 中的画布大小对话框。假设 GIMP 中新标题为 attackvirusnew 的窗口处于活动状态，让我们对 90x89 像素的图像应用画布大小图像操作，并将其转换为 96x96 像素的图像。

**画布尺寸**对话框如图[图 7-14](#Fig14) 所示，它允许您输入**目标分辨率**(画布尺寸)，并通过使用对话框右侧的**中心**按钮来设置**相对于每个 X Y 尺寸的偏移**，或允许 GIMP 为您完成此操作。这就是我所做的，因为我是那种喜欢走捷径的人，因此 GIMP 在我这样做的时候在 X 和 Y 字段中分别输入了 3 个像素的值。

![9781430257462_Fig07-14.jpg](../Images/9781430257462_Fig07-14.jpg)

[图 7-14。](#_Fig14)使用图像![image](../Images/arrow.jpg)画布大小和中心功能，在 96 像素的正方形中重新定位蒙版图像

使用 GIMP 的文件导出(另存为)对话框 将新图像保存为 PNG32 文件格式

现在我们准备将我们攻击病毒的 alpha 通道版本保存为一个带索引的彩色 PNG 文件，这在 GIMP 中是使用**文件![image](../Images/arrow.jpg)导出**菜单序列完成的。在 GIMP 中，使用**保存**会产生一个 **XCF** (GIMP 原生)文件格式，而**导出**通过其他流行格式保存。你可能更熟悉这个叫做另存为的软件操作。。。函数，在 GIMP 2 . 6 . 12 和更早的版本中是这样，在其他软件包中也是这样，所以你需要习惯 GIMP 2.8 和更高版本。

[图 7-15](#Fig15) 显示了 GIMP 中的导出图像对话框，在这里我们输入新的文件名 attackvirusalpha 和扩展名。png 来指定格式。

![9781430257462_Fig07-15.jpg](../Images/9781430257462_Fig07-15.jpg)

[图 7-15。](#_Fig15)使用文件![image](../Images/arrow.jpg)导出图像来导出带有 alpha 通道的新的 PNG8 版本的图像

在 GIMP 中，文件格式被指定为我们输入的文件名的一部分，或者如果您想查看可以导出的其他文件类型，您可以使用对话框左下角的选择文件类型(按扩展名)UI 元素。我通常使用。tif (TIFF 或标记图像文件格式)或。png，因为这些是无损格式，可以产生完美的视觉效果，但您也可以使用。jpg (JPEG，一种有损格式)甚至。tga (Targa，另一种无损格式)格式，如果你喜欢的话。

一旦我们将 attackvirusalpha 导出为 PNG8，我们需要进入我们的 OSes 文件管理器(Explorer 或类似的)，并重命名一些文件，以便接下来我们可以访问 Eclipse 中图形的正确(alpha)版本。

图 7-16 中显示的是 Windows 7 资源管理器，我们已经将我们的旧版本(原始)attackvirus.png 重命名为 attackvirusold.png，然后**将新的**attackvirusalpha.png**文件重命名为**attackvirus.png**，这在我们的 Hello World 应用程序的 XML 标记中被引用，如截图所示。**

![9781430257462_Fig07-16.jpg](../Images/9781430257462_Fig07-16.jpg)

[图 7-16。](#_Fig16)使用 Windows 资源管理器将 attackvirus 重命名为 attackvirus old，将 attackvirusalpha 重命名为 attackvirus

注意，我们的 GIMP attackvirusnew.xcf 工作文件现在也出现了；这不会影响我们在 Eclipse 中的项目，但是我们可以稍后删除这个文件，或者将它移动到我们硬盘驱动器上的另一个文件夹，比如说，一个用于原始艺术品或开发中资产的文件夹，如果您愿意的话。

使用图像调整工具 创建我们的其他分辨率密度图像版本

现在，我们的最高分辨率图像资产已经被遮罩，并包括一个 alpha 通道来定义其透明度，我们可以将图像调整到 80 像素、64 像素和 48 像素版本，这是我们的应用程序项目资源文件夹层次结构中的其他可绘制文件夹所需的(参见[图 7-17](#Fig17) )。

![9781430257462_Fig07-17.jpg](../Images/9781430257462_Fig07-17.jpg)

[图 7-17。](#_Fig17)使用图像![image](../Images/arrow.jpg)缩放图像和三次插值将 96 像素图像调整为 80 像素

这个工作过程是通过**图像**菜单和**缩放图像**子菜单完成的，子菜单访问常用的缩放图像工具对话框，该对话框用于将数字图像调整到不同的分辨率。注意**链图标**，它允许你**锁定**图像**纵横比**，正如我们之前讨论的。

将**宽度**字段中的 **96** 替换为 **80** ，然后注意，当您单击高度字段(或按回车键)时，其他字段也会自动键入 80，因为纵横比被锁定(默认)。第二组字段包含屏幕分辨率(像素密度)，因此对于屏幕工作，将这些字段设置为 72 DPI(对于打印，使用 300 DPI 或更高)。

将缩放算法的**插值质量**下拉菜单设置为**三次**(在 Photoshop 中称为双三次)，然后点击**缩放**按钮。

现在我们的图像是 80×80 像素，我们需要经历与之前完全相同的工作过程，从[图 7-13](#Fig13) 开始。将您的文件保存为 GIMP。XCF 如果你以后需要它，在 drawable-ldpi 文件夹中，然后将其导出为一个名为 **attackvirusalpha** 的 **PNG8** ，然后进入你的文件管理器，这样你就可以将原始文件重命名为 **attackvirusold** ，并将新文件重命名为 **attackvirus** ，这样在我们**刷新**我们的项目视图后，正确的图像数据就可以用在你的 Android Hello World 应用程序中了。

对 **drawable-mdpi** 中的 **64 像素**图像资产，以及 **drawable-ldpi** 中的 **48 像素**图像资产再次进行这个工作过程，当你完成时，你将有机会熟悉这个工作过程。

现在，我们准备进入 XML 标记，将星星添加到 AttackPlanet 用户界面屏幕布局容器的背景中。值得注意的是，当您将图像缩放至 64 和 48 像素时，您应该从 96 像素版本的已保存图像开始，以便为图像大小调整算法提供最多的数据，从而获得最佳的缩放结果。

启动 Eclipse(如果尚未打开)并单击 activity_attack XML editing 选项卡，将您的 LinearLayout android:background 参数从 black (#000000)更改为@drawable/stars.png，并且不要忘记 **Refresh** ！

每当您更改任何文件名或文件内容或添加新文件时，您必须总是右键单击您的项目文件夹并选择**刷新**或左键单击(选择)您的项目文件夹并点击键盘上的 **F5** 键。

现在让我们**作为 Android 应用程序**运行，看看我们使用深色背景和浅色文本的第二个用户界面屏幕后面的星星。

正如你将在[图 7-18](#Fig18) 中看到的，视觉效果和我们预期的一样令人难以置信，我们的星星通过图标和文本用户界面元素完美地显示出来。请注意，Android 中的文本元素有自己的 alpha 通道和不透明度设置，我们将在下一章中看到，届时我们将更详细地讨论用户界面元素(widget)图形设计技术。

![9781430257462_Fig07-18.jpg](../Images/9781430257462_Fig07-18.jpg)

[图 7-18。](#_Fig18) AttackPlanet UI 屏幕显示星星背景和白色背景上的伪装病毒

我们在 Hello World 应用程序的图形设计基础上取得了很大进展，现在我们一半的活动用户界面屏幕都展示了新的基于媒体的用户界面元素和背景。我们还学习了许多数字成像背后的基本原理，以及一些关于 alpha 通道和遮罩的数字成像工作流程。

摘要

在本章中，我们学习了数字图像和图形设计的基本概念，以及 Android 如何将这些概念融入其应用程序开发基础设施。为了在我们的 Hello World 应用程序中实践这些图形设计和数字成像概念，我们在一些活动中添加了 starfield 图像背景参数，并屏蔽了我们的 AttackVirus 以添加 alpha 通道，以便星星可以通过 UI 元素的透明区域无缝显示。

我们了解了 Android **Drawable** 类及其 **direct 子类**，它们定义了我们可以在 Android 应用程序中使用的所有各种类型的图形设计资产，包括**形状**、**颜色**、**插入**、**图层**、**渐变**和**位图**(位图图像，也称为基于像素的图像)。

我们学习了 Drawable 的更复杂的**间接子类**，比如动画、图像过渡、等级列表和状态列表。我们学习了 **DrawableContainer** ，并且我们可以创建我们自己的自定义间接多图形子类，使用那个超类作为它们的基础。

接下来，我们看了一下**像素**的概念，它是数字成像和数字视频的构建模块。然后，我们看了分辨率和长宽比的图像概念，以及如何使用简单的数学计算两者。

我们学习了**色彩理论**，以及数字成像中使用的不同色深，以及如何使用**十六进制符号**来表示颜色。我们学习了如何根据图像的**色深**计算图像中的颜色总数，以及关于**索引色**图像和 256 种颜色**调色板**的概念，调色板**从**真彩色**图像中取样**原色。

我们了解了图像**通道**和 **RGB** 颜色通道，以及第四个 **alpha 通道**，它保存像素的透明度值，以便图像可以通过使用**层**和**混合模式**用于**合成**更复杂的图像或特殊效果。我们通过**Android . graphics . porter duff**类了解了 Android 中的混合支持，并了解了它的主要混合模式，例如:**叠加**、**屏幕**、**变暗**、**变亮**、**异或**。

我们涵盖了 Android 中所有不同的图形文件格式，以及哪些格式更适合使用，为什么，以及哪些格式是无损的，哪些是有损的。我们介绍了 Android 4.0 和更高版本中新的 **WebP** 图像格式支持，并介绍了带有 alpha 通道图像的 **PNG8** 索引和 **PNG24** 真彩色和 **PNG32** 真彩色之间的区别。

最后，我们介绍了压缩概念和技术，如**抖动**，然后我们将学到的数字成像概念应用到 Hello World 应用程序中，通过将酷图标和文本与自定义背景 starfield 图像进行合成，添加更多视觉设计和专业功能。

在下一章中，我们将在本章建立的数字成像知识的基础上，添加自定义 UI 元素。****