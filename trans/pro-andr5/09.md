第章 9

响应配置更改

到目前为止，我们已经介绍了相当多的内容，现在似乎是介绍配置更改的好时机了。当应用在设备上运行时，如果设备的配置发生变化(例如旋转 90 度)，应用需要做出相应的响应。新配置看起来很可能与以前的配置不同。例如，从纵向模式切换到横向模式意味着屏幕从又高又窄变成了又短又宽。UI 元素(按钮、文本、列表等等)需要重新排列、调整大小，甚至删除以适应新的配置。

在 Android 中，默认情况下，配置更改会导致当前活动消失并被重新创建。应用本身继续运行，但是它有机会改变活动的显示方式以响应配置的改变。在极少数情况下，您需要在不破坏和重新创建活动的情况下处理配置更改，Android 也提供了一种处理方式。

请注意，配置更改可以采取多种形式，而不仅仅是设备旋转。如果设备连接到 dock，这也是一种配置更改。改变设备的语言也是如此。无论新的配置是什么，只要你已经为该配置设计了你的活动，Android 会处理大部分事情来过渡到它，给用户一个无缝的体验。

本章将从活动和片段两个角度带您了解配置变更的过程。我们将向您展示如何为这些转换设计您的应用，以及如何避免可能导致您的应用崩溃或行为不当的陷阱。

默认配置更改流程

Android 操作系统会跟踪运行它的设备的当前配置。配置包括许多因素，而且新的因素一直在增加。例如，如果设备被插入扩展坞，这表示设备配置发生了变化。当 Android 检测到配置更改时，运行中的应用会调用回调来告诉它们正在发生更改，因此应用可以正确地对更改做出响应。我们稍后将讨论这些回调，但是现在让我们刷新一下关于资源的记忆。

Android 的一个伟大特性是根据设备的当前配置为你的活动选择资源。您不需要编写代码来确定哪个配置是活动的；你只需按名称访问资源，Android 就会为你获取相应的资源。如果设备处于纵向模式，并且您的应用请求布局，您将获得纵向布局。如果设备处于横向模式，您将获得横向布局。代码只是请求一个布局，而没有指定应该获得哪个布局。这是非常强大的，因为当引入新的配置因子或配置因子的新值时，代码保持不变。开发人员需要做的就是决定是否需要创建新的资源，并根据新配置的需要创建它们。然后，当应用经历配置更改时，Android 向应用提供新的资源，一切继续按预期运行。

由于非常希望事情简单，当配置改变时，Android 破坏当前的活动，并在它的位置创建一个新的活动。这可能看起来相当苛刻，但事实并非如此。更大的挑战是采取一个运行的活动，并找出哪些部分会保持不变，哪些不会，然后只处理需要改变的部分。

一个即将被销毁的活动首先被适当地通知，给你一个机会去保存任何需要保存的东西。当新活动被创建时，它有机会使用前一个活动的数据来恢复状态。为了获得良好的用户体验，显然您不希望这种保存和恢复花费很长时间。

保存你需要保存的任何数据，然后让 Android 扔掉其余的并重新开始，这是相当容易的，只要应用及其活动的设计不包含大量非 UI 的东西，这些东西需要很长时间来重新创建。成功的配置变更设计的秘密就在于此:不要把“东西”放在一个在配置变更期间不容易被重新创建的活动中。

请记住，我们的应用并没有被销毁，所以应用上下文中的任何东西，不属于我们当前活动的一部分，都将在新活动中继续存在。Singletons 仍然是可用的，任何后台线程也是可用的，这些线程可能是我们为了应用而分离出来的。我们合作过的任何数据库或内容提供商也将继续存在。利用这些优势可以快速、轻松地更改配置。如果可能的话，将数据和业务逻辑放在活动之外。

活动和片段之间的配置变更过程有些相似。当一个活动被销毁和重新创建时，该活动中的片段被销毁和重新创建。我们需要担心的是关于我们的片段和活动的状态信息，比如当前显示给用户的数据，或者我们想要保留的内部值。我们将保存我们想要保留的东西，并在碎片和活动被重新创建时在另一边再次拾起它。您会希望通过不让数据在默认的配置更改过程中被破坏来保护不容易重新创建的数据。

活动的破坏/创建周期

在处理活动中的默认配置更改时，需要注意三个回调:

*   onSaveInstanceState()
*   onCreate()
*   onRestoreInstanceState()

第一个是 Android 在检测到配置发生变化时调用的回调。在配置更改结束时创建新活动时，活动有机会保存它想要恢复的状态。在调用 onStop() 之前，将调用 onSaveInstanceState() 回调。任何存在的状态都可以被访问并保存到一个 Bundle 对象中。当活动被重新创建时，这个对象将被传递给其他两个回调函数( onCreate() 和onRestoreInstanceState())。您只需要在其中一个中放入逻辑来恢复活动的状态。

默认的 onSaveInstanceState() 回调为您做了一些好事。例如，它遍历当前活动的视图层次结构，并保存每个具有 android:id 的视图的值。这意味着如果您的 EditText 视图接收到一些用户输入，那么该输入将在活动销毁/创建周期的另一端可用，以在用户取回控制权之前填充 EditText 。您不需要亲自经历并保存这个状态。如果您确实覆盖了 onSaveInstanceState() ，请确保使用 bundle 对象调用super . onSaveInstanceState()，以便它可以为您处理此事。保存的不是视图，而是它们状态的属性，这些属性应该在销毁/创建边界上保持不变。

要将数据保存在 bundle 对象中，可以对整数使用 putInt() ，对字符串使用 putString() 等方法。 android.os.Bundle 类有不少方法；不限于整数和字符串。例如， putParcelable() 可以用来保存复杂对象。每个 put 都与一个字符串键一起使用，稍后您将使用与放入该值相同的键来检索该值。示例 onSaveInstanceState() 可能类似于[清单 9-1](#list1) 。

[***清单 9-1***](#_list1) 。样本 *onSaveInstanceState()*

```java
@Override
public void onSaveInstanceState(Bundle icicle) {
    super.onSaveInstanceState(icicle);
    icicle.putInt("counter", 1);
}
```

有时这个包被称为冰柱,因为它代表了一项活动的一小块冻结部分。在这个示例中，您只保存了一个值，它有一个计数器的键。您可以通过简单地向这个回调函数添加更多的 put 语句来保存更多的值。本例中的计数器值是临时的，因为如果应用被完全破坏，当前值将会丢失。例如，如果用户关闭了他们的设备，就会发生这种情况。在第 11 章中，你会学到更持久地保存价值的方法。这个实例状态只意味着在应用运行时保留值。对于需要长期保存的重要状态，不要使用这种机制。

为了恢复活动状态，您可以访问 bundle 对象来检索您认为存在的值。同样，您使用 Bundle 类的方法，比如 getInt() 和 getString() ，并传递适当的键来告诉您想要返回哪个值。如果键在包中不存在，则传回值 0 或 null (取决于被请求对象的类型)。或者您可以在适当的 getter 方法中提供默认值。[清单 9-2](#list2) 显示了一个示例onRestoreInstanceState()回调。

[***清单 9-2***](#_list2) 。样本 *onRestoreInstanceState()*

```java
@Override
public void onRestoreInstanceState(Bundle icicle) {
    super.onRestoreInstanceState(icicle);
    int someInt = icicle.getInt("counter", -1);
    // Now go do something with someInt to restore the
    // state of the activity. -1 is the default if no
    // value was found.
}
```

是在 onCreate() 还是在 onRestoreInstanceState() 恢复状态，由你决定。许多应用将在 onCreate() 中恢复状态，因为许多初始化工作都是在那里完成的。将两者分开的一个原因是，如果您正在创建一个可以扩展的 activity 类。进行扩展的开发人员可能会发现，与重写所有的 onCreate() 相比，用代码重写 onRestoreInstanceState() 来恢复状态会更容易。

这里需要注意的非常重要的一点是，当当前活动被完全销毁时，您需要非常关注对活动和视图以及其他需要进行垃圾收集的对象的引用。如果在保存的包中放入了引用被销毁的活动的内容，那么该活动就不能被垃圾收集。这很可能是一种内存泄漏，这种泄漏会越来越严重，直到您的应用崩溃。束中要避免的对象包括 Drawable s、 Adapter s、 View s，以及任何与活动上下文相关的东西。不要把一个 Drawable 放到包中，而是序列化位图并保存它。或者更好的是，在活动和片段之外管理位图，而不是在内部。将位图的某种引用添加到包中。当需要为新片段重新创建任何 Drawable 时，使用引用访问外部位图来重新生成您的 Drawable s。

碎片的破坏/创建循环

片段的销毁/创建周期与活动的周期非常相似。处于销毁和重新创建过程中的片段将调用其 onSaveInstanceState() 回调，允许该片段将值保存在 Bundle 对象中以备后用。一个区别是，当一个片段被重新创建时，六个片段回调接收这个捆绑对象: onInflate() ， onCreate() ， onCreateView() ， onActivityCreated() ， onViewCreated() 和 onViewStateRestored() 。最后两次回调是最近的，分别来自 Honeycomb 3.2 和 JellyBean 4.2。这给了我们很多机会从先前的状态重建我们的重建片段的内部状态。

Android 只保证在 onDestroy() 之前的某个时候会为片段调用 onSaveInstanceState() 。这意味着当调用 onSaveInstanceState() 时，可能会也可能不会附加视图层次。因此，不要指望遍历 onSaveInstanceState() 中的视图层次。例如，如果片段在片段后栈上，就不会显示 UI，所以就不会存在视图层次结构。这当然是可以的，因为如果没有 UI 显示，就没有必要试图捕获视图的当前值来保存它们。在试图保存其当前值之前，您需要检查视图是否存在，如果视图不存在，不要认为这是一个错误。

与 activities 一样，注意不要在 bundle 对象中包含引用一个 activity 或一个片段的条目，当这个片段被重新创建时，这个片段可能不存在。保持包的大小尽可能小，尽可能在活动和片段之外存储持久的数据，并简单地从您的活动和片段中引用它。那么您的销毁/创建周期将会更快，您产生内存泄漏的可能性会更小，并且您的活动和片段代码应该更容易维护。

使用 FragmentManager 保存片段状态

除了 Android 通知片段应该保存它们的状态之外，片段还有另一种保存状态的方式。在 Honeycomb 3.2 中， FragmentManager 类得到了一个saveFragmentInstanceState()方法，可以调用该方法来生成类 Fragment 的对象。保存的状态。前面提到的保存状态的方法是在 Android 内部完成的。虽然我们知道状态正在被保存，但我们无法直接访问它。这种保存状态的方法为您提供了一个对象，该对象表示一个片段的保存状态，并允许您控制是否以及何时从该状态创建一个片段。

使用片段的方法。SavedState 对象恢复一个片段是通过片段类的 setInitialSavedState() 方法实现的。在第 8 章的[中，您了解到最好使用静态工厂方法(例如， newInstance() )来创建新的片段。在这个方法中，您看到了如何调用默认构造函数，然后附加一个参数包。您可以调用 setInitialSavedState() 方法](08.html)来设置它以恢复到以前的状态。

关于这种保存片段状态的方法，您应该知道一些注意事项:

*   要保存的片段当前必须连接到片段管理器。
*   使用此保存状态创建的新片段必须与创建它的片段具有相同的类类型。
*   保存的状态不能包含对其他片段的依赖。当重新创建保存的片段时，其他片段可能不存在。

在片段上使用 setRetainInstance

片段可以避免在配置改变时被破坏和重新创建。如果使用参数 true 调用 setRetainInstance() 方法，当其活动被销毁和重新创建时，该片段将保留在应用中。不会调用该片段的 onDestroy() 回调，也不会调用 onCreate() 。将调用 onDetach() 回调，因为该片段必须从即将离开的活动中分离，并且将调用 onAttach() 和 onActivityCreated() ，因为该片段附加到一个新的活动。这只适用于不在后台堆栈上的片段。这对于没有 UI 的片段尤其有用。

这个特性非常强大，因为您可以使用一个非 UI 片段来处理对数据对象和后台线程的引用，并在这个片段上调用 setRetainInstance(true) ，这样它就不会在配置更改时被破坏和重新创建。额外的好处是，在正常的配置更改过程中，非 UI 片段回调 onDetach() 和 onAttach() 会将活动引用从旧的切换到新的。

不推荐使用的配置更改方法

关于活动的几个方法已经被否决，所以您不应该再使用它们:

*   getastnonconfiguration instance()
*   on retaining no configuration instance()

这些方法以前允许您保存正在被销毁的活动中的任意对象，并将其传递给正在创建的活动的下一个实例。尽管这些方法很有用，但是您现在应该使用前面描述的方法来管理销毁/创建周期中活动实例之间的数据。

自己处理配置更改

到目前为止，您已经看到了 Android 如何为您处理配置更改。它负责销毁和重新创建活动和片段，为新配置引入最佳资源，保留任何用户输入的数据，并让您有机会在一些回调中执行一些额外的逻辑。这通常是你的最佳选择。但如果不是这样，当你不得不自己处理配置变更时，Android 提供了一条出路。不建议这样做，因为这完全取决于您来确定由于这种变化需要改变什么，然后由您负责做出所有的变化。如前所述，除了方向变化之外，还有许多配置变化。幸运的是，您不必亲自处理所有的配置更改。

自己处理配置更改的第一步是在 AndroidManifest.xml 文件的 < activity > 标签中声明您将使用 android:configChanges 属性处理的更改。Android 将使用前面描述的方法处理其他配置更改。您可以根据需要指定任意多的配置更改类型，方法是将它们与“|”符号进行“或”运算，如下所示:

```java
<activity  ...   android:configChanges="orientation|keyboardHidden" ... >
```

配置更改类型的完整列表可以在 R.attr 的参考页面上找到。请注意，如果您的目标是 API 13 或更高版本，并且您需要处理方向，您还需要处理屏幕尺寸。

配置更改的默认过程是调用回调来销毁和重新创建活动或片段。当您已经声明您将处理特定的配置更改时，流程会发生变化，因此只有 onConfigurationChanged() 回调会在活动及其片段上被调用。Android 传入一个配置对象，因此回调知道新的配置是什么。由回调来确定可能发生了什么变化；然而，由于您自己可能只处理少量的配置更改，所以找出这一点应该不会太难。

当您可以跳过销毁和重新创建的时候，您真的只想自己处理配置更改。例如，如果纵向和横向的活动布局是相同的布局，并且所有图像资源都是相同的，则破坏和重新创建活动实际上并没有完成任何事情。在这种情况下，声明您将处理方向配置更改是相当安全的。在活动的方向改变期间，活动将保持不变，并使用现有资源(如布局、图像、字符串等)简单地以新的方向重新呈现自己。但是如果可以的话，让 Android 来处理这些事情真的没什么大不了的。

参考

以下是一些对您可能希望进一步探索的主题有帮助的参考:

*   :与本书相关的可下载项目列表。对于这一章，寻找一个名为pro Android 5 _ Ch09 _ config changes . ZIP的 ZIP 文件。这个 ZIP 文件包含本章中的所有项目，列在单独的根目录中。还有一个自述。TXT 文件，它准确地描述了如何将项目从这些 ZIP 文件之一导入到您的 IDE 中。
*   [http://Developer . Android . com/Guide/topics/fundamentals/activities . html # SavingActivityState](http://developer.android.com/guide/topics/fundamentals/activities.html#SavingActivityState):Android 开发者指南，讨论保存和恢复状态。
*   [http://developer . Android . com/Guide/topics/resources/Runtime-Changes . html](http://developer.android.com/guide/topics/resources/runtime-changes.html):处理运行时变更的 Android API 指南。

摘要

让我们通过快速列举您所学到的关于处理配置更改的内容来结束本章:

*   默认情况下，活动会在配置更改期间被销毁和重新创建。碎片也是。
*   避免将大量数据和逻辑放入活动中，以便快速进行配置更改。
*   让 Android 提供适当的资源。
*   使用单例来保存活动之外的数据，以便在配置更改期间更容易销毁和重新创建活动。
*   利用默认的 onSaveInstanceState() 回调来保存带有 android:id s 的视图的 UI 状态
*   如果一个片段在活动销毁和创建周期中没有问题，使用 setRetainInstance() 告诉 Android 它不需要销毁和创建这个片段。