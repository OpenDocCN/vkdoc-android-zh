第章第二十五章

探索 Android 持久性和内容提供商

在 Android SDK 中有许多保存状态的方法。其中包括 1)共享首选项，2)内部文件，3)外部文件，4) SQLite，5)内容提供商，6) O/R 映射工具，以及 7)云中的网络存储。我们将首先简要介绍每个状态保存选项，然后详细介绍使用 SQLite 和内容提供者管理应用状态。

使用共享偏好设置保存状态

我们已经在第 11 章中介绍了共享偏好。共享首选项是应用拥有的基于键/值的 XML 文件。Android 在这个通用的持久化机制之上有一个框架来显示/更新/检索偏好，而无需编写大量代码。后一个方面是[第十一章](11.html)的主要话题。

第 11 章还简要介绍了应用如何使用 XML 文件中的共享偏好 API 存储任何类型的数据。在这种方法中，数据首先被转换为字符串表示，然后存储在首选项键/值存储中。这种方法可以用来存储应用的任意状态，只要它是小到中等大小。

共享首选项 XML 文件是设备上应用的内部文件。其他应用不能直接使用这些数据。最终用户不能通过安装到 USB 端口上来直接操作这些数据。当应用被删除时，该数据被自动删除。

从简单到中等程度的应用持久性需求，您可以通过将各种 Java 对象树直接存储在共享首选项文件中来利用共享首选项。在给定的首选项文件中，可以有一个指向序列化 Java 对象树的关键点。您还可以为多个 Java 对象树使用多个首选项文件。我们已经使用 google 的 JSON/GSON 库非常有效地完成了从 Java 对象到它们的等效 JSON 字符串值的转换。在这种方法中，使用 google GSON 库将 Java 对象树作为 JSON 字符串进行流式传输。然后，该树作为一个值存储在首选项文件的键/值对中。请记住，Java 对象的 GSON 和 JSON 转换可能有一些限制。阅读 GSON/JSON 文档，了解 Java 对象可以变得多么复杂，才能使这种方法发挥作用。我们相当确信，对于大多数基于数据的 Java 对象来说，这是可行的。

清单 25-1 给出了一些使用 GSON/JSON 和共享参数保存 Java 树的示例代码。

[***清单 25-1***](#_list1) 。使用 JSON 在共享首选项 XML 文件中保存 Java 对象树

```java
//Implementation of storeJSON for storing any object
public void storeJSON(Context context, Object anyObject) {

    //Get a GSON instance
    Gson gson = new Gson();

    //Convert Java object to a JSON string
    String jsonString = gson.toJson(anyObject);

    //See [Chapter 11](11.html) for more details on how to get a shared preferences reference
    String filename = "somefilename.xml";
    int mode = Context.MODE_PRIVATE;
    SharedPreferences sp = context.getSharedPreferences(filename,mode);

    //Save the JSON string in the shared preferences
    SharedPreferences.Editor spe = sp.edit();
    spe.putString("json", jsonString);
    spe.commit();
}
//This code can then be used by a client like this:
//Create any data object with reasonable complexity
//Ex:  MainObject mo = MainObject.createTestMainObject();
//You can then call storeJSON(some-activity, mo) below
```

清单 25-2 展示了一些使用 GSON/JSON 和共享参数检索 Java 树的示例代码。

[***清单 25-2***](#_list2) 。使用 JSON 从共享首选项 XML 文件中读取 Java 对象树

```java
public Object retrieveJSON(Context context, String filename, Class classRef) {
    int mode = Context.MODE_PRIVATE;
    SharedPreferences sp = context.getSharedPreferences(filename,mode);
    String jsonString = sp.getString("json", null);
    if (jsonString == null)    {
        throw new RuntimeException("Not able to read the preference");
    }
    Gson gson = new Gson();
    return gson.fromJson(jsonString, classRef);
}

//You can then do this in the client code
MainObject mo = (MainObject)retrieveJSON(context,"somefilename.xml", MainObject.class);
String compareResult = MainObject.checkTestMainObject(mo);
if (compareResult != null)    {
       throw new RuntimeException("Something is wrong. Objects don't match");
}
```

这段代码要求您将 GSON Java 库添加到项目中。这种基于 GSON 的方法在我们的姊妹书《来自 Apress 的专家 Android》中有详细介绍。这个在网上也有简要记载在。

使用内部文件保存状态

在 Android 中，你也可以使用内部文件来存储你的应用的状态。这些内部文件是设备上应用的内部文件。其他应用不能直接使用这些数据。最终用户不能通过安装到 USB 端口上来直接操作这些数据。当应用被删除时，该数据被自动删除。

清单 25-3 显示了如何使用 GSON/JSON 和内部文件保存 Java 树的示例代码。

[***清单 25-3***](#_list3) 。从/向 Android 内部文件读取/写入 JSON 字符串

```java
private Object readFromInternalFile(Context appContext, String filename, Class classRef)
throws Exception
{
    FileInputStream fis = null;
    try {
        fis = appContext.openFileInput(filename);
        //Read the following string from the filestream fis
        String jsonString;

        Gson gson = new Gson();
        return gson.fromJson(jsonString, classRef);
}
    finally {
        // write code to closeStreamSilently(fis);
    }
}
private void saveToInternalFile(Context appContext, String filename, Object anyObject){
    Gson gson = new Gson();
    String jsonString = gson.toJson(anyObject);

    FileOutputStream fos = null;
    try {
        fos = appContext.openFileOutput(filename
                                ,Context.MODE_PRIVATE);
        fos.write(jsonString.getBytes());
    }
    finally    {
        // closeStreamSilently(fos);
    }
}
```

这种基于内部文件和 GSON 的方法在我们的姊妹书《来自 Apress 的专家 Android(【http://www.apress.com/9781430249504】)中有详细介绍。这在网上[http://androidbook.com/item/4439](http://androidbook.com/item/4439)也有简要记载。

使用外部文件保存状态

在 Android 中，外部文件要么存储在 SD 卡上，要么存储在设备上。这些成为公共文件，其他应用(包括用户)可以在应用环境之外看到和读取。对于许多想要管理内部状态的应用来说，这些外部文件会不必要地污染公共空间。

因为您表示为 JSON 的数据通常是特定于您的应用的，所以将其作为外部存储是没有意义的，外部存储通常用于音乐文件、视频文件或其他应用可以理解的格式的文件。

因为诸如 SD 卡的外部存储器可以处于各种状态(可用、未安装、已满等。)，当数据足够小时，为简单的应用编写这样的程序会更困难。因此，我们现在还不能很好地将应用状态保存在外部存储上。

如果应用需要音乐和照片，而这些可以放在外部存储中，同时将核心状态数据保存在 JSON 和 internal 中，那么混合方法可能是有意义的。

android.os.Environment 类和 android.content.Context 类有许多读写外部文件和目录的方法。我们没有包括代码示例，因为一旦您通过和 id.content.Context 访问这些文件，这种方法与内部文件非常相似。

使用 SQLite 保存状态

Android 应用可以使用 SQLite 数据库来存储它们的状态。SQLite 很好地集成到了 Android 的结构中。如果你想存储应用的内部状态，那么这可能是最好的方法。然而，使用包括 SQLite 在内的任何关系数据库都有许多细微差别。我们将在本章稍后介绍在 Android 上使用 SQLite 的要点和细微差别。

使用 O/R 映射库保存状态

O/R 映射代表对象到关系的映射。用 Java 这样的编程语言在关系数据库中存储状态的一个关键困难是 Java 对象结构和数据库的关系结构之间的不匹配。我们需要在名称、类型和字段关系之间进行映射，因为它们在 Java 空间和数据库空间中是等价的。这种映射容易出错。当我们稍后详细介绍 SQLite 时，您会看到这一点。

需要简化 Java 和 SQL 之间的数据映射。这个空间在业内被称为 O/R 映射。现在有一些工具可以在 Android 中解决这个问题。涵盖这些 O/R 映射工具的要点超出了本书的范围。但是我们现在将命名其中的几个工具并给出它们的在线参考。

这方面的两个关键工具是绿岛( [、http://greendao-orm.com/(](http://greendao-orm.com/))和奥姆利特( [、http://ormlite.com/](http://ormlite.com/))。每年都有更多的出现。所以经常检查看看新的是更快还是更容易。GreenDAO 使用基于模式定义的代码生成方法。据说比 OrmLite 快三到四倍。OrmLite 通过注释将模式定义与 Java 类融合在一起。后一种方法在编程上更容易。OrmLite 在任何 Java 平台上也是一样的。然而，可能由于在运行时使用反射，它可能会慢一些，但我怀疑对于大多数应用来说已经足够快了。

我们预测，使用这些 O/R 映射库之一是将您的应用更快推向市场的关键需求。我们建议您隔离持久性服务，从 OrmLite 开始，然后如果您的应用获得足够的牵引力或从您的原型转移到生产，则转移到 GreenDAO。

使用内容提供者 保存状态

Android 在基于 URIs 的数据存储之上提供了更高层次的抽象。使用这种方法，任何应用都可以像 URIs 一样使用 REST 读取或存储数据。这种抽象还允许应用通过基于 URI 字符串的 API 共享数据。在这种方法中，提交 URI 将返回数据库游标中的行和列的集合。如果被授予权限，URI 还可以接受一组键/值对，并将它们保存在目标数据库中。这是 Android 应用之间数据互操作性的通用机制。我们将在本章后面更详细地讨论这一点。如果您的应用拥有可供其他应用共享、创建或操作的宝贵数据，这是一种首选机制。例如，许多处理笔记、文档、音频或视频的应用将它们的数据实现为内容提供者。Android 的大部分核心数据相关服务也是如此。

使用网络存储保存状态

当一个应用创建或使用的数据需要由同一平台或不同平台(如协作应用)上的其他用户通过网络共享时，网络存储就发挥了作用。移动应用使用的这种后端服务设施被称为 MBaaS(移动后端即服务)。Parse.com 是 MBAAS 的一个例子，它提供后端服务，如用户管理、用户登录、安全、社交、公共网络存储、服务器端业务逻辑和通知。

Android 本身也使用一种叫做同步适配器的概念来在设备和网络服务器之间传输数据。你可以在[http://developer . Android . com/training/sync-adapters/index . html](http://developer.android.com/training/sync-adapters/index.html)了解更多关于同步适配器的信息。这是一个使用异步回调的框架，通过在最合适的时机调度和执行它来有效地优化任意数量数据的传输。框架苦于细节，开发人员只需提供转移代码。

以上总结了为 Android 移动应用保存状态的各种方法。我们现在将详细讨论其中的两种方法:SQLite 和内容提供者。我们将从 Android SQLite API 开始。

使用 SQLite 直接存储数据

在本节中，我们将详细探讨如何有效地使用 SQLite 来管理 Android 应用状态。你会明白 Android 对 SQLite 的支持程度。我们将向您展示重要的代码片段。我们将向您展示在 Android 上使用 SQLite 的最佳实践。我们将向您展示如何最好地加载 DDL 来创建您的数据库。我们将向您展示抽象持久性服务的更清晰的架构模式。我们将展示如何通过动态代理应用事务。这一节是对在 Android 上使用 SQLite 的一个健壮的处理。我们还有一个示例程序，您可以下载来查看完整的工作实现。让我们先快速概述一下 Android 中的 SQLite 包和类。

总结关键的 SQLite 包和类

Android 通过其 Java 包 android.database.sqlite 支持 SQLite。为了有效地使用 Android SQLite API，你需要理解的一些关键类在[清单 25-4](#list4) 中列出。注意，有些类在 android.database.sqlite 包之外。

[***清单 25-4***](#_list4) 。Android SDK 中的关键 SQLite Java 类

```java
android.database.sqlite.SQLiteDatabase
android.database.sqlite.SQLiteCursor
android.database.sqlite.SQLiteQueryBuilder
android.content.ContentValues
android.database.Cursor
android.database.SQLException
android.database.sqlite.SQLiteOpenHelper
```

让我们简单地讨论一下这些包和类。

**SQLiteDatabase**:SQLiteDatabase是一个 Java 类，表示数据库通常指的是一个。文件系统上的 db 文件。使用该对象，您可以查询、插入、更新或删除数据库中的给定表。您还可以执行一条任意的 SQL 语句。您可以应用事务。您还可以使用该对象通过 DDLs(数据定义语言)来定义表。DDL 是允许您创建数据库实体(如表、视图、索引等)的语句。通常，在您的应用中有一个表示数据库的该对象的实例。

**SQLiteCursor** :这个 Java 类表示从 SQLiteDatabase 返回的行的集合。它还实现了 android.database.Cursor 接口。这个对象有一些方法，像向前的数据库游标一样一次导航一行，并只在需要时检索行。如果需要，这个对象还可以像随机光标一样通过实现窗口特性向前或向后跳转。这也是您将用来读取任何当前行的列值的对象。

**SQLiteQueryBuilder** :这是一个 helper Java 类，通过递增地指定表名、列名、where 子句等来构造 SQLite 查询字符串。，作为单独的字段。这个类有许多 set 方法来逐步构建查询，而不是将整个 SQL 查询指定为一个字符串。如果您的查询很简单，您也可以直接在 SQLiteDatabase 类上使用查询方法。

**ContentValues** :这个类的 Java 对象包含一组键/值对，许多 SQLite 类使用它们来插入或更新一行数据。

**SQLException** :大部分 Android SQLite 数据库 API在有错误时抛出这个异常。

**SQLiteOpenHelper** :这个助手 Java 对象通过检查一些事情来提供对一个 SQLiteDatabase 的访问:给定一个数据库的文件名，这个对象检查该数据库是否已经安装并且可用。如果可用，它会检查版本是否相同。如果版本也相同，它提供对代表该数据库的 SQLiteDatabase 的引用。如果版本不同，它会在提供对数据库的有效引用之前提供一个回调来迁移数据库。如果数据库文件不存在，那么它提供一个回调来创建和填充数据库。您将扩展这个基类，并为这些不同的回调提供实现。您将很快在提供的代码片段中看到这一点。

这是您用来在 SQLite 数据库中保存应用状态的关键类的快速总结。现在让我们转向使用 SQLite 管理应用状态的关键概念。让我们从创建数据库开始。

创建 SQLite 数据库

Android 中数据库的创建是通过 SQLiteOpenHelper 类来控制的。对于应用中的每个数据库，您将拥有一个 Java 数据库对象，它是该类的一个实例。这个 SQLiteOpenHelper 对象有一对 get 方法来获取对读优化(配置为)或写优化(配置为) SQLiteDatabase 对象的引用。创建或获取对 SQLite 数据库对象的访问包括以下内容:

1.  扩展 SQLiteOpenHelper 并将数据库名称和版本提供给这个派生类的构造函数，以便这些值可以传递给基类
2.  从 SQLiteOpenHelper 中重写 onCreate() 、 onUpgrade() 和 onDowngrade() 方法。如果这个数据库不存在，您将调用 onCreate() 。如果数据库版本较新，则调用 onUpgrade() ，如果数据库版本比设备上的版本旧，则调用 onDowngrade()。您将在这些方法中使用 execute DDL 语句来创建或调整数据库。如果您的数据库不是新的或者版本相同，那么这两个回调都不会被调用。
3.  对此派生对象有一个静态引用。对此对象调用 get 方法以获取对可读或可写数据库副本的引用。使用这些数据库引用来执行 CRUD 操作和事务。

清单 25-5 是一个代码片段，展示了如何实现这些步骤来创建一个名为“booksqlite.db”的数据库，这个数据库保存了一个图书及其详细信息的表格。

[***清单 25-5***](#_list5) 。使用 SQLiteOpenHelper

```java
// File reference in project: DirectAccessBookDBHelper.Java
/**
* A complete example of SQLiteOpenHelper demonstrating
* 1\. How to create a databases
* 2\. How to migrate a database
* 3\. How to hold a static reference
* 4\. How to give out read and write database references
*
* This class also can act as a DatabaseContext.IFactory to produce read and write
* database references. This aspect is not critical to understanding but included
* for advanced readers and for some material later in the chapter.
*/
public class DirectAccessBookDBHelper extends SQLiteOpenHelper
implements DatabaseContext.IFactory
{
    //there is one and only one of these database helpers
    //for this database for this entire application
    public static DirectAccessBookDBHelper m_self =
       new DirectAccessBookDBHelper(MyApplication.m_appContext);

    //Name of the database on the device
    private static final String DATABASE_NAME = "bookSQLite.db";

    //Name of the DDL file you want to load while creating a database
    private static final String CREATE_DATABASE_FILENAME = "create-book-db.sql";

    //Current version number of the database for the App to work
    private static final int DATABASE_VERSION = 1;

    //Just a logging tag
    private static final String TAG = "DirectAccessBookDBHelper";

    //Pass the database name and version to the base class
    //This is a non public constructor
    //Clients can just use m_self and not construct this object at all directly
    DirectAccessBookDBHelper(Context context) {
        super(context,DATABASE_NAME,null,DATABASE_VERSION);
        //Initialize anything else in your system that may need a
        //reference to this object.
        //Example: DatabaseContext.initialize(this);
    }
    @Override
    public void onCreate(SQLiteDatabase db)  {
       try {
          //No database exists. Load DDL from a file in the assets directory
          loadSQLFrom(this.CREATE_DATABASE_FILENAME,db);
       }
       catch(Throwable t)       {
          //Problem creating database
          throw new RuntimeException(t);
       }
    }
    //A function to load one SQL statement at a time using execSQL method
    private void loadSQLFrom(String assetFilename, SQLiteDatabase db)    {
       List<String> statements = getDDLStatementsFrom(assetFilename);
       for(String stmt: statements){
          Log.d(TAG,"Executing Statement:" + stmt);
          db.execSQL(stmt);
       }
    }
    //Optimize this function for robustness.
    //For now it assumes there are no comments in the file
    //the statements are separated by a semicolon
    private List<String> getDDLStatementsFrom(String assetFilename)  {
       ArrayList<String> l = new ArrayList<String>();
       String s = getStringFromAssetFile(assetFilename);
       for (String stmt: s.split(";"))   {
          //Add the stmt if it is a valid statement
          if (isValid(stmt)) {
             l.add(stmt);
          }
       }
       return l;
    }
    private boolean isValid(String s)    {
        //write logic here to see if it is null, empty etc.
        return true; //for now
    }
    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)   {
       //Use old and new version numbers to run DDL statements
       //to upgrade the database
    }
    //Using your specific application object to remember the application context
    //Then using that application context to read assets
    private String getStringFromAssetFile(String filename)   {
       Context ctx = MyApplication.m_appContext;
       if ( ctx == null)   {
          throw new RuntimeException("Sorry your app context is null");
       }
       try   {
         AssetManager am = ctx.getAssets();
         InputStream is = am.open(filename);
         String s = convertStreamToString(is);
         is.close();
         return s;
       }
       catch (IOException x)    {
          throw new RuntimeException("Sorry not able to read filename:" + filename,x);
       }
    }
    //Optimize later. This may not be an efficient read
    private String convertStreamToString(InputStream is)  throws IOException   {
       ByteArrayOutputStream baos = new ByteArrayOutputStream();
       int i = is.read();
       while (i != -1)  {
          baos.write(i);
          i = is.read();
       }
       return baos.toString();
    }
   //Here are some examples of how to get access to readable and
   //writable databases. These methods will make sense once we get through the
   //the transactions applied through dynamic proxies
   /*
   public ReadDatabaseContext createReadableDatabase() {
      return new ReadDatabaseContext(this.getReadableDatabase());
   }
   public WriteDatabaseContext createWritableDatabase() {
      return new WriteDatabaseContext(this.getWritableDatabase());
   }
   */
}//eof-class DatabaseHelper
//Here is the code for MyApplication to remember the context
public class MyApplication extends Application {
   public final static String tag="MyApplication";
   public static volatile Context m_appContext = null;

   @Override
   public void onCreate() {
       super.onCreate();
          MyApplication.m_appContext = this.getApplicationContext();
   }
}
//assets/create-book-db.sql
CREATE TABLE t_books (id INTEGER PRIMARY KEY,
                name TEXT,  isbn TEXT, author TEXT,
                created_on INTEGER, created_by TEXT,
                last_updated_on INTEGER, last_updated_by TEXT
);
```

通过 DDLs 定义数据库

在[清单 25-5](#list5) 中，DirectAccessBookDBHelper是 SQLiteOpenHelper 的一个派生类，它允许我们检查一个现有的数据库，看看它是否需要被创建或者仅仅是基于它的版本被迁移。

只有当设备上不存在该数据库时，才会调用方法 onCreate() 。如果没有 SQLiteOpenHelper ，我们将不得不检查这个文件的物理位置，看看它是否存在。换句话说， SQLiteOpenHelper 实际上是一个瘦包装器，它为我们节省了许多“if-else”子句来检查数据库并进行必要的初始化:无论是创建数据库还是迁移数据库。

许多在互联网上创建 Android 数据库的例子使用 Java 代码中嵌入的 DDL 字符串来创建所需的表。作为 DDL 语句，Java 代码中的字符串难以阅读并且容易出错。更好的方法是将这些数据库创建脚本放在 assets 目录中的一个文本文件中。清单 25-5 中的示例代码演示了如何从应用的资产目录中读取一个文本文件，并使用 SQLiteDatabase 上可用的 execSQL() 函数来初始化数据库。

execSQL() 的一个限制是它一次只能执行一条 SQL 语句。这就是为什么[清单 25-5](#list5) 中的代码读取脚本文件并使用简单的语法将其解析成一系列语句。您可能希望搜索互联网，查看更好的解析工具，以获得更好的脚本文件支持。如果适合您的情况，另一种替代方法是拥有一个 schema 类，它的唯一目的是包含 DDL 的静态公共字符串，因为它减少了解析文件的需要。在本章末尾提供的在线参考资料中，我们有这些基于 Java 的库的链接。特别是，使用 ANTLR 的基于 Java 的工具对于复杂的数据库设置有很大的前景。

onCreate() 函数也将其执行包装在一个事务中，以便执行的数据库是一致的。

如果您有许多脚本，也可以创建整个数据库，并将其保存在 assets 文件夹中。在部署过程中，如果数据库不存在，您可以将文件复制到目标位置。

迁移数据库

如上所述， SQLiteOpenHelper 识别版本号，并适当地调用 onUpgrade() 方法来升级数据库。在这里，您可能还想在 assets 文件夹中保存一系列脚本，这些脚本可以根据版本号的不同适当地改变数据库。请记住，设备上的版本号可能小于或大于您的目标版本。因此，您可能需要一组对于每个转换序列都是唯一的脚本:从 V1 到 V3，或者从 V2 到 V3，或者从 V3 到 V1。后退可能需要警告或动态下载服务器端转换到旧版本，因为旧版本应用的源代码不太可能具有从未来版本退出所需的实用程序。

插入行

其核心是，将一行及其列值插入到 SQLiteDatabase 中仅仅是调用 SQLiteDatabase 对象上与插入相关的方法。解释这一点的伪代码如[清单 25-6](#list6) 所示。

[***清单 25-6***](#_list6) 。使用 SQLiteDatabase 插入行的基础知识

```java
//Get a reference to the database object
//Depending on the framework you have there could be many ways of doing this
SQLiteDatatabase db = DirectAccessBookDBHelper.m_self.getReadableDatabase();
String tablename; //which table you want to insert the row into

//populate a structure with the needed columns and their values
ContentValues cv = new ContentValues();
cv.put(columnName1, column1Value); //etc.

//A column that could be null if 'cv' is empty if an empty row is needed
//Provide null if that behavior is not needed
String nullColumnName = null;

//Insert the row
long rowId = db.insertOrThrow(tablename, nullColumnName, cv);
```

这段代码非常简单。使用这段代码插入任何 Java 对象仅仅是读取其属性，并将这些值放入 ContentValues 数据集中，然后插入。就 Android 的 SQLite insert 功能而言，你只需要知道这些。

如何最好地构造 Java 对象以及如何将这些值转换成内容值取决于您的框架。这是一个冗长乏味的过程。但是，这个细节对于 insert 的基本理解来说并不重要。大多数应用都需要这种严格程度。如果你认为这很复杂，你可以跳过，但是我们把它放在这里，因为我们觉得你的大多数应用都需要这种严格程度。

因此，为插入行获取正确的列名和值需要一些工作，您通常需要以下内容(不管您使用什么框架):

1.  一个 Java 对象，通常代表数据库中的行，例如一个 Book 对象
2.  保存一组帐册的表名
3.  Books 表中可用列的字符串名称
4.  最后，调用 insert 方法将 Book 对象持久化为 Books 表中的一行

我们将给出这些需求的代码片段(有些是伪代码)。对于实际的代码，你可以下载本章的项目。下面是清单 25-7 中的几个类，它们用 Java 代码表示一个图书对象。

[***清单 25-7***](#_list7) 。确保域对象和持久性之间的最小依赖

```java
// File reference in project: BaseEntity.Java
public class BaseEntity {
   private int id; //database identifier

   private String ownedAccount = null; //Multi-tenant if needed
   private String createdBy;
   private Date createdOn;
   private String lastUpdatedBy;
   private Date lastUpdatedOn;

   public BaseEntity(String ownedAccount, String createdBy, Date createdOn,
         String lastUpdatedBy, Date lastUpdatedOn, int id) {
      super();
      this.ownedAccount = ownedAccount;
      this.createdBy = createdBy;
      this.createdOn = createdOn;
      this.lastUpdatedBy = lastUpdatedBy;
      this.lastUpdatedOn = lastUpdatedOn;
      this.id = id;
   }
   //For persistence
   public BaseEntity(){}

   //Usual generated get/set methods
   //eliminated here for space. See the downloads
}
// File reference in project: Book.Java
public class Book extends BaseEntity
{
   //Key data fields
   //*************************************
   private String name;
   private String author;
   private String isbn;
   //*************************************

   public Book(String ownedAccount, String createdBy, Date createdOn,
         String lastUpdatedBy, Date lastUpdatedOn, String name,
         String author, String isbn) {
      super(ownedAccount, createdBy, createdOn, lastUpdatedBy, lastUpdatedOn,-1);
      this.name = name;
      this.author = author;
      this.isbn = isbn;
   }
   //To help with persistence
   public Book() {}
   //Generated methods get and set methods...
   //....
   //The following method is here for testing purposes
   //and also to see how a book object is typically created
   public static Book createAMockBook()  {
      String ownedAccount = "Account1";
      String createdBy = "satya";
      Date createdOn = Calendar.getInstance().getTime();
      String lastUpdatedBy = "satya";
      Date lastUpdatedOn = Calendar.getInstance().getTime();

      //See how many books I have and increment it by one
      //The following method returns a collection of books in the database
      //This is not essential for your understanding here
      //You will see this clarified when you read the section of transactions
      List<Book> books = Services.PersistenceServices.bookps.getAllBooks();
      int i = books.size();
      String name = String.format("Book %s",i);
      String author = "satya";
      String isbn   = "isbn-12344-" + i;

      return new Book(ownedAccount,createdBy,createdOn,
            lastUpdatedBy,lastUpdatedOn,
            name,author,isbn);
   }
}
```

这个清单有两个 Java 类:一个 BaseEntity 和一个扩展了 BaseEntity 的 Book 。看起来像清单 25-7 中的书的对象被称为域对象。这些是纯 Java 对象，它们可以在程序的 Java 空间中移动，而不会受到与持久性相关的行为的影响。然而，谁创建了这些对象，它们是何时创建的，这些属性被封装在 BaseEntity 中，这样所有的域对象都有这些基本信息。

因为 SQLite 数据库方法需要这些对象的显式列名，所以该方面是在一组单独的类中定义的，这些类描述了这些对象的元数据。这些支持类在[清单 25-8](#list8) 中给出。

[***清单 25-8***](#_list8) 。为域对象定义元数据

```java
// File reference in project: BaseEntitySQLiteSQLiteMetaData.Java
public class BaseEntitySQLiteSQLiteMetaData  {
   static public final String OWNED_ACCOUNT_COLNAME = "owned_account";
   static public final String CREATED_BY_COLNAME = "created_by";
   static public final String CREATED_ON_COLNAME = "created_on";
   static public final String LAST_UPDATED_ON = "last_updated_on";
   static public final String LAST_UPDATED_BY = "last_updated_by";
   static public final String ID_COLNAME = "id";
}
// File reference in project: BookSQLiteSQLiteMetaData.Java
public class BookSQLiteSQLiteMetaData extends BaseEntitySQLiteSQLiteMetaData {
   static public final String TABLE_NAME = "t_books";
   static public final String NAME = "name";
   static public final String AUTHOR = "author";
   static public final String ISBN = "isbn";
}
```

这两个类平行于它们各自的 BaseEntity 和 Book 对象类。您必须注意列名与数据库中的列名相匹配。所以这种需求基本上是容易出错的。除非您使用 O/R 映射库并创建自己的库，否则这个问题会一直存在，您必须做好测试。在我们前面讨论的 O/R 映射工具中，由程序员明确定义这些类是不必要的。

现在我们有了一个 Java 类来表示一本书及其元数据定义，它告诉我们表名和字段，我们可以继续编写 Java 代码来将一个 book 对象保存在数据库中，如[清单 25-9](#list9) 所示(注意这仍然是伪代码，使用下载查看任何遗漏的细节)。

[***清单 25-9***](#_list9) 。使用 Android SQLite APIs 插入一行

```java
// File reference in project: BookPSSQLite.Java
private long createBook(Book book) {
   //Get access to a read database
   SQLiteDatabase db = DirectAccessBookDBHelper.m_self.getWritableDatabase();

   //Fill fields from the book object into the content values
   ContentValues bcv = new ContentValues();
   //.... fill other fields example
   bcv.put(BookSQLiteSQLiteMetaData.NAME, book.getName());
   bcv.put(BookSQLiteSQLiteMetaData.ISBN, book.getIsbn());
   bcv.put(BookSQLiteSQLiteMetaData.AUTHOR, book.getAuthor());
   //.... fill other fields

   //if bcv is an empty set, then an empty row can possibly be inserted.
   //It is not the case for our book table. If it were though, the empty bcv
   //will result in an insert statement with no column names in it.
   //At least one column name is needed by SQL insert syntax.
   //It is one of these column names that goes below. For us this is not case so a null
   String nullColumnName = null;

    long rowId = db.insertOrThrow(BookSQLiteSQLiteMetaData.TABLE_NAME,
                      nullColumnName,
                      bcv);
    return rowId;
}
```

清单 25-9 中的逻辑非常简单。获取对我们想要保存的书对象的引用。将书中的字段值复制到一个 ContentValues 键/值对对象中。使用元数据类来正确定义字段名称。使用填充的 ContentValues 对象并调用 insert 方法。如果我们什么都不做，插入会被封装在自动提交中。我们将很快讨论如何进行交易，因为它的理论有点复杂，尽管代码写起来很简单。insert 方法返回该表新插入的主键 ID。这种返回表主键的约定来自底层 SQLite 产品文档，并不特定于 Android。

nullColumnName 与 SQL insert 语句的语法有关。如果该行有十列，但只有两列，并且指示了它们的非空值，则插入带有这两列的新行，并且预计剩余的八列将允许空值。如果您想要一个每列都为 null 的行，可以发出一个完全没有列名的 insert 语句，匹配空的内容值集。但是，不允许使用没有列名的 insert 语句。因此，这个参数 nullColumnName 可以包含一个可以为 null 的列名，以便满足 insert 语句的语法要求。当插入该行时，数据库会在内部将其余的列设置为 null。通常这个列名作为 null 传入，因为我们很少想要插入一个每一列都为空或 null 的行。

更新行

清单 25-10 是一个示例伪代码片段(完整代码见下载项目),展示了如何更新数据库中的一行。注意 Book object 和 BookSQLiteMetaData 类是如何被用来最小化指定表名和列名的错误的。该方法类似于插入方法。

[***清单 25-10***](#_list10) 。更新记录的 Android SQLite API

```java
// File reference in project: BookPSSQLite.Java
public void updateBook(Book book) {
   if (book.getId() < 0) {
      throw new SQLException("Book id is less than 0");
   }
   //Get access to a read database
   SQLiteDatabase db = DirectAccessBookDBHelper.m_self.getWritableDatabase();

   //Fill fields from the book object into the content values
   ContentValues bcv = new ContentValues();
   //.... fill other fields
   bcv.put(BookSQLiteSQLiteMetaData.NAME, book.getName());
   bcv.put(BookSQLiteSQLiteMetaData.ISBN, book.getIsbn());
   bcv.put(BookSQLiteSQLiteMetaData.AUTHOR, book.getAuthor());
   //.... fill other fields

   //You can do this
   String whereClause = String.format("%s = %s",BookSQLiteSQLiteMetaData.ID_COLNAME,book.getId());
   String whereClauseArgs = null;
   //Or the next 4 lines (this is preferred)
   String whereClause2 = BookSQLiteSQLiteMetaData.ID_COLNAME + " = ?";
   String[] whereClause2Args = new String[1];
   whereClause2Args[1] = Integer.toString(book.getId());

   int count = db.update(BookSQLiteSQLiteMetaData.TABLE_NAME, bcv, whereClause2, whereClause2Args);
   if (count == 0)   {
      throw new SQLException(
            String.format("Failed to update book for book id:%s",book.getId()));
   }
}
```

删除行

清单 25-11 是如何从数据库中删除一行的例子。

[***清单 25-11***](#_list11) 。Android SQLite API 删除记录

```java
// File reference in project: BookPSSQLite.Java
public void deleteBook(int bookid){
   //Get access to a writable database
   SQLiteDatabase db = DirectAccessBookDBHelper.m_self.getWritableDatabase();

   String tname = BookSQLiteSQLiteMetaData.TABLE_NAME;
   String whereClause =
      String.format("%s = %s;",
         BookSQLiteSQLiteMetaData.ID_COLNAME,
         bookid);
   String[] whereClauseargs = null;
   int i = db.delete(tname,whereClause, whereClauseargs);
   if (i != 1)   {
      throw new RuntimeException("The number of deleted books is not 1 but:" + i);
   }
}
```

读取行

[清单 25-12](#list12) 显示了使用 SQLiteDatabase.query() 方法从 SQLite 中读取的伪代码片段(完整代码参见下载项目)。这个方法返回一个光标对象，您可以用它来检索每一行。

[***清单 25-12***](#_list12) 。Android SQLite API 读取记录

```java
// File reference in project: BookPSSQLite.Java
public List<Book> getAllBooks()   {
   //Get access to a read database
   SQLiteDatabase db = DirectAccessBookDBHelper.m_self.getReadableDatabase();

   String tname = BookSQLiteSQLiteMetaData.TABLE_NAME;
   //Get column name array from the metadata class
   //(See the download how the column names are gathered)
   //(at the end of the day it is just a set of column names
   String[] colnames = BookSQLiteSQLiteMetaData.s_self.getColumnNames();

   //Selection
   String selection = null;       //all rows. Usually a where clause. exclude where part
   String[] selectionArgs = null; //use ?s if you need it

   String groupBy = null;     //sql group by clause: exclude group by part
   String having = null;      //similar
   String orderby = null;
   String limitClause = null; //max number of rows
   //db.query(tname, colnames)
   Cursor c = null;

   try {
      c = db.query(tname,colnames,selection,selectionArgs,groupBy,having,orderby,limitClause);
      //This may not be the optimal way to read data through a list
      //Directly pass the cursor back if your intent is to read these one row at a time
      List<Book> bookList = new ArrayList<Book>();
      for(c.moveToFirst();!c.isAfterLast();c.moveToNext()) {
         Log.d(tag,"There are books");
         Book b = new Book();

         //..fill base fields the same way
         b.setName(c.getString(c.getColumnIndex(BookSQLiteMetaData.NAME)));
         b.setAuthor(c.getString(c.getColumnIndex(BookSQLiteMetaData.AUTHOR)));
         b.setIsbn(c.getString(c.getColumnIndex(BookSQLiteMetaData.ISBN)));
         //..fill other fields

         //Or you could delegate this work to the BookSQLiteMetaData object
         //as we have done in the sample downloadable project
         //Ex: BookSQLiteSQLiteMetaData.s_self.fillFields(c,b);

         bookList.add(b);
      }
      return bookList;
   }
   finally {
      if (c!= null) c.close();
   }
}
```

以下是一些关于 Android 光标对象的事实:

*   游标是行的集合。
*   在读取任何数据之前，您需要使用 moveToFirst() ，因为光标从第一行之前开始定位。
*   您需要知道列名。
*   您需要知道列的类型。
*   所有的字段访问方法都是基于列号的，所以必须先将列名转换成列号。注意，这个查找可以被优化。如果您希望获取值，然后在游标上使用显式常量索引，那么按顺序填充列名数组会更有效。
*   光标是随机的(可以前后移动，可以跳跃)。
*   因为游标是随机的，所以可以向它询问行数。

应用交易

Android 上的 SQLite 库支持事务。事务方法在 SQLiteDatabase 类中可用。这些方法如[清单 25-13](#list13) 中的伪代码片段所示(完整代码参见下载项目)。

[***清单 25-13***](#_list13) 。用于事务的 SQLite API

```java
// File reference in project: DBServicesProxyHandler.Java
public void doSomeUpdates() {
  SQLiteDatabase db;  //Get a reference to this database through helper
  db.beginTransaction();
  try {
    //...call a number of database methods
    db.setTransactionSuccessful();
  }
  finally {
    db.endTransaction();
  }
}
```

总结 SQLite

如果你是一个有几年经验的 Java 程序员，我们到目前为止所介绍的内容足以理解 Android 中的 SQLite API。到目前为止，已经学习了这些内容，您知道了如何检查数据库、通过 DDL 创建数据库、插入行、更新行、删除行或使用数据库游标进行读取。我们还向您展示了事务的基本 API。然而，如果您不是 Java 方面的老手，数据库事务很难正确有效地实现。下一节将告诉您一个使用 Java 动态代理的基于 API 的模式。

通过动态代理进行交易

您可以将您的移动应用想象成两块砖的集合:一个 API 砖和一个 UI 砖。API 块将有一系列的无状态方法，为 UI 块提供逻辑和数据。在这种情况下，清单 25-13dosome updates()中的方法被 UI 的许多部分或其他 API 认为是可重用的 API。因为它是一个可重用的 API，所以客户端决定在该事务中是否应该提交某些东西。这意味着 API 大部分时间不应该处理事务。它非常像关系数据库中的存储过程。存储过程很少直接处理事务。存储过程的容器决定在存储过程外部提交或不提交。逻辑是这样的:如果存储过程被自己调用，那么它的输出将在存储过程级别提交。如果存储过程被另一个存储过程调用，提交将一直等到主调用存储过程完成。

最好在应用中对这些 API 使用相同的策略，以降低实现 API 的复杂性。这是通过拦截对所有 API 的调用来完成的，以确定这是一个直接调用还是由另一个已经被事务监视的 API 调用。有许多方法可以拦截需要拦截的 API 调用。这有时也被称为面向方面编程或 AOP。AOP 需要复杂的工具来完成。Java 通过动态代理提供了一种不太复杂但很简单的方法。动态代理是 Java 中的一种工具，基于 Java 反射，允许您在对象不知道的情况下拦截对底层对象的调用。当客户机通过这个代理调用对象时，客户机认为它是在直接与对象对话。然而，代理可以选择应用其他方面(如安全性、日志、事务等。)在发送对真实对象的调用之前。本章包含的项目提供了一个动态代理的完整实现，它可以自动应用事务方面。

我们将首先向您展示一旦动态代理就位，您的 API 实现是什么样子的。这将首先让您了解这种事务处理方法的简单性。然后你可以看看你是否想走这条路，并使用动态代理。当我们展示下面的代码时，请注意我们将只包括代码片段或示例，而不是整个代码。使用可下载的项目了解全部细节。我们对下载项目做了很多注释，以帮助您理解。考虑到这一点，请考虑使用 API 来处理基于 Book 的对象。

 。基于 API 的接口，用于处理 Book 域对象

```java
// File reference in project: IBookPS.Java
public interface IBookPS {
   public int saveBook(Book book);
   public Book getBook(int bookid);
   public void updateBook(Book book);
   public void deleteBook(int bookid);
   public List<Book> getAllBooks();
}
```

该接口使用基于 Java 的对象定义操作。 IBookPS 服务末尾的字母“PS”表示这是一本书的持久性服务 API。[清单 25-15](#list15) 显示了 IBookPS 的 SQLite 实现

[***清单 25-15***](#_list15) 。使用 SQLite 实现图书 API

```java
// File reference in project: BookPSSQLite.Java
// The missing classes in this code are in the download and not essential for
// exploring the idea.
// ASQLitePS is a class that contains reusable common methods like getting access
// to the read and write databases using the singleton database helper.
public class BookPSSQLite extends ASQLitePS implements IBookPS {
   private static String tag = "BookPSSQLite";
   @Override public int saveBook(Book book)   {
      //get the database
      //case: id does not exist in the book object
      if (book.getId() == -1)  {
         //id of the book doesn't exist so create it
         return (int)createBook(book);
      }
      //case: id exists in book object
      updateBook(book);
      return book.getId();
   }
   @Override public void deleteBook(int bookid){
      SQLiteDatabase db = getWriteDb();
      String tname = BookSQLiteSQLiteMetaData.TABLE_NAME;
      String whereClause =
         String.format("%s = %s;",
            BookSQLiteSQLiteMetaData.ID_COLNAME,
            bookid);
      String[] whereClauseargs = null;
      int i = db.delete(tname,whereClause, whereClauseargs);
      if (i != 1)  {
         throw new RuntimeException("The number of deleted books is not 1 but:" + i);
      }
   }
   private long createBook(Book book)   {
      //book doesn't exist
      //create it
      SQLiteDatabase db = getWriteDb();

      ContentValues bcv = this.getBookAsContentValuesForCreate(book);

      //I don't need to insert an empty row
      //usually any nullable column name goes here if I want to insert an empty row.
      String nullColumnNameHack = null;
      //Construct values from the Book object. SQLException is a runtime exception
      long rowId = db.insertOrThrow(BookSQLiteMetaData.TABLE_NAME, nullColumnNameHack, bcv);
      return rowId;
   }
   @Override  public void updateBook(Book book) {
      if (book.getId() < 0) {
         throw new SQLException("Book id is less than 0");
      }
      SQLiteDatabase db = getWriteDb();
      ContentValues bcv = this.getBookAsContentValuesForUpdate(book);
      String whereClause = String.format("%s = %s",BookSQLiteMetaData.ID_COLNAME,book.getId());
      whereArgs[0] = BookSQLiteMetaData.ID_COLNAME;
      whereArgs[1] = Integer.toString(book.getId());

      int count = db.update(BookSQLiteMetaData.TABLE_NAME, bcv, whereClause, null);
      if (count == 0)   {
         throw new SQLException(
               String.format("Failed to update book for book id:%s",book.getId()));
      }
   }
    private ContentValues getBookAsContentValuesForUpdate(Book book)  {
      ContentValues cv = new ContentValues();
      //Following code loads column values from book object to the cv
      //See the downloadable project for the mechanics of it
      BookSQLiteMetaData.s_self.fillUpdatableColumnValues(cv, book);
      return cv;
    }
    private ContentValues getBookAsContentValuesForCreate(Book book)  {
      ContentValues cv = new ContentValues();
      BookSQLiteMetaData.s_self.fillAllColumnValues(cv, book);
      return cv;
    }
    @Override   public List<Book> getAllBooks() {
      SQLiteDatabase db = getReadDb();
      String tname = BookSQLiteMetaData.TABLE_NAME;
      String[] colnames = BookSQLiteMetaData.s_self.getColumnNames();

      //Selection
      String selection = null; //all rows. Usually a where clause. exclude where part
      String[] selectionArgs = null; //use ?s if you need it

      String groupBy = null; //sql group by clause: exclude group by part
      String having = null; //similar
      String orderby = null;
      String limitClause = null; //max number of rows
      //db.query(tname, colnames)
      Cursor c = null;

      try {
         c = db.query(tname,colnames,selection,selectionArgs,groupBy,having,orderby,limitClause);
         //This may not be the optimal way to read data through a list
         //Directly pass the cursor back if your intent is to read these one row at a time
         List<Book> bookList = new ArrayList<Book>();
         for(c.moveToFirst();!c.isAfterLast();c.moveToNext())
         {
            Log.d(tag,"There are books");
            Book b = new Book();
            BookSQLiteMetaData.s_self.fillFields(c,b);
            bookList.add(b);
         }
         return bookList;
      }
      finally {
         if (c!= null) c.close();
      }
   }
   @Override   public Book getBook(int bookid) {
      SQLiteDatabase db = getReadDb();
      String tname = BookSQLiteMetaData.TABLE_NAME;
      String[] colnames = BookSQLiteMetaData.s_self.getColumnNames();

      //Selection
      String selection =
         String.format("%s = %s",
               BookSQLiteMetaData.ID_COLNAME,
               bookid);
      //all rows. Usually a where clause. exclude where part
      String[] selectionArgs = null; //use ?s if you need it

      String groupBy = null; //sql group by clause: exclude group by part
      String having = null; //similar
      String orderby = null;
      String limitClause = null; //max number of rows
      //db.query(tname, colnames)
      Cursor c = db.query(tname,colnames,selection,
                      selectionArgs,groupBy,having,orderby,limitClause);
      try    {
         if (c.isAfterLast()) {
            Log.d(tag,"No rows for id" + bookid);
            return null;
         }
         Book b = new Book();
         BookSQLiteMetaData.s_self.fillFields(c, b);
         return b;
      }
      finally {
         c.close();
      }
   }
}//eof-class
```

注意 Book persistence API 的实现并不直接处理这些方法的事务方面。相反，事务是由 Java 动态代理处理的，我们将很快展示这一点。[清单 25-16](#list16) 展示了客户端如何看到这些 API 并间接调用这些持久性 API(同样，请参考下载项目中的类，这些类在这段代码中被引用，但没有在这里列出，因为它们对于理解并不重要)。

[***清单 25-16***](#_list16) 。客户端对基于 API 的服务的访问

```java
// File reference in project: SQLitePersistenceTester.Java
// BaseTester is just a helper class to provider common functionality
// it implements some logging and report back methods to the UI activity
public class SQLitePersistenceTester extends BaseTester {
   private static String tag = "SQLitePersistenceTester";
   //Services is a static class that provides access to persistence services
   //Services class provides visibility to the implementer of the IBookPS
   //It demonstrates how a client gets access to the namespace of services
   //You will shortly see what this class is. Understand the intent first.
   private IBookPS bookPersistenceService = Services.PersistenceServices.bookps;
   //IReportBack is a logging interface to report loggable events back to the UI
   //UI will then choose to log those events and also show on the activity screen.
   SQLitePersistenceTester(Context ctx, IReportBack target) {
      super(ctx, target,tag);
   }

   //Add a book whose id is one larger than the books
   //in the database
   public void addBook()  {
      Book book = Book.createAMockBook();
      int bookid = bookPersistenceService.saveBook(book);
      reportString(String.format("Inserted a book %s whose generated id now is %s"
            ,book.getName()
            ,bookid));
   }
   //Delete the last book
   public void removeBook()  {
      List<Book> bookList = bookPersistenceService.getAllBooks();
      if( bookList.size() <= 0)
      {
         reportString("There are no books that can be deleted");
         return;
      }
      reportString(String.format("There are %s books. First one will be deleted", bookList.size()));

      Book b = bookList.get(0);
      bookPersistenceService.deleteBook(b.getId());
      reportString(String.format("Book with id:%s successfully deleted", b.getId()));
   }

   //write the list of books so far to the screen
   public void showBooks()  {
      List<Book> bookList = bookPersistenceService.getAllBooks();
      reportString(String.format("Number of books:%s", bookList.size()));
      for(Book b: bookList) {
         reportString(String.format("id:%s name:%s author:%s isbn:%s"
               ,b.getId()
               ,b.getName()
               ,b.getAuthor()
               ,b.getIsbn()));
      }
   }

   //Count the number of books in the database
   private int getCount()  {
      List<Book> bookList = bookPersistenceService.getAllBooks();
      return bookList.size();
   }
}
```

在[清单 25-16](#list16) 中，注意通过静态类服务访问 API 是多么简单。当然，我们还没有向您展示服务的实现，以及静态类服务持有的动态代理。[清单 25-17](#list17) 显示了静态服务类的源代码，以便让您了解这个方案是如何工作的。本章中许多(如果不是全部)列表的目的是帮助您理解。对于完整的可编译源代码，我们恳请您参考本章的可下载项目。

[***清单 25-17***](#_list17) 。通过服务名称空间向客户端公开 API

```java
// File reference in project: Services.Java
/**
 * Allow a namespace for clients to discover various services
 * Usage: Services.persistenceServices.bookps.addBook(); etc.
 * Dynamic proxy will take care of transactions.
 * Dynamic proxy will take care of mock data.
 * Dynamic Proxy will allow more than one interface
 *   to apply the above aspects.
 */
public class Services {
   public static String tag = "Services";
   public static class PersistenceServices   {
      ////se this pointer during initialization
      public static IBookPS bookps = null;
      static {
         Services.init();
      }
   }
   //Although this method is empty, calling it
   //will trigger all static initialization code for this class
   public static void init() {}
   private static Object mainProxy;
   static    {
      //A utility class to compile all database-related initializations so far
      //Gets the database helper going.
      //See the download project how it uses the concepts presented so far to do this
      Database.initialize();

      //set up bookps
      ClassLoader cl = IBookPS.class.getClassLoader();
      //Add more interfaces as available
      Class[] variousServiceInterfaces = new Class[] { IBookPS.class };

      //Create a big object that can proxy all the related interfaces
      //for which similar common aspects are applied
      //In this cases it is android SQLite transactions
      mainProxy = Proxy.newProxyInstance(cl,
               variousServiceInterfaces, new DBServicesProxyHandler());

      //Preset the namespace for easy discovery
      PersistenceServices.bookps = (IBookPS)mainProxy;
   }
}
```

注意 DBServicesProxyHandler 是如何代理实现 IBookPS 的。当被客户端调用时，DBServicesProxyHandler然后调用 IBookPS 的实际实现。 IBookPS 的实际实现如[清单 25-15](#list15) 所示。让我们转向清单 25-18 中的动态代理的实现。清单 25-18 中引用的一些代码和类只在可下载的项目中可用。然而，这不应该妨碍对动态代理体系结构的一般理解。

[***清单 25-18***](#_list18) 。Java 动态代理来包装 SQLite API 实现

```java
// File reference in project: DBServicesProxyHandler.Java
/**
 * DBServicesProxyHandler: A class to externalize SQLite Transactions.
 * It is a dynamic proxy. See Services.Java to see how a reference to this is used.
 *
 * This proxy is capable of hosting multiple persistence interfaces.
 * Each interface may represent persistence aspects of a particular entity or a domain object
 * like a Book. Or the interface can be a composite interface dealing with multiple entities.
 *
 * It also uses ThreadLocals to pass the DatabaseContext
 * DatabaseContext holds a reference to the database that is on this thread
 * It also knows how to apply transactions to that database
 * It also knows if the current thread also has a running transaction
 * @See DatabaseContext
 *
 * DatabaseContext provides the SQLiteDatabase reference to
 * the implementation classes.
 *
 * Related classes
 * ****************
 * Services.Java : Client access to interfaces
 * IBookPS: Client interface to deal with persisting a Book
 * BookPSSQLite: SQLite Implementation of IBookPS
 *
 * DBServicesProxyHandler: This class that is a dynamic proxy
 * DatabaseContext: Holds a db reference for BookPSSQLite implementation
 * DirectAccessBookDBHelper: Android DBHelper to construct the database
 *
 */
public class DBServicesProxyHandler implements InvocationHandler {
   private BookPSSQLite bookServiceImpl = new BookPSSQLite();
   private static String tag = "DBServicesProxyHandler";
   DBServicesProxyHandler(){}
   public Object invoke(Object proxy, Method method, Object[] args)
         throws Throwable {
      logMethodSignature(method);
      String mname = method.getName();
      if (mname.startsWith("get")){
         return this.invokeForReads(method, args);
      }
      else {
         return this.invokeForWrites(method, args);
      }
   }
   private void logMethodSignature(Method method){
      String interfaceName = method.getDeclaringClass().getName();
      String mname = method.getName();
      Log.d(tag,String.format("%s : %s", interfaceName, mname));
   }
   private Object callDelegatedMethod(Method method, Object[] args)
   throws Throwable{
      return method.invoke(bookServiceImpl, args);
   }
   private Object invokeForReads(Method method, Object[] args) throws Throwable {
      //See comments above about DatabaseContext
      if (DatabaseContext.isItAlreadyInsideATransaction() == true){
         //It is already bound
         return invokeForReadsWithoutATransactionalWrap(method, args);
      }
      else {
         //A new transaction
         return invokeForReadsWithATransactionalWrap(method, args);
      }

   }
   private Object invokeForReadsWithATransactionalWrap(Method method, Object[] args)
   throws Throwable {
      try   {
         DatabaseContext.setReadableDatabaseContext();
         return callDelegatedMethod(method, args);
      }
      finally   {
         DatabaseContext.reset();
      }
   }
   private Object invokeForReadsWithoutATransactionalWrap(Method method, Object[] args)
   throws Throwable {
      return callDelegatedMethod(method, args);
   }
   private Object invokeForWrites(Method method, Object[] args) throws Throwable   {
      if (DatabaseContext.isItAlreadyInsideATransaction() == true) {
         //It is already bound
         return invokeForWritesWithoutATransactionalWrap(method, args);
      }
      else   {
         //A new transaction
         return invokeForWritesWithATransactionalWrap(method, args);
      }
   }
   private Object invokeForWritesWithATransactionalWrap(Method method, Object[] args)
   throws Throwable   {
      try   {
         DatabaseContext.setWritableDatabaseContext();
         DatabaseContext.beginTransaction();
         Object rtnObject = callDelegatedMethod(method, args);
         DatabaseContext.setTransactionSuccessful();
         return rtnObject;
      }
      finally   {
         try {
            DatabaseContext.endTransaction();
         }
         finally {
            DatabaseContext.reset();
         }
      }
   }
   private Object invokeForWritesWithoutATransactionalWrap(Method method, Object[] args)
   throws Throwable   {
      return callDelegatedMethod(method, args);
   }
}//eof-class
```

清单 25-18 中的代码是动态代理实现。我们没有包括所有的细节，但是这里有足够的细节来理解这个动态代理如何以自动化的面向方面的方式执行事务。它通过反射检查被调用的方法名，看方法名是否以“get”开头，如果是，那么它假设方法不需要事务上下文。否则，它将当前线程标记为事务上下文。在方法返回时，它成功完成事务。如果在它们之间调用了其他方法，动态代理从线程中知道有一个事务在适当的位置，因此从事务的角度来看忽略了那个方法。

现在，根据你的需要，你可能想根据注解或者接口的其他方面来改变这个协议，但是你明白了。这种将 API 从 UI 中分离出来的方法是很好的设计，您可以使用任意数量的持久性存储，而无需更改您的客户端 UI 代码。我们强烈建议您采用这种方法，而不管您使用的持久性机制，包括 O/R 映射工具。

浏览模拟器和可用设备上的数据库

当您直接或通过内容提供者(下一节)使用 SQLite 作为持久性机制时，您可能希望在设备上检查生成的数据库文件，以便进行调试。

SQLite API 创建的数据库文件保存在以下目录中:

/data/data/<fully-qualified-package-name>/数据库</fully-qualified-package-name>

您可以使用 Eclipse Android file explorer 来定位目录并将文件复制到您的本地驱动器，并直接使用 SQLite 提供的本地 SQLite 工具来查看和操作该数据库。

您还可以使用 Android 和 SQLite 提供的工具来检查这些数据库。这些工具中有许多位于\<Android-SDK-install-directory>\ tools子目录中；其他的在 \ <安卓-SDK-安装-目录>\平台-工具。

这些目录中一些有用的命令是

```java
android list avd: To see a list of AVDs or emulators
emulator.exe @avdname: To start an emulator with a given name
adb.exe devices: To see the devices or emulators
adb shell: To open a shell on the emulator or device
```

您可以从“adb shell”中使用以下命令这些可以在模拟器上运行，但是在真实设备上你需要 root 访问权限。

```java
ls /system/bin : To see available commands
ls -l /: Root level directories
ls /data/data/com.android.providers.contacts/databases: an example
ls -R /data/data/*/databases: To see all databases on the device or emulator
```

如果在附带的 Android Unix shell 中有一个 find 命令，你可以查看所有的 *。db 文件。但是仅仅用 ls 是没有好办法做到这一点的。你能做的最接近的事情是:

```java
ls -R /data/data/*/databases
```

使用这个命令，您会注意到 Android 发行版具有清单 25-19 中所示的数据库(根据您的版本，这个列表可能会有所不同):

[***清单 25-19***](#_list19) 。几个示例数据库

```java
alarms.db
contacts.db
downloads.db
internal.db
settings.db
mmssms.db
telephony.db
```

您可以在 adb shell 中调用这些数据库中的一个数据库上的 sqlite3 ,方法是键入以下命令:

```java
sqlite3 /data/data/com.android.providers.contacts/databases/contacts.db
```

您可以通过键入以下命令退出 sqlite3 :

```java
sqlite>.exit
```

注意 adb 的提示是 # ， sqlite3 的提示是 sqlite > 。这些提示可能因设备而异。你可以通过访问[www.sqlite.org/sqlite.html](http://www.sqlite.org/sqlite.html)来了解各种 sqlite3 命令。但是，我们将在这里列出一些重要的命令，这样您就不必去访问 Web 了。您可以通过键入以下命令来查看表格列表

```java
sqlite> .tables
```

该命令是查询 sqlite_master 表的快捷方式，如[清单 25-20](#list20) 所示(结果输出的格式和结构可能有所不同)。

[***清单 25-20***](#_list20) 。使用 SQLite sqlite_master 表

```java
SELECT name FROM sqlite_master
WHERE type IN ('table','view') AND name NOT LIKE 'sqlite_%'
UNION ALL
SELECT name FROM sqlite_temp_master
WHERE type IN ('table','view')
ORDER BY 1
```

表 sqlite_master 是一个主表，它跟踪 sqlite 数据库中的表和视图。下面的命令行为 contacts.db 中的一个名为 people 的表显示一个 create 语句(假设这个数据库存在于您的设备上):

```java
.schema people
```

这是在 SQLite 中获取表的列名的一种方法。这也将显示列数据类型。使用内容提供商时，您应该注意这些列类型，因为访问方法依赖于它们。还要注意，这可能不是查看这些数据库的实用方法，因为您可能无法在真实设备上访问它们。在这种情况下，您必须依赖内容提供商提供的文档。

您可以在操作系统命令提示符下发出以下命令，将 contacts.db 文件下载到本地文件系统:

```java
adb pull /data/data/com.android.providers.contacts/databases/contacts.db É
c:/somelocaldir/contacts.db
```

清单 25-21 中的示例 SQL 语句可以帮助您快速浏览 SQLite 数据库(或者您可以使用任何第三方 SQLite 浏览器工具):

[***清单 25-21***](#_list21) 。SQLite 的示例 SQL 代码

```java
--Set the column headers to show in the tool
sqlite>.headers on

--select all rows from a table
select * from table1;

--count the number of rows in a table
select count(*) from table1;

--select a specific set of columns
select col1, col2 from table1;

--Select distinct values in a column
select distinct col1 from table1;

--counting the distinct values
select count(col1) from (select distinct col1 from table1);

--group by
select count(*), col1 from table1 group by col1;

--regular inner join
select * from table1 t1, table2 t2
where t1.col1 = t2.col1;

--left outer join
--Give me everything in t1 even though there are no rows in t2
select * from table t1 left outer join table2 t2
on t1.col1 = t2.col1
where ....
```

探索内容提供商

在本章的前面，我们谈到了内容提供者在应用之间共享数据。如上所述，内容提供者是数据存储的包装者。数据存储可以是本地的或远程的。数据存储通常是本地设备上的 SQLite 数据库。

要从内容提供者检索数据或将数据保存到内容提供者，您将使用一组类似 REST 的 URIs。例如，如果您要从一个内容提供商那里检索一套图书，该内容提供商是图书数据库的封装，您可能需要使用如下的 URI:

```java
content://com.android.book.BookProvider/books
```

要从图书数据库中检索特定的图书(比如说图书 23)，您可以使用如下的 URI:

```java
content://com.android.book.BookProvider/books/23
```

在本章中，您将看到这些 URIs 如何转化为底层的数据库访问机制。在设备上具有适当访问权限的任何应用都可以利用这些 URIs 来访问和操作数据。

探索 Android 的内置提供商

Android 带有许多内置的内容提供者，这些内容提供者记录在 SDK 的 android.provider Java 包中。您可以在此处查看这些提供商的列表:

```java
[http://developer.android.com/reference/android/provider/package-summary.html](http://developer.android.com/reference/android/provider/package-summary.html)
```

提供商包括例如联系人和媒体商店。这些 SQLite 数据库通常有一个扩展名。db 和只能从实现包中访问。该包之外的任何访问都必须通过内容提供者接口。您可以使用上一节“浏览模拟器和可用设备上的数据库”来浏览模拟器上内置提供程序创建的数据库文件。在真实的设备上，这是不可行的，除非您在设备上有 root 访问权限。

了解内容提供商 URIs 的结构

设备上的每个内容提供者都在 Android manifest 文件中注册，就像一个网站，带有一个名为 authority(类似于域名)的字符串标识符。清单 25-22 有两个注册的例子:

[***清单 25-22***](#_list22) 。注册提供商的示例

```java
<!-- File reference in project: AndroidManifest.xml -->
<provider android:name="SomeProviderJavaClass"
        android:authorities="com.your-company.SomeProvider" />

<provider android:name="BookProvider"
   android:authorities="com.androidbook.provider.BookProvider"
/>
```

唯一的授权字符串形成了该内容提供商提供的一组 URIs 的基础。Android 内容 URI 具有以下结构:

```java
content://<authority-name>/<path-segment1>/<path-segment2>/etc...
```

下面是一个 URI 的例子，它在图书数据库中找到一本编号为 23 的书:

```java
content:// com.androidbook.provider.BookProvider/books/23
```

在内容:之后，URI 包含授权，用于在提供者注册中心定位提供者。在前面的例子中，com . Android book . provider . book provider是 URI 的权威部分。

/books/23 是特定于每个提供者的 URI 的路径部分。书和 23 部分的路段称为路段。记录和解释 URIs 的路段和路段是提供商的责任。因此，内容提供商提供这些类似 REST 的 URL 来检索或操作数据。对于前面的注册，在图书数据库中标识目录或图书集合的 URI 是

```java
content:// com.androidbook.provider.BookProvider/books
```

URI 确定的一个具体注意事项是

```java
content:// com.androidbook.provider.BookProvider/books/#
```

其中 # 是特定音符的 id 。[清单 25-23](#list23) 显示了一些 Android 上的数据提供商接受的 URIs 的其他例子:

[***清单 25-23***](#_list23) 。几个示例 Android 内容 URL

```java
content://media/internal/images
content://media/external/images
content://contacts/people/
content://contacts/people/23
```

请注意，这些提供者的媒体(内容://媒体)和联系人(内容://联系人)没有完全限定的授权名称。这是因为 Android 提供的提供者可能没有完全合格的授权名称。

给定这些内容 URIs，提供者需要检索 URIs 表示的行。还期望提供者使用任何状态改变方法在这个 URI 改变内容:插入、更新或删除。

实施内容提供商

让我们通过实现和使用一个来充分理解内容提供者。要编写一个内容提供者，你得扩展Android . content . content provider并实现以下关键方法: query() 、 insert() 、 update() 、 delete() 、 getType() 。

您需要设置一些东西来实现这些方法。实现内容提供者需要以下步骤:

1.  规划数据库、URIs、列名等，并创建一个元数据类，为所有这些元数据元素定义常量。
2.  扩展抽象类 ContentProvider。
3.  实现这些方法:查询、插入、更新、删除和获取类型。
4.  在清单文件中注册提供程序。
5.  使用内容提供商。

规划数据库

为了探究这个主题，我们将创建一个数据库，它类似于我们在图书收藏中使用的数据库，用于直接演示在 SQLite 中存储数据。请注意，为了防止数据库相互冲突，一些名称可能会不同。

图书数据库只包含一个名为图书的表，它的列是名称、 isbn 和作者。这些列名属于元数据。您将在 Java 类中定义这种相关的元数据。这个承载元数据的 Java 类 BookProviderMetaData 如[清单 25-24](#list24) 所示。

[***清单 25-24***](#_list24) 。为数据库定义元数据

```java
// File reference in project: BookProviderMetaData.Java
public class BookProviderMetaData {
    public static final String AUTHORITY = "com.androidbook.provider.BookProvider";

    public static final String DATABASE_NAME = "book.db";
    public static final int DATABASE_VERSION = 1;
    public static final String BOOKS_TABLE_NAME = "books";

    private BookProviderMetaData() {}

    //inner class describing BookTable
    public static final class BookTableMetaData implements BaseColumns  {
        private BookTableMetaData() {}
        public static final String TABLE_NAME = "books";

        //uri and MIME type definitions
        public static final Uri CONTENT_URI =
                          Uri.parse("content://" + AUTHORITY + "/books");
        public static final String CONTENT_TYPE =
                         "vnd.android.cursor.dir/vnd.androidbook.book";
        public static final String CONTENT_ITEM_TYPE =
                        "vnd.android.cursor.item/vnd.androidbook.book";

        public static final String DEFAULT_SORT_ORDER = "modified DESC";

        //Additional Columns start here.
        //string type
        public static final String BOOK_NAME = "name";
        //string type
        public static final String BOOK_ISBN = "isbn";
        //string type
        public static final String BOOK_AUTHOR = "author";
        //Integer from System.currentTimeMillis()
        public static final String CREATED_DATE = "created";
        //Integer from System.currentTimeMillis()
        public static final String MODIFIED_DATE = "modified";
    }
}
```

这个 BookProviderMetaData 类首先将其权限定义为com . androidbook . provider . book provider。

然后，这个类继续将其一个表( books )定义为内部的 BookTableMetaData 类。然后， BookTableMetaData 类定义了一个 URI 来标识图书集合。给定上一段中的权限，URI 的藏书将是这样的:

```java
content://com.androidbook.provider.BookProvider/books
```

这个 URI 由常数表示

```java
BookProviderMetaData.BookTableMetaData.CONTENT_URI
```

然后, BookTableMetaData 类继续为一组书籍和一本书籍定义 MIME 类型。提供者实现将使用这些常量来返回传入 URIs 的 MIME 类型。MIME 类型类似于 HTTP 定义的 MIME 类型。作为指南，通过 Android 光标返回的项目集合的主要 MIME 类型应该始终是 vnd.android.cursor.dir ，通过 Android 光标检索的单个项目的主要 MIME 类型应该是 vnd.android.cursor.item 。当涉及到子类型时，您有更多的回旋余地，如清单 25-24 中的 vnd.androidbook.book 。

BookTableMetaData 然后定义图书表的列集合:名称， isbn ，作者，创建(创建日期)，以及修改(最后更新日期)。

元数据类 BookTableMetaData 也继承了提供标准 _id 字段的 BaseColumns 类，该字段表示行 id。有了这些元数据定义，我们就可以开始处理提供者实现了。

扩展 ContentProvider

实现 BookProvider 包括扩展 ContentProvider 类并覆盖 onCreate() 来创建数据库，然后实现查询、插入、更新、删除和获取类型方法。

查询方法需要它需要返回的一组列。这类似于一个 select 子句，该子句需要列名及其对应的作为(有时称为同义词)。按照惯例，Android SDK 使用一个称为投影映射的映射对象来表示这些列名及其同义词。我们将需要设置这个映射，以便稍后在查询方法实现中使用它。在提供者实现的代码中(见[清单 25-26](#list26) ，你会看到这是作为投影贴图设置的一部分提前完成的。

我们将为内容提供商契约实现的大多数方法都将 URI 作为输入。[清单 25-25](#list25) 显示了图书供应商 URI 的例子:

[***清单 25-25***](#_list25) 。图书提供商内容 URIs 示例

```java
Uri1: content://com.androidbook.provider.BookProvider/books
Uri2: content://com.androidbook.provider.BookProvider/books/12
```

图书供应商需要区分这些 URIs 中的每一个。 BookProvider 是一个简单的案例。如果我们的图书供应商除了图书之外还存放了更多的对象，那么就会有更多的 URIs 来识别这些额外的对象。

提供者实现需要一种机制来区分 fromAndroid 为此使用了一个名为 UriMatcher 的类。所以我们需要用所有的 URI 变体来设置这个对象。在我们定义了投影图之后，你会在[清单 25-26](#list26) 中看到这段代码。我们将在“使用 UriMatcher 计算 URIs”一节中进一步解释 UriMatcher 类

清单 25-26 中的代码覆盖了 onCreate() 方法以方便数据库的创建。数据库的创建与我们在直接使用 SQLite 来满足内部持久性需求的过程中介绍的数据库创建是相同的。

[清单 25-26](#list26) 中的源代码实现了 insert() 、 query() 、 update() 、 getType() 和 delete() 方法。所有这些的代码都在清单 25-26 中给出，但是我们将在单独的小节中解释每个方面。

[***清单 25-26***](#_list26) 。实现 BookProvider 内容提供者

```java
// File reference in project: BookProvider.Java
public class BookProvider extends ContentProvider
{
    //Logging helper tag. No significance to providers.
    private static final String TAG = "BookProvider";

    //Setup projection Map
    //Projection maps are similar to "as" (column alias) construct
    //in an sql statement where by you can rename the
    //columns.
    private static HashMap<String, String> sBooksProjectionMap;
    static
    {
        sBooksProjectionMap = new HashMap<String, String>();
        sBooksProjectionMap.put(BookTableMetaData._ID,
                                BookTableMetaData._ID);

        //name, isbn, author
        sBooksProjectionMap.put(BookTableMetaData.BOOK_NAME,
                                BookTableMetaData.BOOK_NAME);
        sBooksProjectionMap.put(BookTableMetaData.BOOK_ISBN,
                                BookTableMetaData.BOOK_ISBN);
        sBooksProjectionMap.put(BookTableMetaData.BOOK_AUTHOR,
                                BookTableMetaData.BOOK_AUTHOR);

        //created date, modified date
        sBooksProjectionMap.put(BookTableMetaData.CREATED_DATE,
                                BookTableMetaData.CREATED_DATE);
        sBooksProjectionMap.put(BookTableMetaData.MODIFIED_DATE,
                                BookTableMetaData.MODIFIED_DATE);
    }

    //Provide a mechanism to identify all the incoming uri patterns.
    private static final UriMatcher sUriMatcher;
    private static final int INCOMING_BOOK_COLLECTION_URI_INDICATOR = 1;
    private static final int INCOMING_SINGLE_BOOK_URI_INDICATOR = 2;
    static {
        sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
        sUriMatcher.addURI(BookProviderMetaData.AUTHORITY, "books",
                          INCOMING_BOOK_COLLECTION_URI_INDICATOR);
        sUriMatcher.addURI(BookProviderMetaData.AUTHORITY, "books/#",
                          INCOMING_SINGLE_BOOK_URI_INDICATOR);

    }
    // Setup/Create Database to use for the implementation
    private static class DatabaseHelper extends SQLiteOpenHelper {
        DatabaseHelper(Context context) {
            super(context,
                BookProviderMetaData.DATABASE_NAME,
                null,
                BookProviderMetaData.DATABASE_VERSION);
        }
        @Override
        public void onCreate(SQLiteDatabase db)     {
            Log.d(TAG,"inner oncreate called");
            db.execSQL("CREATE TABLE " + BookTableMetaData.TABLE_NAME + " ("
                    + BookTableMetaData._ID + " INTEGER PRIMARY KEY,"
                    + BookTableMetaData.BOOK_NAME + " TEXT,"
                    + BookTableMetaData.BOOK_ISBN + " TEXT,"
                    + BookTableMetaData.BOOK_AUTHOR + " TEXT,"
                    + BookTableMetaData.CREATED_DATE + " INTEGER,"
                    + BookTableMetaData.MODIFIED_DATE + " INTEGER"
                    + ");");
        }
        @Override
        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
            Log.d(TAG,"inner onupgrade called");
            Log.w(TAG, "Upgrading database from version "
                    + oldVersion + " to "
                    + newVersion + ", which will destroy all old data");
            db.execSQL("DROP TABLE IF EXISTS " +
                     BookTableMetaData.TABLE_NAME);
            onCreate(db);
        }
    }//eof-inner DatabaseHelper class
    //This is initialized in the onCreate() method
    private DatabaseHelper mOpenHelper;

    //Component creation callback
    @Override
    public boolean onCreate()   {
        Log.d(TAG,"main onCreate called");
        mOpenHelper = new DatabaseHelper(getContext());
        return true;
    }

    @Override
    public Cursor query(Uri uri, String[] projection, String selection,
            String[] selectionArgs,  String sortOrder)   {
        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();

        switch (sUriMatcher.match(uri)) {
        case INCOMING_BOOK_COLLECTION_URI_INDICATOR:
            qb.setTables(BookTableMetaData.TABLE_NAME);
            qb.setProjectionMap(sBooksProjectionMap);
            break;

        case INCOMING_SINGLE_BOOK_URI_INDICATOR:
            qb.setTables(BookTableMetaData.TABLE_NAME);
            qb.setProjectionMap(sBooksProjectionMap);
            qb.appendWhere(BookTableMetaData._ID + "="
                        + uri.getPathSegments().get(1));
            break;

        default:
            throw new IllegalArgumentException("Unknown URI " + uri);
        }

        // If no sort order is specified use the default
        String orderBy;
        if (TextUtils.isEmpty(sortOrder)) {
            orderBy = BookTableMetaData.DEFAULT_SORT_ORDER;
        } else {
            orderBy = sortOrder;
        }

        // Get the database and run the query
        SQLiteDatabase db = mOpenHelper.getReadableDatabase();
        Cursor c = qb.query(db, projection, selection,
                   selectionArgs, null, null, orderBy);

        //example of getting a count
        int i = c.getCount();

        // Tell the cursor what uri to watch,
        // so it knows when its source data changes
        c.setNotificationUri(getContext().getContentResolver(), uri);
        return c;
    }
    @Override
    public String getType(Uri uri)    {
        switch (sUriMatcher.match(uri)) {
        case INCOMING_BOOK_COLLECTION_URI_INDICATOR:
            return BookTableMetaData.CONTENT_TYPE;
        case INCOMING_SINGLE_BOOK_URI_INDICATOR:
            return BookTableMetaData.CONTENT_ITEM_TYPE;
        default:
            throw new IllegalArgumentException("Unknown URI " + uri);
        }
    }
    @Override
    public Uri insert(Uri uri, ContentValues initialValues)  {
        // Validate the requested uri
        if (sUriMatcher.match(uri)
                != INCOMING_BOOK_COLLECTION_URI_INDICATOR) {
            throw new IllegalArgumentException("Unknown URI " + uri);
        }
        ContentValues values;
        if (initialValues != null) {
            values = new ContentValues(initialValues);
        } else {
            values = new ContentValues();
        }
        Long now = Long.valueOf(System.currentTimeMillis());
        // Make sure that the fields are all set
        if (values.containsKey(BookTableMetaData.CREATED_DATE) == false){
            values.put(BookTableMetaData.CREATED_DATE, now);
        }
        if (values.containsKey(BookTableMetaData.MODIFIED_DATE) == false) {
            values.put(BookTableMetaData.MODIFIED_DATE, now);
        }
        if (values.containsKey(BookTableMetaData.BOOK_NAME) == false) {
            throw new SQLException(
               "Failed to insert row because Book Name is needed " + uri);
        }
        if (values.containsKey(BookTableMetaData.BOOK_ISBN) == false) {
            values.put(BookTableMetaData.BOOK_ISBN, "Unknown ISBN");
        }
        if (values.containsKey(BookTableMetaData.BOOK_AUTHOR) == false) {
            values.put(BookTableMetaData.BOOK_ISBN, "Unknown Author");
        }

        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
        long rowId = db.insert(BookTableMetaData.TABLE_NAME,
                BookTableMetaData.BOOK_NAME, values);
        if (rowId > 0) {
            Uri insertedBookUri =
                ContentUris.withAppendedId(
                        BookTableMetaData.CONTENT_URI, rowId);
            getContext()
               .getContentResolver()
                    .notifyChange(insertedBookUri, null);

            return insertedBookUri;
        }
        throw new SQLException("Failed to insert row into " + uri);
    }
    @Override
    public int delete(Uri uri, String where, String[] whereArgs) {
        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
        int count;
        switch (sUriMatcher.match(uri)) {
        case INCOMING_BOOK_COLLECTION_URI_INDICATOR:
            count = db.delete(BookTableMetaData.TABLE_NAME,
                    where, whereArgs);
            break;
        case INCOMING_SINGLE_BOOK_URI_INDICATOR:
            String rowId = uri.getPathSegments().get(1);
            count = db.delete(BookTableMetaData.TABLE_NAME,
                    BookTableMetaData._ID + "=" + rowId
                    + (!TextUtils.isEmpty(where) ? " AND (" + where + ')' : ""),
                    whereArgs);
            break;
        default:
            throw new IllegalArgumentException("Unknown URI " + uri);
        }

        getContext().getContentResolver().notifyChange(uri, null);
        return count;
    }
    @Override
    public int update(Uri uri, ContentValues values,
            String where, String[] whereArgs)  {
        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
        int count;
        switch (sUriMatcher.match(uri)) {
        case INCOMING_BOOK_COLLECTION_URI_INDICATOR:
            count = db.update(BookTableMetaData.TABLE_NAME,
                    values, where, whereArgs);
            break;

        case INCOMING_SINGLE_BOOK_URI_INDICATOR:
            String rowId = uri.getPathSegments().get(1);
            count = db.update(BookTableMetaData.TABLE_NAME,
                    values, BookTableMetaData._ID + "=" + rowId
                    + (!TextUtils.isEmpty(where) ? " AND (" + where + ')' : ""),
                    whereArgs);
            break;

        default:
            throw new IllegalArgumentException("Unknown URI " + uri);
        }

        getContext().getContentResolver().notifyChange(uri, null);
        return count;
    }
}
```

现在，让我们一段一段地分析这段代码。

使用 UriMatcher 计算出 URIs

我们已经多次提到了 UriMatcher 类；让我们调查一下。内容提供者中的几乎所有方法相对于 URI 都是重载的。例如，无论您想要检索单本书还是一系列书，都会调用相同的 query() 方法。由方法决定是否知道正在请求哪种类型的 URI。Android 的 UriMatcher 实用程序类帮助你识别 URI 类型。

它是这样工作的。您告诉一个 UriMatcher 的实例，在它的初始化过程中会出现什么样的 URI 模式。您还将为每个模式关联一个唯一的编号。一旦这些模式被注册，您就可以询问 UriMatcher 传入的 URI 是否匹配某个模式。

正如我们提到的，我们的book providercontent provider 有两种 URI 模式:一种针对一系列书籍，另一种针对单本书籍。[清单 25-26](#list26) 中的代码使用 UriMatcher 注册了这两种模式。它为图书集分配 1 ，为单本书分配2(URI 模式本身在图书表的元数据中定义)。您可以在清单 25-26 中的变量 sUriMatcher 的静态初始化中看到这一点。然后，您可以看到 UriMatcher 如何在 query() 方法实现中发挥作用，使用常数区分每种类型 URI 的 URIs。

使用投影地图

内容提供者就像数据库中抽象列集和真实列集之间的中介，但是这些列集可能不同。在构造查询时，您必须在客户端指定的 where 子句列和实际的数据库列之间进行映射。您在 SQLiteQueryBuilder 类的帮助下建立了这个投影地图。您可以看到这个投影映射变量 sBooksProjectionMap 是如何为清单 25-26 中的 BookProvider 设置的。您还可以在清单中看到这个变量 sBooksProjectionMap 如何被 SQLite QueryBuilder 对象使用。

履行模拟合同

让我们从[清单 25-26](#list26) 中的 getType () 方法开始。此方法返回给定 URI 的 MIME 类型。像内容提供商的许多其他方法一样，这种方法对输入的 URI 很敏感。因此， getType() 方法的首要职责就是区分 URI 的类型。是藏书还是单本？代码使用了 UriMatcher 来破译这种 URI 类型。根据这个 URI， BookTableMetaData 类定义了为每个 URI 返回的 MIME 类型常量。

实现查询方法

像其他方法一样，查询方法使用 UriMatcher 来识别 URI 类型。如果 URI 类型是单项类型，该方法通过查看由 getPathSegments() 返回的第一个段，从传入的 URI 中检索图书 ID。

然后，查询方法使用我们在[清单 25-26](#list26) 中预先创建的投影来标识返回列。最后，查询将光标返回给调用者。在整个过程中，查询方法使用 SQLiteQueryBuilder 对象来制定和执行查询。

读取数据时，可以使用 URI 或通过作为输入传递给查询方法的显式 where 子句参数来约束返回的行。在[清单 25-26](#list26) 的 BookProvider 实现中，我们使用了使用 URI 段检索图书 ID 的方法来返回该书的值。

相反，您可以使用 query() 方法的 selection 参数和 selectionArgs 参数来显式传递 where 子句参数。这些参数的工作方式就像[清单 25-12](#list12) 中的 SQLiteDatabase.query() 参数，其中“？”用作在 selectionArgs 数组中传递的值的占位符。

实现插入方法

内容提供者中的 insert 方法负责将记录插入底层数据库，然后返回指向新创建记录的 URI。

像其他方法一样， insert 使用 UriMatcher 来识别 URI 类型。代码首先检查 URI 是否指示正确的集合类型 URI。否则，代码会抛出异常。

然后，代码验证可选和强制的列参数。如果某些列缺少默认值，该代码可以替换它们。

接下来，代码使用一个 SQLiteDatabase 对象来插入新记录，并返回新插入的 ID。最后，代码使用数据库返回的 ID 构造新的 URI。

实施更新方法

内容提供者中的 update 方法负责根据传入的列值以及传入的 where 子句更新记录。然后， update 方法返回流程中更新的行数。

像其他方法一样， update 使用 UriMatcher 来识别 URI 类型。如果 URI 类型是一个集合，那么 where 子句被传递，因此它可以影响尽可能多的记录。如果 URI 类型是单记录类型，那么从 URI 中提取图书 ID，并指定为附加的 where 子句。最后，代码返回更新的记录数。还要注意这个 notifyChange 方法如何让您向全世界宣布 URI 的数据已经更改。潜在地，你可以在 insert 方法中做同样的事情，比如说 URI 的图书数据集合".../books 在插入记录时已经改变。

实现删除方法

内容提供者中的 delete 方法负责根据传入的 where 子句删除一个(或多个)记录。然后， delete 方法返回流程中删除的行数。

像其他方法一样， delete 使用 UriMatcher 来识别 URI 类型。如果 URI 类型是集合类型，那么 where 子句将被传递，这样您就可以删除尽可能多的记录。如果 where 子句为 null ，所有记录将被删除。如果 URI 类型是单记录类型，则从 URI 中提取图书 ID，并指定为附加的 where 子句。最后，代码返回删除的记录数。

注册提供商

最后，您必须在 Android 中注册内容提供商。使用清单 25-27 中的标签结构的 Manifest.xml 文件。提供者是一个组件，因此是其他组件(如活动和接收者)的兄弟。所以它是 Android 清单文件中其他活动的兄弟节点。

[***清单 25-27***](#_list27) 。注册提供商

```java
<provider android:name=".BookProvider"
   android:authorities="com.androidbook.provider.BookProvider"/>
```

行使图书供应商

现在我们有了一个图书提供者，我们将向您展示使用该提供者的示例代码。示例代码包括添加一本书、删除一本书、计算书的数量，最后显示所有的书。

请记住，这些是从示例项目中提取的代码，不会被编译，因为它们需要额外的依赖文件。但是，我们认为这个示例代码足以展示我们所探索的概念。

在本章的最后，我们包含了一个到可下载的示例项目的链接，您可以在您的 Eclipse 环境中使用它来编译和测试。

添加图书

清单 25-28 中的代码将一本新书插入图书数据库。

[***清单 25-28***](#_list28) 。练习提供者插入

```java
// File reference in project:ProviderTester.Java
public void addBook(Context context) {
    String tag = "Exercise BookProvider";
    Log.d(tag,"Adding a book");
    ContentValues cv = new ContentValues();
    cv.put(BookProviderMetaData.BookTableMetaData.BOOK_NAME, "book1");
    cv.put(BookProviderMetaData.BookTableMetaData.BOOK_ISBN, "isbn-1");
    cv.put(BookProviderMetaData.BookTableMetaData.BOOK_AUTHOR, "author-1");

    ContentResolver cr = context.getContentResolver();
    Uri uri = BookProviderMetaData.BookTableMetaData.CONTENT_URI;
    Log.d(tag,"book insert uri:" + uri);
    Uri insertedUri = cr.insert(uri, cv);
    Log.d(tag,"inserted uri:" + insertedUri);
}
```

移除一本书

清单 25-29 中的代码从图书数据库中删除最后一条记录。

[***清单 25-29***](#_list29) 。执行提供者删除

```java
// File reference in project:ProviderTester.Java
public void removeBook() {
   int firstBookId = this.getFirstBookId();
   if (firstBookId == -1) throw new SQLException("Book id is less than 0");
   ContentResolver cr = this.mContext.getContentResolver();
   Uri uri = BookProviderMetaData.BookTableMetaData.CONTENT_URI;
   Uri delUri = Uri.withAppendedPath(uri, Integer.toString(firstBookId));
   reportString("Del Uri:" + delUri);
   cr.delete(delUri, null, null);
   this.reportString("Number of Books after the delete:" + getCount());
}

private int getFirstBookId() {
   Uri uri = BookProviderMetaData.BookTableMetaData.CONTENT_URI;
   Activity a = (Activity)this.mContext;
   Cursor c = null;
   try   {
      c = a.getContentResolver().query(uri,
            null, //projection
            null, //selection string
            null, //selection args array of strings
            null); //sort order
      int numberOfRecords = c.getCount();
      if (numberOfRecords == 0) {
         return -1;
      }
      c.moveToFirst();
      int id = c.getInt(1); //id column
      return id;
   }
   finally   {
      if (c!= null) c.close();
   }
}
```

显示图书列表

清单 25-30 中的代码检索图书数据库中的所有记录。

[***清单 25-30***](#_list30) 。显示图书列表

```java
// File reference in project:ProviderTester.Java
public void showBooks() {
   Uri uri = BookProviderMetaData.BookTableMetaData.CONTENT_URI;
   Activity a = (Activity)this.mContext;
   Cursor c = null;
   try  {
      c = a.getContentResolver().query(uri,
            null, //projection
            null, //selection string
            null, //selection args array of strings
            null); //sort order
      int iid = c.getColumnIndex(BookProviderMetaData.BookTableMetaData._ID);
      int iname = c.getColumnIndex(BookProviderMetaData.BookTableMetaData.BOOK_NAME);
      int iisbn = c.getColumnIndex(BookProviderMetaData.BookTableMetaData.BOOK_ISBN);
      int iauthor = c.getColumnIndex(BookProviderMetaData.BookTableMetaData.BOOK_AUTHOR);

      //Report your indexes
      Log.d(tag, "name,isbn,author:" + iname + iisbn + iauthor);

      //walk through the rows based on indexes
      for(c.moveToFirst();!c.isAfterLast();c.moveToNext()) {
         //Gather values
         String id = c.getString(iid);
         String name = c.getString(iname);
         String isbn = c.getString(iisbn);
         String author = c.getString(iauthor);

         //Report or log the row
         StringBuffer cbuf = new StringBuffer(id);
         cbuf.append(",").append(name);
         cbuf.append(",").append(isbn);
         cbuf.append(",").append(author);
         Log.d(tag,cbuf.toString());
      }

      //Report how many rows have been read
      int numberOfRecords = c.getCount();
      Log.d(tag,"Num of Records:" + numberOfRecords);
   }
   finally   {
      if (c!= null) c.close();
   }
}
```

请注意，从内容提供商处检索图书的方法与从 SQLite 数据库中检索数据非常相似。在[清单 25-30](#list30) 中，我们使用了来自 ContentResolver 对象的 query() 方法。使用光标对象后，我们关闭了光标。

相反，如果您将这个光标对象传递给一个位于活动中的 UI 组件，那么这个光标对象需要被管理，因为活动遵循它的生命周期。在 Honeycomb 之前，在活动上有一个名为 managedQuery() 的方法来自动完成这项工作，但该方法已经被弃用，取而代之的是 CursorLoader。

当通过 managedQuery() 管理一个查询时，活动可以调用游标上的方法，将其置于适当的状态。例如，活动在停止时会调用光标上的 deactivate() ，稍后在开始时会调用 requery() 。当活动被销毁时，光标将被关闭。如果您想自己控制光标的行为，可以选择对该光标调用 stopManagingCursor() 。因为活动关闭了游标，所以不要关闭托管游标。如果您打算一次读取所有行并关闭游标，则使用 ContentResolver 的 query() 方法，而不是activity . managed query()方法并显式关闭游标。

自 Honeycomb 以来，游标读取被打包成一种更通用的方法，称为“加载器”，它允许您通过暴露给片段或活动的回调在异步线程中读取数据。这是推荐和首选的方法。我们将在下一章[关于装载机的第 26 章](26.html)中介绍这种方法。

您已经看到了我们如何在内容提供商上使用更新 API。如果通过内容提供商一个接一个地进行，这些更新操作可能是低效的。在第 27 章中，我们将介绍如何将这些单独的更新操作批量发送给内容提供商，以提高效率。

资源

以下是一些额外的 Android 资源，可以帮助您了解本章涵盖的主题:

*   [http://developer . Android . com/guide/topics/data/data-storage . html](http://developer.android.com/guide/topics/data/data-storage.html):Android 文档中的各种数据存储选项。
*   :Android 上持久化的选项总结。
*   [【http://www.androidbook.com/item/4876】](http://www.androidbook.com/item/4876):探索 Android 上直接 SQL 存储的工具和技术。这也包括对 O/R 映射工具的研究。
*   [【http://www.androidbook.com/item/4877】](http://www.androidbook.com/item/4877):通过为 Android 解析将数据存储在云端。
*   [【http://www.androidbook.com/item/4440】](http://www.androidbook.com/item/4440):使用 GSON/JSON 进行手机 app 存储。
*   :使用共享偏好进行应用状态管理。
*   [http://developer . android . com/guide/topics/providers/content-providers . html](http://developer.android.com/guide/topics/providers/content-providers.html):关于内容提供商的 Android 文档。
*   [http://developer . Android . com/reference/Android/content/content provider . html](http://developer.android.com/reference/android/content/ContentProvider.html):一个 ContentProvider 的 API 描述，在这里可以了解到 ContentProvider 合约。
*   [http://developer . Android . com/reference/Android/content/uri matcher . html](http://developer.android.com/reference/android/content/UriMatcher.html):对理解 UriMatcher 有用的信息。
*   [http://developer . Android . com/reference/Android/database/cursor . html](http://developer.android.com/reference/android/database/Cursor.html):帮助你直接从内容提供商或数据库读取数据的信息。
*   [http://developer.android.com/guide/components/loaders.html](http://developer.android.com/guide/components/loaders.html):装载机开发者指南。
*   [http://developer . Android . com/reference/Android/app/activity . html # startManagingCursor(Android . database . cursor](http://developer.android.com/reference/android/app/Activity.html#startManagingCursor(android.database.Cursor)):什么是托管光标的 API 文档。
*   :SQLite 的主页，在这里您可以了解更多关于 SQLite 的信息，并下载可以用来处理 SQLite 数据库的工具。
*   :本章的可下载测试项目可以从这个 URL 获得。zip 文件的名称是proandroid 5 _ Ch25 _ test provider . zip。

摘要

本章涵盖了应用的一个重要需求的许多方面:持久性。我们已经为您提供了 Android 中过多的持久性选项，以及如何选择合适的选项。我们已经非常详细地介绍了如何使用 SQLite 来满足内部持久性需求。我们向您展示了使用 SQLite 实现持久性的工业级 API 模式，该模式可以扩展到任何持久性实现。重要的是，该模式向您展示了如何将事务外部化，以保持您的持久性代码简单。然后，我们讨论了什么是内容提供者，内容 URIs 的本质，MIME 类型，如何使用 SQLite 来构造响应 URIs 的提供者，如何编写新的内容提供者，以及如何访问现有的内容提供者。