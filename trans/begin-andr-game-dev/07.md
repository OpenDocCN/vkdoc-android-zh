© Ted Hagos, Mario Zechner, J.F. DiMarzio and Robert Green 2020T. Hagos et al.Beginning Android Games Development[https://doi.org/10.1007/978-1-4842-6121-7_7](https://doi.org/10.1007/978-1-4842-6121-7_7)

# 7.构建气球爆炸游戏

Ted Hagos<sup>[1](#Aff5)</sup> , Mario Zechner<sup>[2](#Aff6)</sup>, J. F. DiMarzio<sup>[3](#Aff7)</sup> and Robert Green<sup>[4](#Aff8)</sup>(1)Makati, Philippines(2)Graz, Steiermark, Austria(3)Kissimmee, FL, USA(4)Portland, OR, USALet’s jump into the next game. This game will be simpler than the previous one we built, both in mechanics and technique, but this one will incorporate the use of audio and some sound effects. In this chapter, we’ll discuss the following:

*   如何在游戏中使用 ImageView 作为图形对象

*   使用值 Animator 来制作游戏对象运动的动画

*   使用 AudioManager、MediaPlayer 和 SoundPool 类为游戏添加音效和音乐

*   使用 Java 线程在后台运行

像上一章一样，我将展示构建游戏所必需的代码片段；有时，甚至会提供一些类的完整代码清单。理解和学习本章中的编程技术的最好方法是下载游戏的源代码，并在阅读本章的时候保持它在 Android Studio 中打开。如果您想继续学习并自己构建项目，最好将本章的源代码放在手边，这样您就可以根据需要复制和粘贴特定的代码片段。

<section class="Section1 RenderAsSection1" id="Sec1">

## 游戏力学

我们将让气球从屏幕底部漂浮起来，上升到顶部。玩家的目标是在气球到达屏幕顶部之前弹出尽可能多的气球。如果一个气球到达顶部而没有被弹出，这将是对用户的一点。玩家将有五条命(在这种情况下是图钉)；每当玩家错过一个气球，他们就会失去一个别针。当针用完时，游戏就结束了。

We’ll introduce the concept of levels. In each level, there will be several balloons. As the player progresses in levels, the time it takes for the balloon to float from the bottom to the top becomes less and less; the balloons float faster as the level increases. It’s that simple. Figure [7-1](#Fig1) shows a screenshot of Balloon Popper game.

<figure class="Figure" id="Fig1">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig1_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig1_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-1

流行气球

</figcaption>

</figure>

气球将从屏幕底部随机出现。

我们将把屏幕的下半部分用于游戏统计。我们将用它来显示分数和等级。在左下角，我们将放置一个按钮视图，用户可以使用它来开始游戏和开始一个新的水平。

游戏将以全屏模式进行(就像我们之前的游戏一样)，并且只在横向模式下进行。

</section>

<section class="Section1 RenderAsSection1" id="Sec2">

## 创建项目

Create a new project with an empty Activity, as shown in Figure [7-2](#Fig2).

<figure class="Figure" id="Fig2">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig2_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig2_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-2

活动为空的新项目

</figcaption>

</figure>

In the window that follows, fill out the project details, as shown in Figure [7-3](#Fig3).

<figure class="Figure" id="Fig3">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig3_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig3_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-3

创建一个新的项目

</figcaption>

</figure>

点击**完成**创建项目。

</section>

<section class="Section1 RenderAsSection1" id="Sec3">

## 绘制背景

游戏有一个背景图；你可以没有，但它增加了用户体验。当然，如果你发行一个商业游戏，你会使用一个更专业的形象。我从一个公共领域网站上抓取了这张图片；请随意使用您喜欢的任何图像。

当我得到背景图片时，我只下载了一个文件，并将其命名为“background.jpg”。我可以使用这个图片，并将其放在 **app/res/drawable** 文件夹中，然后就可以完成了。如果我这样做了，运行时将使用这个相同的图像文件作为不同显示密度的背景，并在游戏运行时尝试进行调整，这可能会导致游戏体验不稳定。因此，为不同的屏幕密度提供背景图像是非常重要的。如果你很熟悉 Photoshop 或 GIMP，你可以试着为不同的屏幕生成图像；或者，你可以只使用一张背景图像，然后使用一个名为**Android Resizer**([https://github.com/asystat/Final-Android-Resizer](https://github.com/asystat/Final-Android-Resizer))的应用程序来为你生成图像。你可以从它的 GitHub repo 下载应用程序并立即使用。这是一个可执行的 Java 归档(JAR)文件。

Once downloaded, you can open the zipped file and double-click the file **Final Android Resizer.jar** in the Executable Jar folder (shown in Figure [7-4](#Fig4)).

<figure class="Figure" id="Fig4">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig4_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig4_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-4

Android resize app

</figcaption>

</figure>

In the window that follows (Figure [7-5](#Fig5)), modify the settings of the “export” section; the various screen density targets are in the Export section. I ticked off ldpi because we don’t have to support the low-density screens. I also ticked off the tvdpi because our targets don’t include Android TVs.

<figure class="Figure" id="Fig5">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig5_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig5_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-5

Android 【调整大小】

</figcaption>

</figure>

Click the browse button of the Android Resizer to set the target folder where you would like to generate the images, as shown in Figure [7-6](#Fig6); then click **Choose**.

<figure class="Figure" id="Fig6">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig6_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig6_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-6

生成图像的目标文件夹

</figcaption>

</figure>

<figure class="Figure" id="Fig7">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig7_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig7_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-7

Android Resizer，目标目录集

</figcaption>

</figure>

目标目录(资源目录)现在应该设置好了。记住这个目录，因为您将从这里获取图像，并将它们传输到 Android 项目。在随后的窗口中(图 [7-7](#Fig7) )，您将设置目标目录。

Next, drag the image you’d like to resize in the center area of the Resizer app. As soon as you drop the image, the conversion begins. When the conversion finishes, you’ll see a message “Done! Gimme some more…”, as shown in Figure [7-8](#Fig8).

<figure class="Figure" id="Fig8">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig8_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig8_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-8

Android Resizer，完成了转换

</figcaption>

</figure>

The generated images are neatly placed in their corresponding folders, as shown in Figure [7-9](#Fig9).

<figure class="Figure" id="Fig9">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig9_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig9_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-9

生成的图像

</figcaption>

</figure>

The background image file isn’t the only thing we need to resize. We also need to do this for the balloon image. We will use a graphic image to represent the balloons in the game. The balloon file is just a grayscale image (shown in Figure [7-10](#Fig10)); we’ll add the colors in the program later.

<figure class="Figure" id="Fig10">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig10_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig10_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-10

气球的灰度图像

</figcaption>

</figure>

Drag and drop the balloon image in the Resizer app, as you did with the background file. When it’s done, the Android Resizer would have generated the files **balloons.png** and **background.jpg** in the appropriate folders (as shown in Figure [7-11](#Fig11)).

<figure class="Figure" id="Fig11">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig11_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig11_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-11

生成的文件

</figcaption>

</figure>

We can now use these images for the project. To move the images to the project, open the **app/res** folder; you can do this by using a context action; right-click **app/res**, then choose **Reveal in Finder** (if you’re on macOS); if you’re on Windows, it will be **Show in Explorer** (as shown in Figure [7-12](#Fig12)).

<figure class="Figure" id="Fig12">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig12_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig12_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-12

在取景器中显示

</figcaption>

</figure>

现在，您可以简单地将生成的图像文件夹(和文件)拖放到 **app/res/** 目录中的正确文件夹中。

Figure [7-13](#Fig13) shows an updated **app/res** directory of the project. I switched the scope of the Project tool from *Android scope* to *Project scope* to see the physical layout of the files. I usually change scopes, depending on what I need.

<figure class="Figure" id="Fig13">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig13_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig13_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-13

app/res 文件夹中有合适的图像文件

</figcaption>

</figure>

Before we draw the background image, let’s take care of the screen orientation. It’s best to play this game in landscape mode; that’s why we’ll fix the orientation to landscape. We can do this in the **AndroidManifest** file. Edit the project’s AndroidManifest to match Listing [7-1](#PC1); Figure [7-14](#Fig14) shows the location of the AndroidManifest file in the Project tool window.

<figure class="Figure" id="Fig14">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig14_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig14_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-14

AndroidManifest.xml

</figcaption>

</figure>

*<?*xml version="1.0" encoding="utf-8"*?>*<manifest xmlns:android="http://schemas.android.com/apk/res/android"package="net.workingdev.popballoons"><applicationandroid:allowBackup="true"android:icon="@mipmap/ic_launcher"android:label="@string/app_name"android:roundIcon="@mipmap/ic_launcher_round"android:supportsRtl="true"android:theme="@style/AppTheme"><activity android:name=".MainActivity"**android:configChanges="orientation|keyboardHidden|screenSize"****android:label="@string/app_name"****android:screenOrientation="landscape"****android:theme="@style/FullscreenTheme"**><intent-filter><action android:name="android.intent.action.MAIN"/><category android:name="android.intent.category.LAUNCHER" /></intent-filter></activity></application></manifest>Listing 7-1

AndroidManifest.xml

在清单文件中的 <活动> 节点的属性上可以找到负责将方向固定为横向的条目。此时，项目会有一个错误，因为**Android:theme = " style/full screen theme "**属性还不存在。我们会尽快解决这个问题。

Edit the **/app/res/styles.xml** file and add another style, as shown in Listing [7-2](#PC2).<resources><!-- Base application theme. --><style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"><!-- Customize your theme here. --><item name="colorPrimary">@color/colorPrimary</item><item name="colorPrimaryDark">@color/colorPrimaryDark</item><item name="colorAccent">@color/colorAccent</item></style>**<style name="FullscreenTheme" parent="AppTheme">****<item name="android:windowBackground">@android:color/white</item>****</style>**</resources>Listing 7-2

/app/res/styles.xml

That should fix it. Figure [7-15](#Fig15) shows the app in its current state.

<figure class="Figure" id="Fig15">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig15_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig15_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-15

PopBalloons

</figcaption>

</figure>

To load the background image from the **app/res/mipmap** folders, we will use the following code:getWindow().setBackgroundDrawableResource(R.mipmap.background);We need to call this statement in the **onCreate()** method of MainActivity, just before we call **setContentView()**. Listing [7-3](#PC4) shows our (still) minimal MainActivity.public class MainActivity extends AppCompatActivity {@Overrideprotected void onCreate(Bundle savedInstanceState) {super.onCreate(savedInstanceState);**getWindow().setBackgroundDrawableResource(R.mipmap.background);**setContentView(R.layout.activity_main);}}Listing 7-3

主活动

Now, build and run the app. You will notice that the app has a background image now (as shown in Figure [7-16](#Fig16)).

<figure class="Figure" id="Fig16">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig16_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig16_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-16

用背景图像

</figcaption>

</figure>

</section>

<section class="Section1 RenderAsSection1" id="Sec4">

## 游戏控件和大头针图标

我们将使用屏幕的底部来显示分数和级别。我们还将使用屏幕的这一部分来放置一个按钮，该按钮触发游戏和关卡的开始。

Let’s fix the **activity_main** layout file first. Currently, this layout file is set to ConstraintLayout (this is the default), but we don’t need this layout, so we’ll replace it with the RelativeLayout. We’ll set the **layout_width** and **layout_height** of this container to **match_parent** so that it expands to the available space. Listing [7-4](#PC5) shows our refactored main layout.<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"xmlns:tools="http://schemas.android.com/tools"android:layout_width="match_parent"android:layout_height="match_parent"tools:context=".MainActivity"></RelativeLayout>Listing 7-4

活动 _ 主要

Next, we will add the Button and the TextView objects, which we’ll use to start the game and to display game statistics. The idea is to nest the TextViews inside a LinearLayout container, which is oriented horizontally, and then put it side by side with a Button control; then, we’ll enclose the Button and the LinearLayout container within another RelativeLayout container. Listing [7-5](#PC6) shows the complete activity_main layout, with the game controls added.<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"xmlns:tools="http://schemas.android.com/tools"android:layout_width="match_parent"android:layout_height="match_parent"tools:context=".MainActivity">*<!-- Buttons and status displays -->*<RelativeLayoutandroid:layout_width="match_parent"android:layout_height="wrap_content"android:layout_alignParentBottom="true"android:background="@color/lightGrey">< Buttonandroid:id="@+id/go_button"style="?android:borderlessButtonStyle"android:layout_width="wrap_content"android:layout_height="wrap_content"android:layout_alignParentStart="true"android:layout_centerVertical="true"android:text="@string/play_game"android:layout_alignParentLeft="true"/><LinearLayoutandroid:id="@+id/status_display"android:layout_width="wrap_content"android:layout_height="wrap_content"android:layout_alignParentEnd="true"android:layout_centerVertical="true"android:layout_marginEnd="8dp"android:orientation="horizontal"tools:ignore="RelativeOverlap"><TextViewandroid:layout_width="wrap_content"android:layout_height="wrap_content"android:text="@string/level_label"android:textSize="20sp"android:textStyle="bold"tools:ignore="RelativeOverlap" /><TextViewandroid:id="@+id/level_display"android:layout_width="40dp"android:layout_height="wrap_content"android:layout_marginEnd="32dp"android:gravity="end"android:text="@string/maxNumber"android:textSize="20sp"android:textStyle="bold" /><TextViewandroid:id="@+id/score_label"android:layout_width="wrap_content"android:layout_height="wrap_content"android:text="@string/score_label"android:textSize="20sp"android:textStyle="bold"tools:ignore="RelativeOverlap" /><TextViewandroid:id="@+id/score_display"android:layout_width="40dp"android:layout_height="wrap_content"android:layout_marginEnd="16dp"android:gravity="end"android:text="@string/maxNumber"android:textSize="20sp"android:textStyle="bold" /></LinearLayout></RelativeLayout></RelativeLayout>Listing 7-5

activity_main.xml

我们在 **activity_main.xml** 中引用了几个字符串和颜色资源，我们需要将它们添加到 resources 文件夹中的 **strings.xml** 和 **colors.xml** 中。

Open **colors.xml**  and edit it to match Listing [7-6](#PC7).*<?*xml version="1.0" encoding="utf-8"*?>*<resources><color name="colorPrimary">#008577</color><color name="colorPrimaryDark">#00574B</color><color name="colorAccent">#D81B60</color>**<color name="lightGrey">#DDDDDD</color>****<color name="pinColor">@color/black_overlay</color>****<color name="black_overlay">#66000000</color>**</resources>Listing 7-6

app/res/values/colors.xml

Open **strings.xml** and edit it to match Listing [7-7](#PC8).<resources><string name="app_name">PopBalloons</string><string name="play_game">Play</string><string name="stop_game">Stop</string><string name="score_label">Score:</string><string name="maxNumber">999</string><string name="level_label">Level:</string><string name="wow_that_was_awesome">Wow, that was awesome</string><string name="more_levels_than_ever">More Levels than Ever!</string><string name="new_top_score">New Top Score!</string><string name="your_top_score_is">Top score: %s</string><string name="you_completed_n_levels">Levels completed: %s</string><string name="game_over">Game over!</string><string name="missed_that_one">Missed that one!</string><string name="you_finished_level_n">You finished level %s!</string><string name="popping_pin">Popping Pin</string></resources>Listing 7-7

app/RES/values/strings . XML

字符串文字存储在 strings.xml 中，以避免在我们的程序中硬编码字符串文字。这种将资源文件用于字符串文字的方法使得以后更改字符串变得更加容易——比如说，当您向非英语国家发布游戏时。

Figure [7-17](#Fig17) shows the app with game controls.

<figure class="Figure" id="Fig17">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig17_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig17_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-17

带游戏控制

</figcaption>

</figure>

接下来，让我们画大头针。你可以从谷歌的材料图标上找到图钉。这些是 SVG 图标，所以我们不必为不同的屏幕分辨率创建多个副本；它们伸缩自如。引脚的矢量定义将位于 drawable 文件夹中。我们将为引脚创建两个向量定义；一个图像代表完整的 pin(未使用的游戏寿命)，另一个图像代表断裂的 pin(使用过的游戏寿命)。

We need to create these files inside the drawable folder; we can do this with the context menu actions. Right-click the **app/res/drawable** folder of the project, as shown in Figure [7-18](#Fig18).

<figure class="Figure" id="Fig18">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig18_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig18_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-18

新的可提取资源文件

</figcaption>

</figure>

In the window that follows, type the name of the file (as shown in Figure [7-19](#Fig19)).

<figure class="Figure" id="Fig19">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig19_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig19_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-19

新的资源文件

</figcaption>

</figure>

检查**目录名**是否是“可绘制的”，然后点击 OK。简单地键入 **pin** 作为文件名；不需要添加 XML 扩展，它会由 Android Studio 自动添加。做同样的事情为**pin _ breaked**创建文件。

Edit the newly created resource files. Listings [7-8](#PC9) and [7-9](#PC10) show the code for **pin.xml**  and **pin_broken.xml**, respectively.<vector xmlns:android="http://schemas.android.com/apk/res/android"android:height="24dp"android:width="24dp"android:viewportWidth="24"android:viewportHeight="24"><path android:fillColor="#000" android:pathData="M16,12V4H17V2H7V4H8V12L6,14V16H11.2V22H12.8V16H18V14L16,12Z" /></vector>Listing 7-8

app/res/drawable/pin.xml

<vector xmlns:android="http://schemas.android.com/apk/res/android"android:height="24dp"android:width="24dp"android:viewportWidth="24"android:viewportHeight="24"><path android:fillColor="#000" android:pathData="M2,5.27L3.28,4L20,20.72L18.73,22L12.8,16.07V22H11.2V16H6V14L8,12V11.27L2,5.27M16,12L18,14V16H17.82L8,6.18V4H7V2H17V4H16V12Z" /></vector>Listing 7-9

app/RES/drawable . pin _ broken . XML

Figure [7-20](#Fig20) shows a preview of the pin in Android Studio.

<figure class="Figure" id="Fig20">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig20_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig20_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-20

大头针图像的预览

</figcaption>

</figure>

Now that we have images for the pins, we can add them to the **activity_main** layout file. We’ll place five ImageView objects at the top part of the screen, and then we will point each ImageView to the pin images we recently created. Listing [7-10](#PC11) shows a snippet of the pin definitions in XML.<ImageViewandroid:id="@+id/pushpin1"android:layout_width="40dp"android:layout_height="40dp"android:contentDescription="@string/popping_pin"android:src="@drawable/pin"android:tint="@color/pinColor" />Listing 7-10

XML 中的 Pin 定义

**android:src** 属性将 ImageView 指向我们在 drawable 文件夹中的矢量图。

Listing [7-11](#PC12) shows the full **activity_main.xml**, which contains the game controls, the pin drawings, and the FrameLayout container, which will contain all our game action.<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"xmlns:tools="http://schemas.android.com/tools"android:layout_width="match_parent"android:layout_height="match_parent"tools:context=".MainActivity"><FrameLayoutandroid:id="@+id/content_view"android:layout_width="match_parent"android:layout_height="match_parent" /><!-- Container for pin icons --><LinearLayoutandroid:layout_width="wrap_content"android:layout_height="wrap_content"android:layout_alignParentEnd="true"android:layout_alignParentTop="true"android:layout_marginEnd="16dp"android:layout_marginTop="16dp"android:orientation="horizontal"><ImageViewandroid:id="@+id/pushpin1"android:layout_width="40dp"android:layout_height="40dp"android:contentDescription="@string/popping_pin"android:src="@drawable/pin"android:tint="@color/pinColor" /><ImageViewandroid:id="@+id/pushpin2"android:layout_width="40dp"android:layout_height="40dp"android:contentDescription="@string/popping_pin"android:src="@drawable/pin"android:tint="@color/pinColor" /><ImageViewandroid:id="@+id/pushpin3"android:layout_width="40dp"android:layout_height="40dp"android:contentDescription="@string/popping_pin"android:src="@drawable/pin"android:tint="@color/pinColor" /><ImageViewandroid:id="@+id/pushpin4"android:layout_width="40dp"android:layout_height="40dp"android:contentDescription="@string/popping_pin"android:src="@drawable/pin"android:tint="@color/pinColor" /><ImageViewandroid:id="@+id/pushpin5"android:layout_width="40dp"android:layout_height="40dp"android:contentDescription="@string/popping_pin"android:src="@drawable/pin"android:tint="@color/pinColor" /></LinearLayout><!-- Buttons and game statistics --><RelativeLayoutandroid:layout_width="match_parent"android:layout_height="wrap_content"android:layout_alignParentBottom="true"android:background="@color/lightGrey">< Buttonandroid:id="n"style="?android:borderlessButtonStyle"android:layout_width="wrap_content"android:layout_height="wrap_content"android:layout_alignParentStart="true"android:layout_centerVertical="true"android:text="@string/play_game" /><LinearLayoutandroid:id="@+id/status_display"android:layout_width="wrap_content"android:layout_height="wrap_content"android:layout_alignParentEnd="true"android:layout_centerVertical="true"android:layout_marginEnd="8dp"android:orientation="horizontal"tools:ignore="RelativeOverlap"><TextViewandroid:layout_width="wrap_content"android:layout_height="wrap_content"android:text="@string/level_label"android:textSize="20sp"android:textStyle="bold"tools:ignore="RelativeOverlap" /><TextViewandroid:id="@+id/level_display"android:layout_width="40dp"android:layout_height="wrap_content"android:layout_marginEnd="32dp"android:gravity="end"android:text="@string/maxNumber"android:textSize="20sp"android:textStyle="bold" /><TextViewandroid:id="@+id/score_label"android:layout_width="wrap_content"android:layout_height="wrap_content"android:text="@string/score_label"android:textSize="20sp"android:textStyle="bold"tools:ignore="RelativeOverlap" /><TextViewandroid:id="@+id/score_display"android:layout_width="40dp"android:layout_height="wrap_content"android:layout_marginEnd="16dp"android:gravity="end"android:text="@string/maxNumber"android:textSize="20sp"android:textStyle="bold" /></LinearLayout></RelativeLayout></RelativeLayout>Listing 7-11

activity_main.xml 的完整代码

At this point, you should have something that looks like Figure [7-21](#Fig21).

<figure class="Figure" id="Fig21">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig21_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig21_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-21

带有游戏控件和 pin 码的应用程序

</figcaption>

</figure>

It’s starting to shape up, but we still need to fix that toolbar and the other widgets displayed on the top strip of the screen. We’ve already done this in the previous chapter so that this technique will be familiar. Listing [7-12](#PC13) shows the code for the **setToFullScreen()** method.private void setToFullScreen() {contentView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LOW_PROFILE| View.SYSTEM_UI_FLAG_FULLSCREEN| View.SYSTEM_UI_FLAG_LAYOUT_STABLE| View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY| View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION| View.SYSTEM_UI_FLAG_HIDE_NAVIGATION);}Listing 7-12

setToFullScreen()

启用全屏模式在 Android 开发者网站中有很好的记录；以下是更多信息的链接:[](https://developer.android.com/training/system-ui/immersive)。

Listing [7-13](#PC14) shows the annotated listing of MainActivity.import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.view.MotionEvent;import android.view.View;import android.view.ViewGroup;public class MainActivity extends AppCompatActivity {ViewGroup contentView; ❶@Overrideprotected void onCreate(Bundle savedInstanceState) {super.onCreate(savedInstanceState);getWindow().setBackgroundDrawableResource(R.mipmap.background);setContentView(R.layout.activity_main);contentView = (ViewGroup) findViewById(R.id.content_view); ❷contentView.setOnTouchListener(new View.OnTouchListener() {@Overridepublic boolean onTouch(View v, MotionEvent event) { ❸if (event.getAction() == MotionEvent.ACTION_DOWN) {setToFullScreen();}return false;}});}@Overrideprotected void onResume() {super.onResume();setToFullScreen(); ❹}private void setToFullScreen() {contentView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_OW_PROFILE| View.SYSTEM_UI_FLAG_FULLSCREEN| View.SYSTEM_UI_FLAG_LAYOUT_STABLE| View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY| View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION| View.SYSTEM_UI_FLAG_HIDE_NAVIGATION);}}Listing 7-13

带注释的主要活动

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| -好的 | 将 **contentView** 变量声明为成员；我们将在几个方法中使用它，所以我们需要它在类范围内可用。 |
| ❷ | 获取对我们之前在 **activity_main** 中定义的 FrameLayout 容器的引用。将返回值存储到**容器视图**变量中。 |
| -你好 | 全屏设置是临时的。屏幕稍后可以恢复到显示工具栏(例如，当显示对话窗口时)。我们将 **setOnTouchListener()** 绑定到 FrameLayout，以允许用户只需点击屏幕上的任意位置一次即可恢复全屏。 |
| (a) | 我们在这里调用 **onResume()** 生命周期方法中的 **setToFullScreen()** 。当所有视图对象对用户都可见时，我们希望将屏幕设置为全屏。 |

Figure [7-22](#Fig22) shows the app in fullscreen mode.

<figure class="Figure" id="Fig22">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig22_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig22_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-22

应用程序全屏屏幕

</figcaption>

</figure>

</section>

<section class="Section1 RenderAsSection1" id="Sec5">

## 画气球

这个想法是创建许多气球，它们将从屏幕的底部升到顶部。我们需要以编程方式创建气球。我们可以通过创建一个表示气球的类来做到这一点。我们将编写一些逻辑来创建 Balloon 类的实例，并使它们出现在屏幕底部的随机位置，但首先，让我们创建 Balloon 类。

Right-click the project’s package, then choose **New** ➤ **Java Class**, as shown in Figure [7-23](#Fig23).

<figure class="Figure" id="Fig23">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig23_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig23_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-23

新的 Java 类

</figcaption>

</figure>

In the window that follows, type the name of the class (Balloon) and type its superclass (AppCompatImageView), as shown in Figure [7-24](#Fig24).

<figure class="Figure" id="Fig24">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig24_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig24_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-24

创建一个新的类

</figcaption>

</figure>

Listing [7-14](#PC15) shows the code for the Balloon class.import androidx.appcompat.widget.AppCompatImageView;import android.content.Context;import android.util.TypedValue;import android.view.ViewGroup;public class Balloon extends AppCompatImageView {public Balloon(Context context) { ❶super(context);}public Balloon(Context context, int color, int height, int level ) { ❷super(context);setImageResource(R.mipmap.balloon); ❸setColorFilter(color); ❹int width = height / 2; ❺int dpHeight = pixelsToDp(height, context); ❻int dpWidth = pixelsToDp(width, context);ViewGroup.LayoutParams params =new ViewGroup.LayoutParams(dpWidth, dpHeight);setLayoutParams(params);}public static int pixelsToDp(int px, Context context) {return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, px,context.getResources().getDisplayMetrics());}}Listing 7-14

气球类

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| -好的 | 这是 AppCompatImageView 的默认构造函数。我们不去管这件事 |
| ❷ | 我们需要一个新的构造函数，一个接受游戏所需参数的函数。重载构造函数并创建一个接受气球颜色、高度和游戏级别参数的函数 |
| -你好 | 设置图像的来源。将它指向 mipmap 文件夹中的气球图像 |
| (a) | 气球图像只是单色灰色。 **setColorFilter()** 用你喜欢的任何颜色给图像上色。这就是我们要参数化颜色的原因 |
| (一) | 气球的图像文件被设置为两倍于其宽度。为了计算气球的宽度，我们用高度除以 2 |
| ❻ | 我们想计算图像的设备无关像素；因此，我们在 Balloon 类中创建了一个静态方法来完成这个任务(参见 **pixelsToDp()** 的实现) |

If you want to see this in action, you can modify the **onTouch()** listener of the contentView container in MainActivity such that, every time you touch the screen, a red balloon pops up exactly where you touched the screen. The code for that is shown in Listing [7-15](#PC16).contentView.setOnTouchListener(new View.OnTouchListener() {@Overridepublic boolean onTouch(View v, MotionEvent event) {Balloon btemp = new Balloon(MainActivity.this, 0xFFFF0000, 100, 1); ❶btemp.setY(event.getY()); ❷btemp.setX(event.getX()); ❸contentView.addView(btemp); ❹if (event.getAction() == MotionEvent.ACTION_DOWN) {setToFullScreen();}return false;}});Listing 7-15

MainActivity's 本体搜索监听器

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| -好的 | 创建 Balloon 类的实例；传递上下文、红色、任意高度和 1(对于关卡，这现在并不重要)。 |
| ❷ | 设置我们希望气球对象显示的 Y 坐标。 |
| -你好 | 设置 X 坐标。 |
| (a) | 将新的气球对象作为子对象添加到视图对象中；这很重要，因为这让我们可以看到气球。 |

At this point, every time you click the screen, a red balloon shows up. We need to mix up the colors of the balloons to make it more interesting. Let’s use at least three colors: red, green, and blue. We can look up the hex values of these colors, or we can use the Color class in Android. To get the red color, we can write something like this:Color.argb(255, 255, 0, 0);For blue and green, it would be as follows:Color.argb(255, 0, 255, 0);Color.argb(255, 0, 0, 255);A simple solution to rotate the colors is to set up an array of three elements, where each element contains a color value. Listing [7-16](#PC19) shows the partial code for this task.private int[] colors = new int[3];@Overrideprotected void onCreate(Bundle savedInstanceState) {super.onCreate(savedInstanceState);// ...colors[0] = Color.argb(255, 255, 0, 0);colors[1] = Color.argb(255, 0, 255, 0);colors[2] = Color.argb(255, 0, 0, 255);}Listing 7-16

颜色数组  (这进入主活动)

Next, we set up a method that returns a random number between 0 and 2\. We’ll make this our random selector for color. Listing [7-17](#PC20) shows this code.private static int nextColor() {int max = 2;int min = 0;int retval = 0;Random random = new Random();retval = random.nextInt((max - min) + 1) + min;return retval;}Listing 7-17

nextColor()方法

Next, we modify that part of our code in MainActivity when we create the Balloon (inside the **onTouch()** method) and assign it a color; now, we will assign it a random color. Listing [7-18](#PC21) shows that code.**int curColor = colors[nextColor()];**Balloon btemp = new Balloon(MainActivity.this, **curColor**, 100, 1);btemp.setY(event.getY());btemp.setX(event.getX());contentView.addView(btemp);Listing 7-18

分配随机颜色

Figure [7-25](#Fig25) shows the app randomizing the colors of the balloons.

<figure class="Figure" id="Fig25">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig25_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig25_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-25

随机颜色

</figcaption>

</figure>

</section>

<section class="Section1 RenderAsSection1" id="Sec6">

## 让气球漂浮起来

为了让气球从底部飘到顶部，我们将使用 Android SDK 中的内置类。当气球升到屏幕顶部时，我们不会对它的位置进行微操作。

ValueAnimator 类(**Android . animation . value animator**)本质上是一个运行动画的计时引擎。它计算动画值，然后将它们设置在目标对象上。

Since we want to animate each balloon, we’ll put the animation logic inside the Balloon class; let’s add a new method named **release()** where we will put the necessary code to make the balloon float. Listing [7-19](#PC22) shows the code.private BalloonListener listener;// some other statements ...listener = new BalloonListener(this);// some other statements ...public void release(int scrHeight, int duration) { ❶animator = new ValueAnimator(); ❷animator.setDuration(duration); ❸animator.setFloatValues(scrHeight, 0f); ❹animator.setInterpolator(new LinearInterpolator()); ❺animator.setTarget(this); ❻animator.addListener(listener);animator.addUpdateListener(listener); ❼animator.start(); ❽}Listing 7-19

气球类中的 release()方法

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| -好的 | **release()** 方法有两个参数；第一个是屏幕的高度(动画需要这个)，第二个是*时长*；我们需要这个稍后的水平。随着高度的增加，气球上升的速度越快。 |
| ❷ | 创建 Animator 对象。 |
| -你好 | 这将设置动画的持续时间。该值越高，动画越长。 |
| (a) | 这将设置浮点值，这些值将在。我们想从屏幕底部到顶部制作动画；因此，我们传递了的**和屏幕高度。** |
| (一) | 我们设置时间插值器，用于计算该动画的已用部分。插值器确定动画是以线性运动还是非线性运动运行，如加速和减速。在我们的例子中，我们想要一个线性加速度，所以我们传递了 LinearInterpolator 的一个实例。 |
| ❻ | 动画的目标是一个气球的具体实例，因此**这个**。 |
| ❼ | 动画有一个生命周期。我们可以通过添加一些监听器对象来监听这些更新。我们稍后将实现这些侦听器。 |
| ❽ | 开始播放动画。 |

Create a new class (on the same package) and name it **BalloonListener.java**; Listing [7-20](#PC23) shows the code for the BalloonListener.import android.animation.Animator;import android.animation.ValueAnimator;public class BalloonListener implements ❶Animator.AnimatorListener,ValueAnimator.AnimatorUpdateListener{Balloon balloon;public BalloonListener(Balloon balloon) {this.balloon = balloon; ❷}@Overridepublic void onAnimationUpdate(ValueAnimator valueAnimator) {balloon.setY((float) valueAnimator.getAnimatedValue()); ❸}// some other lifecycle methods ...}Listing 7-20

BalloonListener.java

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| -好的 | 我们对动画的生命周期方法感兴趣；因此，我们实现了 **Animator。动画师**和**值动画师。AnimatorUpdateListener** 。 |
| ❷ | 我们需要对气球对象的引用；因此，当创建这个侦听器对象时，我们将它作为一个参数。 |
| -你好 | 当 ValueAnimator 更新其值时，我们将气球实例的 Y 位置设置为该值。 |

In MainActivity (where we create an instance of the Balloon), we need to calculate the screen height. Listing [7-21](#PC24) shows the annotated code that will accomplish that.ViewTreeObserver viewTreeObserver = contentView.getViewTreeObserver(); ❶if (viewTreeObserver.isAlive()) { ❷viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() { ❸@Overridepublic void onGlobalLayout() {contentView.getViewTreeObserver().removeOnGlobalLayoutListener(this); ❹scrWidth = contentView.getWidth(); ❺scrHeight = contentView.getHeight();}});}Listing 7-21

计算屏幕的高度和宽度

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| -好的 | 获取 ViewTreeObserver 的实例。 |
| ❷ | 我们只能在这个观察者活着的时候和他一起工作。因此，我们将整个逻辑包装在一个 **if 语句**中。 |
| -你好 | 当视图树中视图的全局布局状态或可见性发生变化时，我们希望得到通知。 |
| (a) | 我们希望只收到一次通知；因此，一旦调用了 **onGlobalLayout()** 方法，我们就删除了监听器。 |
| (一) | 现在，我们可以得到屏幕的高度和宽度。 |

Listing [7-22](#PC25) shows MainActivity with the code to calculate the screen’s height and width.public class MainActivity extends AppCompatActivity {ViewGroup contentView;private static String TAG;private int[] colors = new int[3];private int scrWidth; ❶private int scrHeight;@Overrideprotected void onCreate(Bundle savedInstanceState) {super.onCreate(savedInstanceState);TAG = getClass().getName();// other statements ...contentView = (ViewGroup) findViewById(R.id.content_view);contentView.setOnTouchListener(new View.OnTouchListener() {@Overridepublic boolean onTouch(View v, MotionEvent event) {Log.d(TAG, "onTouch");int curColor = colors[nextColor()];Balloon btemp = new Balloon(MainActivity.this, curColor, 100, 1);btemp.setY(scrHeight); ❷btemp.setX(event.getX());contentView.addView(btemp);btemp.release(scrHeight, 4000); ❸Log.d(TAG, "Balloon created");if (event.getAction() == MotionEvent.ACTION_DOWN) {setToFullScreen();}return false;}});}@Overrideprotected void onResume() {super.onResume();setToFullScreen(); ❹ViewTreeObserver viewTreeObserver = contentView.getViewTreeObserver(); ❺if (viewTreeObserver.isAlive()) {viewTreeObserver.addOnGlobalLayoutListener(newViewTreeObserver.OnGlobalLayoutListener() {@Overridepublic void onGlobalLayout() {contentView.getViewTreeObserver().removeOnGlobalLayoutListener(this);scrWidth = contentView.getWidth();scrHeight = contentView.getHeight();}});}}}Listing 7-22

主要活动

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| -好的 | 创建成员变量**scrh height**和**scrw width**。 |
| ❷ | 更改气球实例的 Y 坐标值。让我们从屏幕底部的气球的 Y 位置开始，而不是显示发生点击的气球的 Y 位置。 |
| -你好 | 调用气球的 **release()** 方法。我们打这个电话的时候应该已经计算出屏幕高度了。第二个参数现在是硬编码的(持续时间)，这意味着气球需要大约 4 秒钟才能升到屏幕顶部。 |
| (a) | 在我们计算屏幕高度和宽度之前，非常重要的是我们已经调用了**setToFullScreen()**；这样，我们就有了一组精确的尺寸。 |
| (一) | 当所有视图对象对用户都可见时，将计算屏幕高度和宽度的代码放在回调函数中；那就是 **onResume()** 方法。 |

At this point, if you run the app, a Balloon object will rise from the bottom to the top of the screen whenever you click anywhere on the screen (Figure [7-26](#Fig26)).

<figure class="Figure" id="Fig26">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig26_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig26_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-26

气球升到顶端

</figcaption>

</figure>

</section>

<section class="Section1 RenderAsSection1" id="Sec7">

## 发射气球

现在我们可以让气球一次升到顶端，我们需要弄清楚如何发射几个类似游戏关卡的气球。现在，响应用户的点击，气球出现在屏幕上；这不是我们想要的游戏方式。我们需要做一些改变。

我们想要的是玩家点击一个按钮，然后开始游戏。当按钮第一次被点击时，用户自动进入第一级。游戏的关卡并不复杂；随着高度的上升，我们将简单地增加气球的速度。

To launch the balloons, we need to do the following:

1.  1\.

    Make the button in **activity_main.xml** respond to the click event.

2.  2\.

    Create a new method in MainActivity, which will contain all the codes needed to start a level.

3.  3\.

    Write a cycle that can launch several balloons.

4.  4\.

    Randomize the X position of the balloon when creating it.

To make the Button respond to click events, we need to bind it to an OnClickListener object, as shown in Listing [7-23](#PC26).Button btn = (Button) findViewById(R.id.btn);btn.setOnClickListener(new View.OnClickListener() {@Overridepublic void onClick(View view) {// start the level// when this is clicked}});Listing 7-23

将按钮绑定到 onClickListener

The code to start a level is shown in Listing [7-24](#PC27).private void startLevel() {// we'll fill this codes later}Listing 7-24

MainActivity 中的 startLevel()

We need to refactor the code to launch a single balloon. Right now, we’re doing it inside the onTouchListener. We want to enclose this logic in a method. Listing [7-25](#PC28) shows the **launchBalloon()** method in MainActivity.public void launchBalloon(int xPos) { ❶int curColor = colors[nextColor()];Balloon btemp = new Balloon(MainActivity.this, curColor, 100, 1);btemp.setY(scrHeight);btemp.setX(xPos); ❷contentView.addView(btemp);btemp.release(scrHeight, 3000);Log.d(TAG, "Balloon created");}Listing 7-25

发射气球()

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| -好的 | 该方法采用一个 int 参数。这将是气球在屏幕上的 X 位置。 |
| ❷ | 设置气球的水平位置。 |

We want to launch the balloons in the background; you don’t want to do these things in the main UI thread because that will affect the game’s responsiveness. We don’t want the game to feel janky. So, we’ll write the looping logic in a Thread. Listing [7-26](#PC29) shows the code for this Thread class.class LevelLoop extends Thread { ❶int balloonsLaunched = 0;public void run() {while (balloonsLaunched <= 15) { ❷balloonsLaunched++;Random random = new Random(new Date().getTime());final int xPosition = random.nextInt(scrWidth - 200); ❸try {Thread.sleep(1000); ❹}catch(InterruptedException e) {Log.e(TAG, e.getMessage());}// need to wrap this on runOnUiThreadrunOnUiThread(new Thread() {public void run() {launchBalloon(xPosition); ❺}});}}}Listing 7-26

LevelLoop(在 MainActivity 中实现为内部类)

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| -好的 | LevelLoop 是 MainActivity 中的内部类。将它实现为内部类可以让我们访问外部类(MainActivity)的成员变量和方法(这很方便)。 |
| ❷ | 当我们发射 15 个气球后，循环就会停止。要发射的气球数量现在是硬编码的，但我们稍后会重构它。 |
| -你好 | 获得一个随机数来选择一个 x 捐赠气球。 |
| (a) | 我们来介绍一个延迟；如果不引入延迟，所有 15 个气球都可以同时出现并升到顶端。现在，延迟是硬编码的；我们稍后将对此进行重构。我们需要根据水平来改变这一点。对了， **Thread.sleep()** 抛出了**中断异常**；这就是为什么我们需要将它包装在一个 try-catch 块中。 |
| (一) | 最后调用外层类的 **launchBalloon()** 方法。我们需要将这个调用包装在一个 **runOnUiThread()** 方法中，因为后台进程调用 UI 元素是非法的；UI 元素在主线程(也称为 UI 线程)上呈现。如果你在后台运行时需要调用 UI 线程上的对象，你需要像我们在这里所做的那样，在一个 **runOnUiThread()** 方法上包装这个调用。 |

此时，每当你点击“播放”按钮，游戏将发射一系列 15 个气球，这些气球将升至屏幕顶部；然而，这个游戏还没有等级的概念。无论你点击多少次“播放”，气球上升的速度保持不变。让我们在下一节中解决这个问题。

</section>

<section class="Section1 RenderAsSection1" id="Sec8">

## 处理游戏关卡

To introduce levels, let’s create a member variable in MainActivity to hold the value of the levels, and every time we call the **startLevel()** method, we increment that variable by 1\. Listing [7-27](#PC30) shows the code for these changes.private int level; ❶// other statements ...@Overrideprotected void onCreate(Bundle savedInstanceState) {super.onCreate(savedInstanceState);// other statements ...levelDisplay = (TextView) findViewById(R.id.level_display); ❷scoreDisplay = (TextView) findViewById(R.id.score_display); ❸}private void startLevel() {level++; ❹new LevelLoop(level).start(); ❺levelDisplay.setText(String.format("%s", level)); ❻}Listing 7-27

准备关卡

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| -好的 | 将**级别**声明为成员变量。 |
| ❷ | 获取对显示当前级别的 TextView 对象的引用。 |
| -你好 | 当我们这样做的时候，还要获取一个对显示当前分数的 TextView 对象的引用。 |
| (a) | 每次调用 **startLevel()** 方法时，递增 **level** 变量。 |
| (一) | 让我们将 **level** 变量传递给 **LevelLoop** 对象(我们需要重构 LevelLoop 类，这样它就知道游戏级别了)。 |
| ❻ | 让我们显示当前级别。 |

Next, let’s refactor the LevelLoop class to make it sensitive to the current game level. Listing [7-28](#PC31) shows these changes.class LevelLoop extends Thread {private int shortDelay = 500; ❶private int longDelay = 1_500;private int maxDelay;private int minDelay;private int delay;private int looplevel;int balloonsLaunched = 0;public LevelLoop(int argLevel) { ❷looplevel = argLevel;}public void run() {while (balloonsLaunched < 15) {balloonsLaunched++;Random random = new Random(new Date().getTime());final int xPosition = random.nextInt(scrWidth - 200);maxDelay = Math.max(shortDelay, (longDelay - ((looplevel -1)) * 500)); ❸minDelay = maxDelay / 2;delay = random.nextInt(minDelay) + minDelay;Log.i(TAG, String.format("Thread delay = %d", delay));try {Thread.sleep(delay); ❹}catch(InterruptedException e) {Log.e(TAG, e.getMessage());}// need to wrap this on runOnUiThreadrunOnUiThread(new Thread() {public void run() {launchBalloon(xPosition);}});}}}Listing 7-28

水平环路

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| -好的 | 让我们引入变量 **longDelay** 和 **shortDelay** ，它们分别保存最长可能延迟(毫秒)和最短可能延迟的整数值。 |
| ❷ | 重构构造函数以接受级别参数。将该参数分配给成员变量 **looplevel** 。 |
| -你好 | 这一点数学计算延迟(现在受电平影响)。延迟不会低于**短延迟**也不会高于**长延迟**。 |
| (a) | 在 Thread.sleep() 方法中使用计算出的**延迟**。 |

</section>

<section class="Section1 RenderAsSection1" id="Sec9">

## 戳破气球

为了得分，玩家必须触摸气球，从而在它们到达屏幕顶部之前戳破它们。当一个气球到达屏幕顶部时，它也会弹出，但玩家不会得到一分；事实上，当这种情况发生时，玩家会失去一枚别针。

To pop a balloon, we need to set up a touch listener for the Balloon, then inform MainActivity that the player popped the balloon; we need to inform MainActivity because

1.  1\.

    In the MainActivity, we will update the score and the status of how many bottles are left.

2.  2\.

    Also in the MainActivity, we will remove the balloon from the view group, no matter how it pops up, whether the player pops it up or the balloon runs away.

To do this, we need to set up an interface between the Balloon class and MainActivity. Let’s create an interface and add it to the project. Creating an interface in Android Studio is very similar to how we create classes. Use the context menu; right-click the project’s package, then choose **New** ➤ **Java Class**, as shown in Figure [7-27](#Fig27).

<figure class="Figure" id="Fig27">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig27_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig27_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-27

新的 Java 类

</figcaption>

</figure>

In the window that follows, type the name of the interface (PopListener) and choose **Interface** as the kind (shown in Figure [7-28](#Fig28)).

<figure class="Figure" id="Fig28">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig28_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig28_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-28

新界面

</figcaption>

</figure>

The PopListener interface will only have one method (shown in Listing [7-29](#PC32)).public interface PopListener {void popBalloon(Balloon bal, boolean isTouched);}Listing 7-29

弹出式监听器接口

第一个参数( **bal** )指的是一个气球的具体实例。我们需要这个引用，因为这是我们将从视图组中移除的内容。从视图组中删除它会使它从屏幕上消失。第二个参数将告诉我们气球是否因为玩家得到它而弹出，在这种情况下，该参数将为**真**，或者它是否因为它一直到顶部而弹出，在这种情况下，该参数将为**假**。

Now we make a quick change to MainActivity, as shown in Listing [7-30](#PC33).public class MainActivity extends AppCompatActivityimplements PopListener { ❶@Overridepublic void popBalloon(Balloon bal, boolean isTouched) { ❷contentView.removeView(bal); ❸if(isTouched) {userScore++; ❹scoreDisplay.setText(String.format("%d", userScore)); ❺}}}Listing 7-30

主活动

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| -好的 | 实现弹出式列表器接口。 |
| ❷ | 实现实际的 **popBalloon()** 方法。 |
| -你好 | 这段代码删除了视图组中一个气球的特定实例。 |
| (a) | 现在我们可以增加玩家的分数。 |
| (一) | 这将显示玩家的分数。 |

Then we make adjustments on the Balloon class; Listing [7-31](#PC34) shows these changes.public class Balloon extends AppCompatImageViewimplements View.OnTouchListener { ❶private ValueAnimator animator;private BalloonListener listener;private boolean isPopped; ❷private PopListener mainactivity; ❸private final String TAG = getClass().getName();public Balloon(Context context) {super(context);}public Balloon(Context context, int color, int height, int level ) {super(context);mainactivity = (PopListener) context; ❹// other statements ...setOnTouchListener(this); ❺}// other methods ...@Overridepublic boolean onTouch(View view, MotionEvent motionEvent) {Log.d(TAG, "TOUCHED");if(!isPopped) {mainactivity.popBalloon(this, true);isPopped = true;animator.cancel();}return true;}public void pop(boolean isTouched) { ❻mainactivity.popBalloon(this, isTouched); ❼}public boolean isPopped() { ❽return isPopped;}}Listing 7-31

气球类

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| -好的 | 实现**视图。气球类上的 OnTouchListener** 。我们将使这个类成为触摸事件的监听器。 |
| ❷ | **isPopped** 变量保存任何特定气球的状态，无论是否弹出。 |
| -你好 | 创建对 MainActivity 的引用(它实现了弹出式列表器接口)。 |
| (a) | 在气球的构造函数中，将上下文对象转换为弹出式列表器，并将其分配给 **mainactivity** 变量。 |
| (一) | 为此气球实例设置 onTouchListener。 |
| ❻ | 创建一个名为 **pop()** 的实用函数。我们将它公开是因为我们稍后需要从 **BalloonListener** 类调用这个方法。 |
| ❼ | 创建一个名为 **isPopped()** 的效用函数；我们还将从 **BalloonListener** 类中调用这个方法。 |

此时，您可以玩功能有限的游戏。当你点击“播放”时，一组气球会浮到顶部；单击气球可将其从视图组中移除。当气球到达顶部时，它也会从视图组中移除。

</section>

<section class="Section1 RenderAsSection1" id="Sec10">

## 管理 pin

当一个气球离开玩家时，我们想要更新屏幕顶部的图钉图像。对于每个丢失的气球，我们希望显示一个损坏的图钉图像。我们需要更改的代码在 MainActivity 中；所以，让我们来实现这一改变。

We can start by declaring two member variables on MainActivity.

*   **number of pins = 5**；—我们布局中的引脚数量。

*   **；—每次气球飞走，我们增加这个变量。**

**Let’s also create an ArrayList to hold the pushpin images. We want to put them in an ArrayList so we can reference the pushpin images programmatically. Creating and populating the ArrayList with the pushpin images can be done with the code in Listing [7-32](#PC35). This code can be written inside the **onCreate()** method of MainActivity.**private** ArrayList<ImageView> **pinImages** = **new** ArrayList<>();**pinImages**.add((ImageView) findViewById(R.id.***pushpin1***));**pinImages**.add((ImageView) findViewById(R.id.***pushpin2***));**pinImages**.add((ImageView) findViewById(R.id.***pushpin3***));**pinImages**.add((ImageView) findViewById(R.id.***pushpin4***));**pinImages**.add((ImageView) findViewById(R.id.***pushpin5***));Listing 7-32

数组列表中的图钉图像

We’ve already got the logic to handle the missed balloons inside the **popBalloon()** method. We already know how to handle the case when the player pops the Balloon; all we need to do is add some more logic to the existing *if-else* condition. Listing [7-33](#PC36) shows us that code.public void popBalloon(Balloon bal, boolean isTouched) {contentView.removeView(bal);if(isTouched) {userScore++;scoreDisplay.setText(String.format("%d", userScore));}else { ❶pinsUsed++; ❷if (pinsUsed <= pinImages.size() ) { ❸pinImages.get(pinsUsed -1).setImageResource(R.drawable.pin_broken); ❹Toast.makeText(this, "Ouch!",Toast.LENGTH_SHORT).show(); ❺}if(pinsUsed == numberOfPins) { ❻gameOver();}}}private void gameOver() {// TODO: implement GameOver methodToast.makeText(this, "Game Over", Toast.LENGTH_LONG).show();}Listing 7-33

popBalloon()

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| -好的 | 如果**被触摸**为*假*，则意味着气球从玩家手中逃脱。 |
| ❷ | 增加**引脚使用的**变量。对于每一个丢失的气球，我们增加这个变量。 |
| -你好 | 让我们检查一下 **pinsUsed** 是否小于或等于包含图钉图像的数组列表的大小(它有五个元素)；如果这个表达式为*真*，那就意味着游戏还没有结束，玩家还有多余的图钉，我们可以继续游戏。 |
| (a) | 此代码替换图钉的图像；它将图像设置为断开的大头针的图像。 |
| (一) | 我们向玩家显示一个简单的祝酒词。祝酒词是出现在屏幕底部的一个小弹出窗口，然后从视图中消失。 |
| ❻ | 让我们检查一下玩家是否用完了所有的五个图钉。如果有，我们调用 **gameOver()** 方法，我们仍然需要实现它。 |** </section>

 **<section class="Section1 RenderAsSection1" id="Sec11">

## 当游戏结束时

When the game is over, we need to do some cleanup; at the very least, we have to reset the pushpin images—which is easy enough to do. Listing [7-34](#PC37) should accomplish that job.for (ImageView pin: pinImages) {pin.setImageResource(R.drawable.*pin*);}Listing 7-34

重置图钉图像

We also need to reset a couple of counters. To do these cleanups, let’s reorganize MainActivity a little bit. Start with implementing the **gameOver()** method, as shown in Listing [7-35](#PC38).private void gameOver() {isGameStopped = true;Toast.makeText(this, "Game Over", Toast.LENGTH_LONG).show();btn.setText("Play game");}Listing 7-35

gameOver()

我们只是向玩家敬酒，宣布游戏结束的消息。我们还重置了按钮的文本。你可能已经注意到了**是一个被终止的**变量；这是我们需要创建的另一个成员变量，以帮助我们管理一些基本的游戏状态。

Next, let’s add another method called **finishLevel()**, so we can group some actions we need to take when the player finishes a level; the code for that is in Listing [7-36](#PC39).private void finishLevel() {Log.d(TAG, "FINISH LEVEL");String message = String.format("Level %d finished!", level);Toast.makeText(this, message, Toast.LENGTH_LONG).show(); // ❶level++; ❷updateGameStats(); ❸btn.setText(String.format("Start level %d", level)); ❹Log.d(TAG, String.format("balloonsLaunched = %d", balloonsLaunched));balloonsPopped = 0; ❺}Listing 7-36

finishLevel()

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| -好的 | 告诉玩家这一关结束了。 |
| ❷ | 增加级别变量。 |
| -你好 | 我们还没有实现这个方法，但是你可以猜到它会做什么。它将简单地显示当前分数和当前级别。 |
| (a) | 将按钮的文本更改为反映下一级别的文本。 |
| (一) | 我们正在将**气球弹出的**变量重置为零。我们还需要创建这个成员变量。它会记录所有被戳破的气球。我们将用它来确定关卡是否已经完成。 |

Listing [7-37](#PC40) shows the code for the updateGameStats() method.private void updateGameStats() {levelDisplay.setText(String.format("%s", level));scoreDisplay.setText(String.format("%s", userScore));}Listing 7-37

updateGameStats()

现在，我们需要知道关卡何时完成。我们以前从未为此烦恼过，因为我们只是让 LevelLoop 线程来完成发射气球的工作，但现在我们需要管理一些游戏状态。在 MainActivity 中有几个地方我们可以发出关卡结束的信号。我们可以在 LevelLoop 线程内部实现。只要 while 循环结束，就应该表示这个级别结束了；但是如果我们把它放在那里，游戏可能会感觉不同步。当一些气球仍在播放动画时，可能会出现祝酒词。我们将调用 **popBalloon()** 方法中的 **finishLevel()** 来代替。

If we simply count the number of Balloons that gets popped—which is everything, because every balloon gets popped one way or another—compare it with the number of balloons we launch per level; when the two variables are equal, that should signal the end of the level. Listing [7-38](#PC41) shows that implementation.@Overridepublic void popBalloon(Balloon bal, boolean isTouched) {balloonsPopped++;contentView.removeView(bal);if(isTouched) {userScore++;scoreDisplay.setText(String.format("%d", userScore));}else {pinsUsed++;if (pinsUsed <= pinImages.size() ) {pinImages.get(pinsUsed -1).setImageResource(R.drawable.pin_broken);Toast.makeText(this, "Ouch!",Toast.LENGTH_SHORT).show();}if(pinsUsed == numberOfPins) {gameOver();}}**if (balloonsPopped == balloonsPerLevel) {****finishLevel();****}**}Listing 7-38

popBalloon()

Next, let’s move to the **startLevel()** method. The refactored code is shown in Listing [7-39](#PC42).private void startLevel() {if (isGameStopped) { ❶isGameStopped = false; ❷startGame(); ❸}updateGameStats(); ❹new LevelLoop(level).start();}Listing 7-39

startLevel()

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| -好的 | 让我们检查一些游戏状态。玩家第一次开始游戏时，这将是错误的。这在 **gameOver()** 方法中被重置。如果这个条件为真，就意味着我们要开始一个新游戏。 |
| ❷ | 让我们将**is gamestadopted**的值设置为 false，因为我们已经开始了一个新游戏。 |
| -你好 | 调用 **startGame()** 方法。我们将很快实现这一点。 |
| (a) | 更新游戏统计数据。 |

Next, implement the **startGame()** method; Listing [7-40](#PC43) shows us how.private void startGame() {// reset the scoresuserScore = 0;level = 1;updateGameStats();//reset the pushpin imagesfor (ImageView pin: pinImages) {pin.setImageResource(R.drawable.pin);}}Listing 7-40

startGame()方法

那应该可以处理一些基本的家务。

</section>

<section class="Section1 RenderAsSection1" id="Sec12">

## 声音的

大多数游戏在背景中使用音乐来增强玩家的体验。这些游戏还使用声音效果来获得更身临其境的感觉。我们的小游戏会用到这两者。当游戏开始时，我们会播放背景音乐，当气球爆开时，我们也会播放音效。

我从 YouTube 音频库拿到了背景音乐和 popping 音效；请随意选择您喜欢的背景音乐。

Once you’ve procured the audio files, you need to add them to the project; firstly, you need to create a raw folder in the **app/res** directory. You can do that with the context menu. Right-click **app/res**, then choose **New** ➤ **Folder** ➤ **Raw Resources Folder**, as shown in Figure [7-29](#Fig29).

<figure class="Figure" id="Fig29">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig29_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig29_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-29

新建资源文件夹

</figcaption>

</figure>

In the window that follows, click Finish, as shown in Figure [7-30](#Fig30).

<figure class="Figure" id="Fig30">![../images/340874_4_En_7_Chapter/340874_4_En_7_Fig30_HTML.jpg](../images/340874_4_En_7_Chapter/340874_4_En_7_Fig30_HTML.jpg)

<figcaption class="Caption" lang="en">Figure 7-30

新的安卓组件

</figcaption>

</figure>

接下来，右键单击原始文件夹。根据您使用的操作系统，选择**在 Finder 中显示**或**在浏览器中显示**。

您现在可以将音频文件拖放到 **raw** 文件夹中。

To play the background music, we will need a MediaPlayer object. This object is built-in in Android SDK. We simply need to import it to our Java source file. The following are the key method calls for the MediaPlayer object. Listing [7-41](#PC44) shows the important APIs we will use.import android.media.MediaPlayerMediaPlayer mplayer;mplayer = MediaPlayer.create(ctx.getApplicationContext(), R.raw.ngoni); ❶mplayer.setVolume(07.f, 0.7f); ❷mplayer.setLooping(true); ❸mplayer.start(); ❹mplayer.pause() ❺Listing 7-41

Key 方法调用 MediaPlayer 对象

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| -好的 | 该语句创建 MediaPlayer 的一个实例。它需要两个参数:第一个参数是一个上下文对象，第二个参数是原始文件夹(ngoni.mp3)中的资源文件的名称。我们在这里指定一个资源文件，所以不需要添加 **.mp3** 扩展名。 |
| ❷ | **setVolume()** 方法有两个参数。第一个是浮点值，用于指定左声道的音量，第二个是右声道的音量。这些值的范围是从 0.0 到 1.0。如您所见，我指定了 70%的音量。在实际的游戏中，您可能希望将这些值存储在一个首选项文件中，并让用户控制它。 |
| -你好 | 我希望音乐继续播放。我把它设置成自动重复播放。 |
| (a) | 这将开始播放音乐。 |
| (一) | 这将暂停音乐。 |

为了播放气球的弹出声音，我们将使用 SoundPool 对象。爆音是一个非常短的音频文件，可以反复使用(每次我们爆气球时)。使用 SoundPool 对象可以最好地管理这些声音。

There’s a bit of setup required before you can use a SoundPool object; Listing [7-42](#PC45) shows this setup.public Audio(Activity activity) { ❶AudioManager audioManager = (AudioManager)activity.getSystemService(Context.AUDIO_SERVICE);float actVolume = (float)audioManager.getStreamVolume(AudioManager.STREAM_MUSIC); ❷float maxVolume = (float)audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);volume = actVolume / maxVolume;activity.setVolumeControlStream(AudioManager.STREAM_MUSIC); ❸AudioAttributes audioAttrib = new AudioAttributes.Builder() ❹.setUsage(AudioAttributes.USAGE_GAME).setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION).build();soundPool = new SoundPool.Builder().setAudioAttributes(audioAttrib).setMaxStreams(6).build();soundPool.setOnLoadCompleteListener(new SoundPool.OnLoadCompleteListener() { ❺@Overridepublic void onLoadComplete(SoundPool soundPool, int sampleId, int status) {Log.d(TAG, "SoundPool is loaded");isLoaded = true;}});soundId = soundPool.load(activity, R.raw.pop, 1); ❻}public void playSound() {if (isLoaded) {soundPool.play(soundId, volume, volume, 1, 0, 1f); ❼}Log.d(TAG, "playSound");}Listing 7-42

声池〔t0〕〔t1〕

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| -好的 | 设置 SoundPool 和 AudioManager 通常在构造函数上完成。我们需要传递一个 Activity 实例(将是 MainActivity)，这样我们就可以获得对音频服务的引用。 |
| ❷ | 我们将使用 **getStreamVolume()** 和 **getStreamMaxVolume()** 来确定我们想要的声音效果有多大。 |
| -你好 | 这将音量控制绑定到 MainActivity。 |
| (a) | 我们需要设置一些属性来构建声音池。这种构建音池的方法是针对 Android 及以上版本(Lollipop)的。 |
| (一) | 声音是异步加载的。我们需要设置一个监听器，这样当它被加载时我们会得到通知。 |
| ❻ | 现在我们可以从 raw 文件夹中加载声音文件。 |
| ❼ | 这条线播放声音。这就是我们将在 **popBalloon()** 方法中调用的内容。 |

We’re going to put all of this code in a separate class; we’ll name it the **Audio** class. Create a new Java class named Audio. You can do that by right-clicking the project’s package, then choosing **New** ➤ **Java Class**, as we did before. Listing [7-43](#PC46) shows the full code for the Audio class.import android.app.Activity;import android.content.Context;import android.media.AudioAttributes;import android.media.AudioManager;import android.media.MediaPlayer;import android.media.SoundPool;import android.util.Log;public class Audio {private final int soundId;private MediaPlayer mplayer;private float volume;private SoundPool soundPool;private boolean isLoaded;private final String TAG = getClass().getName();public Audio(Activity activity) {AudioManager audioManager = (AudioManager) activity.getSystemService(Context.AUDIO_SERVICE);float actVolume = (float) audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);float maxVolume = (float) audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);volume = actVolume / maxVolume;activity.setVolumeControlStream(AudioManager.STREAM_MUSIC);AudioAttributes audioAttrib = new AudioAttributes.Builder().setUsage(AudioAttributes.USAGE_GAME).setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION).build();soundPool = new SoundPool.Builder().setAudioAttributes(audioAttrib).setMaxStreams(6).build();soundPool.setOnLoadCompleteListener(new SoundPool.OnLoadCompleteListener() {@Overridepublic void onLoadComplete(SoundPool soundPool, int sampleId, int status) {Log.d(TAG, "SoundPool is loaded");isLoaded = true;}});soundId = soundPool.load(activity, R.raw.pop, 1);}public void playSound() {if (isLoaded) {soundPool.play(soundId, volume, volume, 1, 0, 1f);}Log.d(TAG, "playSound");}public void prepareMediaPlayer(Context ctx) {mplayer = MediaPlayer.create(ctx.getApplicationContext(), R.raw.ngoni);mplayer.setVolume(05.f, 0.5f);mplayer.setLooping(true);}public void playMusic() {mplayer.start();}public void stopMusic() {mplayer.stop();}public void pauseMusic() {mplayer.pause();}}Listing 7-43

音频类

Now we can add some sounds to the app. In the MainActivity class, we need to create a member variable of type Audio, like this:Audio audio;Then, in the **onCreate()** method, we instantiate the Audio class and call the prepareMediaPlayer() method, as shown in the following:audio = new Audio(this);audio.prepareMediaPlayer(this);We want to play the music only when the game is in play; so, in MainActivity’s **startGame()** method, we add the following statement:audio.playMusic();When the game is not at play anymore, we want the music to stop; so, in the **gameOver()** method, we add this statement:audio.pauseMusic();Finally, in the **popBalloon()** method, add the following statement:audio.playSound();</section>

<section class="Section1 RenderAsSection1" id="Sec13">

## 最后润色

If you’ve been following the coding exercise (and running the game), you may have noticed that even after the game is over, you can still see some balloons flying around; you can thank the background thread for that. Even when all the five pins have been used up, the level is still active, and we still see some balloons being launched. To handle that, we can do the following:

1.  1\.

    Track all balloons released at each level. We can do this with an array list. Whenever we launch a balloon, we add it to the list.

2.  2\.

    Once the balloon is punctured, we will delete it from the list.

3.  3\.

    If the game is over, we will traverse all the remaining balloon objects in the array list and set their status to popped.

4.  4\.

    Finally, remove all remaining balloon objects from the view group.

First, let’s declare an ArrayList (as a member variable on MainActivity) to hold all the references to all Balloons that will be launched per level. The following code accomplishes that:private ArrayList<Balloon> balloons = new ArrayList<>();Next, in the **launchBalloon()** method, we insert a statement that adds a Balloon object to the ArrayList, like this:balloons.add(btemp);Next, in the **gameOver()** method, we add a logic that will loop through all the remaining Balloons in the ArrayList, set their popped status to true, and also remove the Balloon instance from the ViewGroup (the code is shown in Listing [7-44](#PC54)).private void gameOver() {isGameStopped = true;Toast.makeText(this, "Game Over", Toast.LENGTH_LONG).show();btn.setText("Play game");for (Balloon bal : balloons) {bal.setPopped(true);contentView.removeView(bal);}balloons.clear();audio.pauseMusic();}Listing 7-44

gameOver()方法

Finally, we need to add the **setPopped()** method to the Balloon class, as shown in Listing [7-45](#PC55).public void setPopped(boolean b) {isPopped = true;}Listing 7-45

气球类中的 setPopped()方法

That should do it. The final code listing we will see in this chapter is the complete code for MainActivity. It may be difficult to keep things straight after all the changes we made to MainActivity; so, to provide as a reference, Listing [7-46](#PC56) shows MainActivity’s complete code.import android.graphics.Color;import android.os.Bundle;import android.util.Log;import android.view.MotionEvent;import android.view.View;import android.view.ViewGroup;import android.view.ViewTreeObserver;import android.widget.Button;import android.widget.ImageView;import android.widget.TextView;import android.widget.Toast;import java.util.ArrayList;import java.util.Date;import java.util.Random;public class MainActivity extends AppCompatActivityimplements PopListener {ViewGroup contentView;private static String TAG;private int[] colors = new int[3];private int scrWidth;private int scrHeight;private int level = 1;private TextView levelDisplay;private TextView scoreDisplay;private int numberOfPins = 5;private int pinsUsed;private int balloonsLaunched;private int balloonsPerLevel = 8;private int balloonsPopped = 0;private boolean isGameStopped = true;private ArrayList<ImageView> pinImages = new ArrayList<>();private ArrayList<Balloon> balloons = new ArrayList<>();private int userScore;Button btn;Audio audio;@Overrideprotected void onCreate(Bundle savedInstanceState) {super.onCreate(savedInstanceState);TAG = getClass().getName();getWindow().setBackgroundDrawableResource(R.mipmap.background);setContentView(R.layout.activity_main);colors[0] = Color.argb(255, 255, 0, 0);colors[1] = Color.argb(255, 0, 255, 0);colors[2] = Color.argb(255, 0, 0, 255);contentView = (ViewGroup) findViewById(R.id.content_view);levelDisplay = (TextView) findViewById(R.id.level_display);scoreDisplay = (TextView) findViewById(R.id.score_display);pinImages.add((ImageView) findViewById(R.id.pushpin1));pinImages.add((ImageView) findViewById(R.id.pushpin2));pinImages.add((ImageView) findViewById(R.id.pushpin3));pinImages.add((ImageView) findViewById(R.id.pushpin4));pinImages.add((ImageView) findViewById(R.id.pushpin5));btn = (Button) findViewById(R.id.btn);btn.setOnClickListener(new View.OnClickListener() {@Overridepublic void onClick(View view) {startLevel();}});contentView.setOnTouchListener(new View.OnTouchListener() {@Overridepublic boolean onTouch(View v, MotionEvent event) {if (event.getAction() == MotionEvent.ACTION_DOWN) {setToFullScreen();}return false;}});audio = new Audio(this);audio.prepareMediaPlayer(this);}@Overrideprotected void onResume() {super.onResume();updateGameStats();setToFullScreen();ViewTreeObserver viewTreeObserver = contentView.getViewTreeObserver();if (viewTreeObserver.isAlive()) {viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {@Overridepublic void onGlobalLayout() {contentView.getViewTreeObserver().removeOnGlobalLayoutListener(this);scrWidth = contentView.getWidth();scrHeight = contentView.getHeight();}});}}public void launchBalloon(int xPos) {balloonsLaunched++;int curColor = colors[nextColor()];Balloon btemp = new Balloon(MainActivity.this, curColor, 100, level);btemp.setY(scrHeight);btemp.setX(xPos);balloons.add(btemp);contentView.addView(btemp);btemp.release(scrHeight, 5000);Log.d(TAG, "Balloon created");}private void startLevel() {if (isGameStopped) {isGameStopped = false;startGame();}updateGameStats();new LevelLoop(level).start();}private void finishLevel() {Log.d(TAG, "FINISH LEVEL");String message = String.format("Level %d finished!", level);Toast.makeText(this, message, Toast.LENGTH_LONG).show();level++;updateGameStats();btn.setText(String.format("Start level %d", level));Log.d(TAG, String.format("balloonsLaunched = %d", balloonsLaunched));balloonsPopped = 0;}private void updateGameStats() {levelDisplay.setText(String.format("%s", level));scoreDisplay.setText(String.format("%s", userScore));}private void setToFullScreen() {contentView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LOW_PROFILE| View.SYSTEM_UI_FLAG_FULLSCREEN| View.SYSTEM_UI_FLAG_LAYOUT_STABLE| View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY| View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION| View.SYSTEM_UI_FLAG_HIDE_NAVIGATION);}private static int nextColor() {int max = 2;int min = 0;int retval = 0;Random random = new Random();retval = random.nextInt((max - min) + 1) + min;Log.d(TAG, String.format("retval = %d", retval));return retval;}@Overridepublic void popBalloon(Balloon bal, boolean isTouched) {balloonsPopped++;balloons.remove(bal);contentView.removeView(bal);audio.playSound();if(isTouched) {userScore++;scoreDisplay.setText(String.format("%d", userScore));}else {pinsUsed++;if (pinsUsed <= pinImages.size() ) {pinImages.get(pinsUsed -1).setImageResource(R.drawable.pin_broken);Toast.makeText(this, "Ouch!",Toast.LENGTH_SHORT).show();}if(pinsUsed == numberOfPins) {gameOver();}}if (balloonsPopped == balloonsPerLevel) {finishLevel();}}private void startGame() {// reset the scoresuserScore = 0;level = 1;updateGameStats();//reset the pushpin imagesfor (ImageView pin: pinImages) {pin.setImageResource(R.drawable.pin);}audio.playMusic();}private void gameOver() {isGameStopped = true;Toast.makeText(this, "Game Over", Toast.LENGTH_LONG).show();btn.setText("Play game");for (Balloon bal : balloons) {bal.setPopped(true);contentView.removeView(bal);}balloons.clear();audio.pauseMusic();}class LevelLoop extends Thread {private int shortDelay = 500;private int longDelay = 1_500;private int maxDelay;private int minDelay;private int delay;private int looplevel;int balloonsLaunched = 0;public LevelLoop(int argLevel) {looplevel = argLevel;}public void run() {while (balloonsLaunched <= balloonsPerLevel) {balloonsLaunched++;Random random = new Random(new Date().getTime());final int xPosition = random.nextInt(scrWidth - 200);maxDelay = Math.max(shortDelay, (longDelay - ((looplevel -1)) * 500));minDelay = maxDelay / 2;delay = random.nextInt(minDelay) + minDelay;Log.i(TAG, String.format("Thread delay = %d", delay));try {Thread.sleep(delay);}catch(InterruptedException e) {Log.e(TAG, e.getMessage());}// need to wrap this on runOnUiThreadrunOnUiThread(new Thread() {public void run() {launchBalloon(xPosition);}});}}}}Listing 7-46

主要活动

</section>**