# 一、奠定基础

首先，在这一章中，我向你介绍了反编译器的问题，以及为什么虚拟机和 Android 平台面临如此大的风险。你了解了反编译器的历史；你可能会惊讶，它们几乎和计算机一样存在了很久。因为这是一个非常情绪化的话题，我花了一些时间来讨论反编译背后的法律和道德问题。最后，如果你想保护你的代码，你会看到一些选择。

### 编译器和反编译器

计算机语言的发展是因为大多数正常人不能用机器代码或其最接近的等价物，汇编程序工作。幸运的是，在计算技术发展的早期，人们就意识到人类不适合用机器代码编程。诸如 Fortran、COBOL、C、VB 以及最近的 Java 和 C#等计算机语言的发展，使我们能够以一种人类友好的格式表达我们的想法，然后可以转换成计算机芯片可以理解的格式。

最基本的是，编译器的工作是将这种文本表示或源代码翻译成一系列 0 和 1 或机器代码，计算机可以将其解释为您希望它执行的操作或步骤。它使用一系列模式匹配规则来做到这一点。词法分析器标记源代码——任何错误或不在编译器词典中的单词都会被拒绝。然后，这些标记被传递给语言解析器，它将一个或多个标记与一系列规则进行匹配，并将这些标记翻译成中间代码 (VB。NET、C#、Pascal 或 Java)或有时直接转换成机器代码(Objective-C、C++或 Fortran)。任何不符合编译器规则的源代码都会被拒绝，编译会失败。

现在你知道编译器是做什么的了，但我只是触及了皮毛。编译器技术一直是一个专门的、有时是复杂的计算领域。现代的进步意味着事情会变得更加复杂，尤其是在虚拟机领域。在某种程度上，这种驱动力来自 Java 和. net。JIT 编译器试图通过优化 Java 字节码的执行来缩短 Java 和 C++执行时间的差距。这似乎是一个不可能的任务，因为 Java 字节码毕竟是解释的，而 C++是编译的。但是 JIT 编译器技术取得了显著的进步，也使得 Java 编译器和虚拟机变得更加复杂。

大多数编译器会做大量的预处理和后处理。预处理程序通过去除所有不必要的信息，如程序员的注释，并添加任何标准的或包含的头文件或包，为词法分析准备源代码。典型的后处理器阶段是代码优化，编译器解析或扫描代码，重新排序，并删除任何冗余以提高代码的效率和速度。

反编译器(这并不奇怪)将机器码或中间代码翻译回源代码。换句话说，整个编译过程是相反的。机器码以某种方式被标记化，并被解析或翻译回源代码。不过，这种转换很少会产生原始源代码，因为信息会在预处理和后处理阶段丢失。

考虑与人类语言的类比:将 Android 包文件(APK)反编译回 Java 源代码就像将德语(`classes.dex`)翻译成法语(Java 类文件)，然后翻译成英语(Java 源代码)。一路上，一些信息在翻译过程中丢失了。Java 源代码是为人类而不是为计算机设计的，通常有些步骤是多余的，或者以稍微不同的顺序执行会更快。由于这些丢失的元素，很少(如果有的话)反编译产生原始源代码。

目前有一些反编译器，但是它们没有被广泛宣传。反编译器或反汇编器可用于 Clipper(瓦尔基里)，FoxPro (ReFox 和 Defox)，Pascal，C (dcc，decomp，Hex-Rays)，Objective-C (Hex-Rays)，Ada，当然还有 Java。即使是世界各地杜恩斯伯里迷们喜爱的牛顿，也不安全。毫不奇怪，对于解释型语言(如 VB、Pascal 和 Java)来说，反编译器更为常见，因为要传递大量的信息。

### 虚拟机反编译器

有过几次值得注意的反编译机器码的尝试。克里斯蒂娜·希福恩特斯的 dcc 和最近的 Hex-Ray 的 IDA 反编译器只是两个例子。然而，在机器码级别，数据和指令是混合在一起的，要恢复原始代码要困难得多(但并非不可能)。

在虚拟机中，代码只是简单地通过了预处理器，而反编译器的工作是逆转编译的预处理阶段。这使得解释的代码更容易反编译。当然，没有评论，更糟糕的是，没有规范，但也没有 R&D 成本。

### 为什么 Java 配 Android？

在我谈论“为什么是 Android？”我首先需要问，“为什么是 Java？”这并不是说所有的 Android 应用都是用 Java 编写的——我也包括 HTML5 应用。但是 Java 和 Android 是紧密结合在一起的，所以我真的不能离开另一个来讨论一个。

最初的 Java 虚拟机(JVM)被设计为在电视有线机顶盒上运行。因此，它是一个非常小堆栈的机器，使用有限的指令集将指令推入堆栈或从堆栈中取出。这使得使用相对较少的练习就能很容易理解这些说明。因为编译现在是一个两阶段的过程，JVM 还要求编译器传递大量信息，比如变量和方法名，否则这些信息是不可用的。当你试图理解反编译的源代码时，这些名字几乎和注释一样有用。

JVM 的当前设计独立于 Java 开发工具包(JDK)。换句话说，语言和库可能会改变，但是 JVM 和操作码是固定的。这意味着，如果 Java 现在易于反编译，它也很可能总是易于反编译。正如您将看到的，在许多情况下，反编译 Java 类就像运行简单的 DOS 或 UNIX 命令一样简单。

将来，JVM 很可能会被修改以停止反编译，但是这会破坏任何向后兼容性，并且所有当前的 Java 代码都必须重新编译。虽然这种情况以前在使用不同版本 VB 的微软世界中也发生过，但是除了 Oracle 之外，许多公司都开发了虚拟机。

让这种情况变得更加有趣的是，那些希望让自己的操作系统或浏览器支持 Java 的公司通常会创建自己的 JVM。Oracle 只负责 JVM 规范。这种情况已经发展到这样的程度，对 JVM 规范的任何基本改变都必须是向后兼容的。修改 JVM 以防止反编译将需要大量的手术，并且很可能会破坏这种向后兼容性，从而确保 Java 类在可预见的将来会反编译。

JDK 没有这样的兼容性限制，并且每个版本都添加了更多的功能。虽然第一批反编译器，如 Mocha，在 JDK 1.1 中引入内部类时失败了，但目前最受欢迎的 JD-GUI 完全能够处理内部类或 Java 语言的后续添加，如泛型。

在下一章中，你会学到更多关于为什么 Java 面临着反编译的风险，但是现在，这里是 Java 易受攻击的七个原因:

*   为了便于移植，Java 代码被部分编译，然后由 JVM 解释。
*   Java 编译后的类包含大量 JVM 的符号信息。
*   由于向后兼容的问题，JVM 的设计不太可能改变。
*   JVM 中几乎没有指令或操作码。
*   JVM 是一个简单的堆栈机器。
*   标准应用对反编译没有真正的保护。
*   Java 应用被自动编译成更小的模块化类。

让我们从一个简单的类文件例子开始，如[清单 1-1](#list_1_1) 所示。

**清单 1-1。** *简单的 Java 源代码示例*

`public class Casting {
public static void main(String args[]){
for(char c=0; c < 128; c++) {
System.out.println("ascii " + (int)c + " character "+ c);
}
}
}`

[清单 1-2](#list_1_2) 显示了使用 javap 的[清单 1-1](#list_1_1) 中的类文件的输出，javap 是 JDK 附带的 Java 的类文件反汇编器。你可以很容易地反编译 Java，因为——正如你在本书后面看到的 JVM 是一个简单的堆栈机器，没有寄存器和有限数量的高级指令或操作码。

**清单 1-2。** *Javap 输出*

`Compiled from Casting.java
public synchronized class Casting extends java.lang.Object
/* ACC_SUPER bit set */
{
public static void main(java.lang.String[]);
/* Stack=4, Locals=2, Args_size=1 */
public Casting();
/* Stack=1, Locals=1, Args_size=1 */
}

Method void main(java.lang.String[])
0 iconst_0
1 istore_1
2 goto 41
5 getstatic #12 <Field java.io.PrintStream out>
8 new #6 <Class java.lang.StringBuffer>
11 dup
12 ldc #2 <String "ascii ">
14 invokespecial #9 <Method
java.lang.StringBuffer(java.lang.String)>
17 iload_1
18 invokevirtual #10 <Method java.lang.StringBuffer append(char)>
21 ldc #1 <String " character ">
23 invokevirtual #11 <Method java.lang.StringBuffer
append(java.lang.String)>
26 iload_1
27 invokevirtual #10 <Method java.lang.StringBuffer append(char)>
30 invokevirtual #14 <Method java.lang.String toString()>
33 invokevirtual #13 <Method void println(java.lang.String)>
36 iload_1
37 iconst_1
38 iadd
39 i2c
40 istore_1
41 iload_1
42 sipush 128
45 if_icmplt 5
48 return

Method Casting()
0 aload_0
1 invokespecial #8 <Method java.lang.Object()>
4 return<`

显然，一个类文件包含了大量的源代码信息。我在本书中的目的是向您展示如何获取这些信息，并将其逆向工程为源代码。我还将向您展示可以采取哪些步骤来保护信息。

### 为什么选择安卓？

到目前为止，除了 applets 和 Java Swing 应用之外，Java 代码通常位于服务器端，很少或没有代码在客户端运行。随着谷歌 Android 操作系统的推出，这种情况发生了变化。Android 应用，不管是用 Java 还是 HTML5/CSS 写的，都是 apk 形式的客户端应用。这些 apk 然后在 Dalvik 虚拟机(DVM)上执行。

DVM 在许多方面不同于 JVM。首先，它是基于寄存器的机器，不像基于堆栈的 JVM。DVM 使用一个具有不同结构和操作码的 Dalvik 可执行(DEX)文件，而不是将多个类文件捆绑到一个 jar 文件中。从表面上看，反编译 APK 似乎要困难得多。然而，有人已经为您做了所有的艰苦工作:一个名为 dex2jar 的工具允许您将 dex 文件转换回 jar 文件，然后可以将其反编译回 Java 源代码。

因为 apk 存在于手机上，所以可以很容易地下载到 PC 或 Mac 上，然后进行反编译。您可以使用许多不同的工具和技术来访问 APK，还有许多反编译器，我将在本书的后面介绍。但是获取源代码最简单的方法是使用市场上的任何文件管理工具，比如 ASTRO File Manager，将 APK 复制到手机的 SD 卡上。一旦 SD 卡插入 PC 或 Mac，就可以使用 dex2jar 进行反编译，然后使用您喜欢的反编译器，如 JD-GUI。

Google 已经使得在你的构建中添加 ProGuard 变得非常容易，但是在默认情况下不会发生混淆。目前(直到这个问题得到更高的关注)，代码不太可能使用模糊处理来保护，所以代码很有可能被完全反编译回源代码。ProGuard 作为混淆工具也不是 100%有效，正如你在第 4 章和第 7 章中看到的。

许多 Android 应用通过 web 服务与后端系统对话。他们在数据库中寻找物品，或者完成一次购买，或者将数据添加到工资单系统，或者将文档上传到文件服务器。允许应用连接到这些后端系统的用户名和密码通常是硬编码在 Android 应用中的。因此，如果你没有保护你的代码，并且你把你的后台系统的钥匙留在你的应用中，你就冒着有人破坏你的数据库并获得他们不应该访问的系统的风险。

不太可能，但完全有可能，有人可以访问源代码，并可以重新编译应用，让它与不同的后端系统对话，并将其用作获取用户名和密码的一种方式。这些信息可以在稍后阶段使用真正的 Android 应用访问私人数据。

这本书解释了如何隐藏你的信息，不让这些窥探的眼睛看到，并提高门槛，因此找到后端服务器的钥匙或找到存储在你手机上的信用卡信息需要比基本知识多得多的知识。

在将你的 Android 应用发布到市场之前，保护好它也是非常重要的。几个网站和论坛共享 APK，因此即使你通过发布更新版本来保护你的应用，原始的未受保护的 APK 可能仍然存在于手机和论坛上。您的 web 服务 API 也必须同时更新，这迫使用户更新他们的应用，并导致糟糕的用户体验和潜在的客户流失。

在第 4 章中，你会学到更多关于为什么 Android 会面临反编译的风险，但是现在这里列出了 Android 应用易受攻击的原因:

*   有多种简单的方法可以访问 Android APKs。
*   将 APK 翻译成 Java jar 文件以便后续反编译是很简单的。
*   到目前为止，几乎没有人使用混淆或任何形式的保护。
*   一旦 APK 被释放，就很难取消访问。
*   使用 apktool 等工具，一键反编译是可能的。
*   apk 在黑客论坛上分享。

[清单 1-3](#list_1_3) 显示了来自[清单 1-1](#list_1_1) 的`Casting.java`文件在转换成 DEX 格式后的 dexdump 输出。如您所见，这是类似的信息，但采用了新的格式。第 3 章更详细地介绍了不同之处。

**清单 1-3。**T3】dex dump 输出

`Class #0 -
Class descriptor : 'LCasting;'
Access flags : 0x0001 (PUBLIC)
Superclass : 'Ljava/lang/Object;'
Interfaces -
Static fields -
Instance fields -
Direct methods -
#0 : (in LCasting;)
name : '<init>'
type : '()V'
access : 0x10001 (PUBLIC CONSTRUCTOR)
code -
registers : 1
ins : 1
outs : 1
insns size : 4 16-bit code units
catches : (none)
positions :
0x0000 line=1
locals :
0x0000 - 0x0004 reg=0 this LCasting;
#1 : (in LCasting;)
name : 'main'
type : '([Ljava/lang/String;)V'
access : 0x0009 (PUBLIC STATIC)
code -
registers : 5
ins : 1
outs : 2
insns size : 44 16-bit code units
catches : (none)
positions :
0x0000 line=3
0x0005 line=4
0x0027 line=3
0x002b line=6
locals :
Virtual methods -
source_file_idx : 3 (Casting.java)`

### 反编译器的历史

关于反编译器的历史写得很少，这很令人惊讶，因为几乎每个编译器都有一个反编译器。让我们花一点时间来谈谈它们的历史，这样你就能明白为什么这么快就为 JVM 和 DVM 创建了反编译器。

自从简陋的 PC 出现之前——不要说了，自从 COBOL 出现之前，反编译器就已经以这样或那样的形式存在了。你可以一直追溯到 ALGOL，找到最早的反编译器的例子。早在 1960 年，Joel Donnelly 和 Herman Englander 就在美国海军电子实验室(NEL)实验室编写了 D-Neliac。它的主要功能是将非 Neliac 编译的程序转换成与 Neliac 兼容的二进制文件。(Neliac 是一种 ALGOL 类型的语言，代表海军电子实验室国际 ALGOL 编译器。)

多年来，已经有了其他针对 COBOL、Ada、Fortran 和许多其他深奥的主流语言的反编译器，它们运行在 IBM 大型机、PDP-11 和 UNIVACs 等之上。这些早期开发的主要原因可能是翻译软件或转换二进制文件以在不同的硬件上运行。

最近，规避 2000 年问题的逆向工程成为反编译的可接受的一面——转换遗留代码以规避 2000 年问题通常需要反汇编或完全反编译。但是逆向工程是一个巨大的增长领域，并没有在世纪之交后消失。道琼斯指数触及 10，000 点大关和欧元的引入所引发的问题导致了金融计划的失败。

逆向工程技术也被用来分析旧代码，这些代码通常有成千上万的增量变化，以消除冗余并将这些遗留系统转换成更高效的动物。

在一个更基本的层面上，PC 机代码的十六进制转储给程序员提供了额外的洞察力，让他们了解某些东西是如何实现的，并被用来打破对软件的人为限制。例如，包含游戏和其他实用程序的定时炸弹或限制副本的杂志光盘经常被打补丁，以将演示副本更改为软件的完整版本；这通常是用原始的反汇编程序完成的，如 DOS 的调试程序。

任何精通汇编语言的人都可以学会快速发现代码中的模式，并绕过适当的源代码片段。盗版软件是软件业的一个大问题，而分解代码只是专业和业余盗版者使用的一种技术。因此，许多神秘的复制保护技术都失败了。但是这些都是原始的工具和技术，从头开始编写代码可能比用汇编程序重新创建源代码更快。

多年来，传统软件公司也参与了软件逆向工程。竞赛使用逆向工程和反编译工具在世界各地研究和复制新技术。一般来说，这些都是内部的反编译器，不供公众使用。

很可能第一个真正的 Java 反编译器是由 IBM 编写的，而不是由《摩卡》的作者 Hanpeter van Vliet 编写的。丹尼尔·福特的白皮书《Jive:一个 Java 反编译器》(1996 年 5 月)出现在 IBM Research 的搜索引擎中；这打败了摩卡，摩卡直到第二年 7 月才公布。

像 dcc 这样的学术反编译器可以在公共领域获得。Hex-Ray 的 IDA 等商业反编译器也开始出现。幸运的是，对于微软这样的公司来说，使用 dcc 或 Hex-Rays 反编译 Office 会产生如此多的代码，以至于它对用户来说就像 debug 或十六进制转储一样友好。大多数现代商业软件的源代码是如此之大，以至于没有设计文档和大量的源代码注释就变得难以理解。让我们面对现实吧:许多人的 C++代码在他们写出来六个月后仍然很难读懂。对于其他人来说，在没有帮助的情况下破译来自编译 C++代码的 C 代码有多容易？

#### 更仔细地回顾解释型语言:Visual Basic

让我们以 VB 为例来看看早期版本的解释语言。VB 的早期版本由它的运行时模块`vbrun.dll`以一种有点类似于 Java 和 JVM 的方式解释。像 Java 类文件一样，VB 程序的源代码被捆绑在二进制文件中。奇怪的是，VB3 比 Java 保留了更多的信息——甚至包括程序员的注释。

最初版本的 VB 生成了一个中间伪代码，叫做 *p-code* ，是 Pascal 语言，起源于 P-System ( `[www.threedee.com/jcm/psystem/](http://www.threedee.com/jcm/psystem/)`)。在你说任何事情之前，是的，Pascal 和它的所有衍生物都同样容易被反编译——包括微软早期版本的 C 编译器，所以没有人会觉得被遗漏了。p 代码与字节码没有什么不同，本质上是在运行时由`vbrun.dll`解释的 VB 操作码。如果你曾经想知道为什么你需要在 VB 可执行文件中包含`vbrun300.dll`，现在你知道了。你必须包含`vbrun.dll`，这样它才能解释 p 代码并执行你的程序。

来自德国的 H. P. Diettrich 博士是同名著作《DoDi——也许是最著名的 VB 反编译器——的作者。曾经，VB 有一种反编译器和混淆器(或保护工具，因为它们在 VB 中被称为)的文化。但是随着 VB 转向编译代码而不是解释代码，反编译器的数量急剧减少。DoDi 在其网站上免费提供了 VBGuard，其他来源也提供了诸如 Decompiler Defeater、Protect、Overwrite、Shield 和 VBShield 等程序。但是它们也随着 VB5 和 VB6 一起消失了。

那当然是以前了。NET，这又兜了一圈:VB 再一次被演绎。毫不奇怪，许多反编译器和混淆器再次出现在。NET 世界，如 ILSpy 和 Reflector 反编译器，以及风度和 Dotfuscator 混淆器。

#### 汉彼得·范·弗利特和摩卡

奇怪的是，作为一个技术主题，这本书也有非常人性化的元素。1996 年，在荷兰从癌症手术中康复期间，Hanpeter van Vliet 编写了第一个公共领域反编译器 Mocha。他还编写了一个名为 Crema 的混淆器，试图保护 applet 的源代码。如果说摩卡是乌兹机枪，那么克莉玛就是防弹衣。在如今经典的互联网营销策略中，摩卡是免费的，而克莉玛则收取少量费用。

当摩卡的测试版首次出现在汉彼得的网站上时，引起了巨大的争议，尤其是在 CNET 的一篇文章中。由于争议，汉彼得采取了非常光荣的步骤，从他的网站上删除了摩卡。然后他允许他网站的访问者投票决定是否应该再次提供摩卡咖啡。投票结果是十比一支持摩卡，很快它就重新出现在了汉彼得的网站上。

然而，摩卡从未走出测试版。在为一篇关于这一主题的网络技术文章做研究时，我从他的妻子英格丽德那里得知，汉彼得的喉癌最终夺去了他的生命，他于 1996 年新年前夕去世，享年 34 岁。

克莉玛和摩卡的源代码在汉彼得去世前不久卖给了博兰，所有收益归英格丽所有。JBuilder 的一些早期版本附带了一个混淆器，可能是 Crema。它试图通过用控制字符替换 ASCII 变量名来保护 Java 代码不被反编译。

我将在本书的后面更多地讨论其他 Java 反编译器和混淆器的宿主。

### 反编译时要考虑的法律问题

在您开始构建自己的反编译器之前，让我们借此机会考虑一下为了您自己的享受或利益而反编译他人代码的法律含义。仅仅因为 Java 将反编译技术从一些非常严肃的领域转移到了更主流的计算领域，并不能减少你或你的公司被起诉的可能性。这可能会让它更有趣，但你真的应该小心。

作为一小组基本规则，请尝试以下方法:

*   不要反编译一个 APK，重新编译它，然后把它当成你自己的。
*   不要想把重新编译的 APK 卖给任何第三方。
*   尽量不要反编译带有明确禁止反编译或逆向工程代码的许可协议的 APK 或应用。
*   不要反编译一个 APK 来移除任何保护机制，然后为了你自己的使用而重新编译它。

#### 保护法

在过去的几年里，当涉及到反编译软件时，大企业已经使法律坚定地向它倾斜。公司可以使用许多法律机制来阻止你反编译他们的软件；如果你因为一家公司发现你反编译了它的程序而不得不出现在法庭上，你几乎没有或者根本没有法律辩护。专利法、版权法、包覆许可证中的反逆向工程条款，以及诸如数字千年版权法(DMCA)等许多法律都可能被用来对付您。不同的国家或州可能适用不同的法律:例如，“无反向工程条款”软件许可证在欧盟(EU)是无效条款。但基本概念是相同的:为了将代码克隆到另一个竞争产品中而反编译一个程序，你可能违反了法律。秘诀在于，你不应该站着、跪着或非常用力地压制原作者的合法权利(版权)。这并不是说反编译是不可行的。在某些有限的条件下，法律倾向于通过所谓的*合理使用*的概念进行反编译或逆向工程。几乎从时间的开端，当然也是从工业时代开始，许多人类最伟大的发明都来自那些站在巨人肩膀上创造出一些特别东西的人。例如，蒸汽火车和电灯泡的发明是相对温和的技术进步。其他人提供了底层的概念，而最终的对象是由像乔治·斯蒂芬森或托马斯·爱迪生这样的人来创造的。(你可以在`[www.usgennet.org/usa/topic/steam/Early/Time.html](http://www.usgennet.org/usa/topic/steam/Early/Time.html)`看到斯蒂芬森欠许多其他发明家的债务的一个很好的例子，比如詹姆斯·瓦特。这是专利出现的原因之一:允许人们建立在其他发明的基础上，同时仍然给最初的发明者一些补偿，比如说 20 年。

##### 双亲

在软件领域，商业秘密通常受到版权法的保护，并且越来越多地受到专利的保护。专利可以保护程序的某些部分，但是一个完整的程序被一个专利或一系列专利保护的可能性很小。软件公司希望保护他们的投资，所以他们通常求助于版权法或软件许可证来防止人们从本质上窃取他们的研究和开发成果。

##### 版权

但是版权法并不是坚如磐石，因为否则就没有为一个想法申请专利的动机，专利局也会很快倒闭。版权保护并不延伸到计算机程序的接口，如果开发者能够证明他们已经反编译了程序，以查看他们如何能够与程序中任何未发布的*应用编程接口(API)*进行互操作，那么他们可以使用合理使用辩护。

##### 计算机程序法律保护指令

如果你住在欧盟，那么你很可能会受到计算机程序法律保护指令的约束。这个指令声明你可以在一定的限制条件下反编译器:例如，当你试图理解功能需求来创建一个与你自己的程序兼容的接口。换句话说，如果您需要访问第三方程序的内部调用，并且作者拒绝以任何价格泄露 API，您可以进行反编译。但是你只能用这些信息来创建你自己程序的接口，而不是创建一个有竞争力的产品。你也不能对任何受保护的区域进行逆向工程。

多年来，微软的应用据称从对 Windows 3.1 和 Windows 95 的底层未发布 API 调用中获得了不公平的优势，这些调用比已发布的 API 快几个数量级。电子前沿基金会(EFF)提出了一个有用的路线图类比来帮助解释这种情况。假设您正从底特律前往纽约，但您的地图没有显示任何州际路线；当然，你最终会通过走小路到达那里，但是如果你有一张完整的州际地图，路程会短很多。如果这些情况属实，欧盟指令将成为拆卸 Windows 2000 或微软 Office 的理由，但在尝试之前，你最好请一位好律师。

##### 逆向工程

在美国，判例也允许法律反编译。迄今为止最著名的案例是 Sega 诉 Accolade ( `[http://digital-law-online.info/cases/24PQ2D1561.htm](http://digital-law-online.info/cases/24PQ2D1561.htm)`)。1992 年，Accolade 公司赢得了对世嘉公司的诉讼；裁决称，雅高未经授权拆卸世嘉目标代码并不侵犯版权。Accolade 将世嘉的二进制文件逆向工程为一个中间代码，允许 Accolade 提取一个软件密钥，使 Accolade 的游戏能够与世嘉 Genesis 视频控制台进行交互。显然，世嘉不打算让 Accolade 访问其 API，或者在这种情况下，解锁世嘉游戏平台的代码。法院支持 Accolade，判定反向工程构成了合理使用。但在你认为这给了你反编译代码的全权委托之前，你可能想知道雅达利诉任天堂(`[http://digital-law-online.info/cases/24PQ2D1015.htm](http://digital-law-online.info/cases/24PQ2D1015.htm)`)在非常相似的情况下对雅达利不利。

#### 法律大局

总之——你可以看出这是法律部分——美国的法院案例和欧盟指令都强调，在某些情况下，逆向工程*可以*用于理解互操作性和创建程序接口。它*不能*用来制作复制品，并作为竞争产品出售。大多数 Java 反编译不属于互操作性范畴。更有可能的是，反编译器想要盗版代码，或者，充其量，理解软件背后的基本思想和技术。

尚不清楚通过逆向工程来发现 APK 是如何创作的是否构成合理使用。美国 1976 年的版权法排除了“任何想法、程序、过程、系统、操作方法、概念、原则或发现，无论其描述的形式如何”，这听起来像是辩护的开始，也是越来越多的软件专利被颁发的原因之一。反编译盗版或非法出售软件无法辩护。

但从开发商的角度来看，形势看起来很黯淡。唯一的保护——用户许可证——几乎和禁止盗版 MP3 的法律一样有用。它不会从物理上阻止任何人进行非法复制，也不会对家庭用户起到真正的威慑作用。没有任何法律手段可以保护你的代码免受黑客的攻击，有时，试图创建当今安全系统的人似乎感觉自己站在了白痴的肩膀上。你只需要看看对电子书保护计划的调查(`[http://slashdot.org/article.pl?sid=01/07/17/130226](http://slashdot.org/article.pl?sid=01/07/17/130226)`)和 DeCSS 惨败(`[http://cyber.law.harvard.edu/openlaw/DVD/resources.html](http://cyber.law.harvard.edu/openlaw/DVD/resources.html)`)就能明白许多所谓的安全系统实际上有多脆弱。

### 道德问题

反编译是学习 Android 开发和 DVM 如何工作的一个很好的方法。如果你遇到一种你以前没见过的技术，你可以快速反编译它，看看它是如何完成的。反编译通过看到其他人的编程技术，帮助人们爬上 Android 学习曲线。反编译 apk 的能力可以决定基本的 Android 理解和深入的知识。的确，有大量的开源示例可供参考，但是如果您可以选择自己的示例并修改它们以满足您的需求，那会更有帮助。

但是如果没有讨论窃取他人代码背后的道德问题，任何一本关于反编译的书都是不完整的。由于这种情况，Android 应用带有完整的源代码:如果你愿意，可以说是强制开源。

作者、出版商、作者的代理人以及作者代理人的母亲想要声明，我们*并不是*提倡本书的读者为了教育目的之外的任何目的反编译器。本书的目的是向您展示如何反编译源代码，但我们不鼓励任何人反编译其他程序员的代码，然后尝试使用、出售或重新打包，就好像这是您自己的代码一样。请不要对任何有许可协议的代码进行逆向工程，该协议声明您不应该反编译代码。这不公平，你只会给自己找麻烦。(此外，你永远无法确定反编译器生成的代码是 100%准确的。如果你打算使用反编译作为你自己产品的基础，你可能会大吃一惊。话虽如此，数以千计的 apk 可用，当反编译时，将帮助你理解好的和坏的 Android 编程技术。

在某种程度上，我是在为“不要射杀信使”辩护。我不是第一个发现 Java 中这个缺陷的人，当然也不会是最后一个写这个主题的人。我写这本书的原因，就像互联网的早期一样，基本上是利他的。换句话说，我发现了一个很酷的小技巧，我想告诉大家。

### 保护自己

盗版软件是许多软件公司头疼的问题，也是其他公司的大生意。至少，软件盗版者可以使用反编译器来消除许可限制；但是想象一下，如果这项技术可以反编译 Office 2010，重新编译它，并作为一种新的竞争产品出售，会有什么后果。在某种程度上，当 Corel 发布其 Office for Java 的测试版时，这种情况很容易发生。

你能做些什么来保护你的代码吗？是:

*   许可协议:许可协议并不能为想要反编译你代码的程序员提供任何真正的保护。
*   *代码中的保护方案:*在代码中散布保护方案(比如检查手机是否有根)是没有用的，因为这些方案可以在反编译代码之外进行注释。
*   *代码指纹:*这被定义为用于标记或指纹化源代码以证明所有权的伪造代码。它可以与许可协议一起使用，但只有在法庭上才真正有用。更好的反编译工具可以分析代码并删除任何虚假代码。
*   *混淆:*混淆将一个类文件中的方法名和变量名替换成怪异而奇妙的名字。这可能是一个很好的威慑，但源代码通常仍然是可见的，这取决于您选择的混淆器。
*   *知识产权(IPR)保护方案:*这些方案，如 Android Market 数字版权管理(DRM)，通常会在几小时或几天内被破坏，通常不会提供太多保护。
*   *服务器端代码:*对 APKs 最安全的保护是隐藏 web 服务器上所有有趣的代码，只使用 APK 作为瘦前端 GUI。这样做的缺点是，您可能仍然需要在某个地方隐藏一个 API 密钥来访问 web 服务器。
*   *原生代码:*Android 原生开发套件(NDK)允许你在 C++文件中隐藏密码信息，这些文件可以反汇编但不能反编译，并且仍然运行在 DVM 之上。如果操作正确，这项技术可以增加一层重要的保护。它还可以与数字签名检查一起使用，以确保没有人在另一个 APK 中窃取您精心隐藏的信息。
*   *加密:*加密还可以与 NDK 结合使用，以提供额外的防拆卸保护，或者作为向任何后端 web 服务器传递公钥和私钥信息的一种方式。

这些选项中的前四个仅起威慑作用(一些混淆器比另一些更好)，其余四个是有效的，但有其他含义。我将在本书的后面更详细地讨论它们。

### 总结

反编译是新 Android 程序员最好的学习工具之一。要了解如何编写 Android 应用，还有什么比从手机中取出一个例子并反编译成源代码更好的方法呢？当移动软件公司破产时，反编译也是一个必要的工具，修复代码的唯一方法就是自己反编译。但是，如果你试图保护无数小时的设计和开发投资，反编译也是一种威胁。

这本书的目的是创造关于反编译和源代码保护的对话——区分事实和虚构，并展示反编译 Android 应用有多容易，以及可以采取什么措施来保护代码。有些人可能会说反编译不是问题，开发人员总是可以被训练去阅读竞争对手的汇编程序。但是一旦允许轻松访问 Android 应用文件，任何人都可以下载 dex2jar 或 JD-GUI，反编译就会变得容易得多。不信？然后继续读下去，自己做决定。