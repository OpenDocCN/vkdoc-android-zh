## 第四章

## 贸易工具

本章着眼于黑客用来从 Android 包文件(APK)逆向工程底层源代码的一些工具和一些简单的技术。它还简要介绍了主要的开源和商业混淆器，因为混淆是保护源代码最流行的工具。此外，这一章涵盖了这些混淆器背后的理论，这样你就可以更好地了解你所购买的东西。

让我们从某人如何破解你的安卓 APK 文件开始这一章。这样，当您试图保护您的代码时，您可以开始避免一些最明显的陷阱。

### 下载 APK

多年来，Java 代码可以被反编译或逆向工程成与原始代码非常接近的东西已经不是什么秘密了。但自从浏览器小程序多年前失宠以来，这从来就不是一个棘手的问题。原因简单明了:准入。互联网上的大多数 Java 代码都存在于服务器上，而不是浏览器中。有些桌面应用是用 Java Swing 写的，比如 Corel 的 WordPerfect。但这些都是值得注意的例外，大多数 Java 代码位于防火墙后的 web 服务器上。所以，在你反编译它们之前，你必须侵入一个服务器来访问类文件。这是不太可能的情况；坦率地说，如果有人通过入侵你的服务器获得了对你的类文件的访问权，那么你有比他们反编译你的代码更糟糕的事情要担心。

但安卓手机不再是这样了。在第三章中，你看到了 Java 代码是如何被编译成一个`classes.dex`文件的。然后，`classes.dex`文件与所有其他资源(如图像、字符串、文件等)捆绑在一起，成为您的客户下载到他们手机上的 APK。你的安卓 app 是客户端；有了正确的知识，任何人都可以访问 APK，并最终访问您的代码。

有三种方法可以访问 APK:将它备份到 SD 卡上；通过互联网论坛；通过使用 Android SDK 自带的 Android 平台工具。这些选项将在以下章节中讨论。

#### 备份 APK

或许获得 APK 的最简单方法是使用备份工具将 APK 下载到微型 SD 卡上，以便以后在 PC 上检查。步骤如下:

1.  从 Android Market 下载并安装免费版的 ASTRO 文件管理器。
2.  将微型 SD 卡插入手机
3.  打开 ASTRO，按下手机上的菜单键。
4.  选择工具![Image](images/U001.jpg)应用管理器/备份。
5.  选中目标 APK 旁边的复选框，点击备份，参见[图 4-1](#fig_4_1) 。
6.  关闭 ASTRO 文件管理器。
7.  取出微型 SD 卡，并将其插入电脑。或者，如果你没有 SD 卡，把 APK 用电子邮件发给你自己。

![Image](images/9781430242482_Fig04-01.jpg)

**图 4-1。** *使用 ASTRO 文件管理器备份 APK*

#### 论坛

如果你正在寻找一个更受欢迎的 apk，它可能很容易在网上找到。比如`[http://forum.xda-developers.com](http://forum.xda-developers.com)`的 XDA 开发者论坛，就是开发者分享新旧 apk 的地方。

#### 平台工具

如果你开发 Android 应用程序，那么你更有可能想要使用 Android 平台工具来访问 APK。这是下载 APK 的简单方法，但只有当你获得了手机的 root 或管理员权限时，这就是所谓的*root*手机。以我不那么科学的观点来看，由于 Android 平台的开源性，Android 手机比 iPhones 或 Windows mobile 手机更容易被 root 或越狱。开源吸引了更多的开发者，他们通常想知道(或者如果他们有时间的话，可以选择知道)他们的手机是如何通过拆开软件或硬件来工作的。其他人可能只是想捆绑他们的手机，获得免费 Wi-Fi，这是运营商不鼓励的。

在 Android 上扎根很容易，谷歌早些时候就通过其解锁的 Nexus 手机系列鼓励了这一点。下一节将展示给手机找根是多么容易；我无法涵盖所有设备和 Android 版本，但它们都遵循相似的模式。找到一部手机最困难的事情往往是为你的设备找到正确的 USB 驱动程序。

请记住，给你的手机找根是有风险的。除其他外，这样做可能会使保修无效；因此，如果出现任何问题，你可能会留下一个死设备。

##### 窃听电话

有很多不同的选择，当谈到扎根你的手机。对你的手机来说，最好的方法取决于手机类型以及手机上运行的 Android 版本。最直接的方法是从 XDA 开发者论坛下载 Z4Root、SuperOneClick 或 Universal Androot Android 应用程序，并将其安装在手机上。有段时间，安卓市场有 Z4Root 但是，毫不奇怪，它和其他 apk 将根你的手机再也找不到了。

Z4Root 在运行 Android 2.2 (Froyo)的早期机器人上工作得很好，并使用 RageAgainstTheCage 病毒获得 Root 访问权限。这是谷歌在 Android 2.3(姜饼)中修复的。但是 GingerBreak 随后被开发出来，允许黑客进入运行 Gingerbread 的手机。随着 Superboot 现在可以获得 Android 4.0(冰淇淋三明治)手机的 root 访问权限，这种情况一直持续到今天。

我们来看看 Z4Root 在 Android 2.2.1 或者 Froyo 上是如何工作的。虽然是 Android 的早期版本，但在姜饼上使用 GingerBreak 或在冰淇淋三明治上使用 Honeycomb 或 Superboot 时，过程是相同的。

在 Android 2.2.1 手机上安装 Z4Root 的步骤如下:

1.  备份你的手机。
2.  从`[http://forum.xda-developers.com](http://forum.xda-developers.com)`下载 APK。如果你的电脑上有一个病毒扫描程序，它会弹出一条消息，说你下载了一个带有 RageAgainstTheCage 病毒的文件，这是 Z4Root 用来入侵手机的漏洞。
3.  将 APK 从您的计算机复制到 SD 卡上。
4.  将 SD 卡放入手机，使用 ASTRO 文件管理器安装 Z4Root。
5.  遵循 Z4Root 中的步骤，如图[图 4-2](#fig_4_2) 和 [4-3](#fig_4_3) 所示。在第一个屏幕上选择 Root 然后，选择临时根来根您的电话，直到您的电话重新启动，或选择永久根来保持根。Z4Root 对你的手机进行 Root 可能需要几分钟的时间，但是如果成功的话，设备会重新启动，手机也会被 root。

![Image](images/9781430242482_Fig04-02.jpg)

**图 4-2。** *Z4Root 安装*

![Image](images/9781430242482_Fig04-03.jpg)

**图 4-3。** *在 Z4Root 中选择一个临时或永久的根*

如果您在手机已经根化之后运行 Z4Root，它会为您提供取消根化手机的选项。这在你需要更换手机又不想让保修失效的情况下很有用(见[图 4-4](#fig_4_4) )。

![Image](images/9781430242482_Fig04-04.jpg)

**图 4-4** *使用 Z4Root* 禁用 root

Z4Root 使用的 RageAgainstTheCage 病毒会产生大量的 adb (Android Debug Bridge)进程，直到手机的进程数达到极限。Z4Root 杀死最后一个进程；然后，由于 Android 2.2.1 中的一个 bug，最后一个 adb 进程仍然以 root 身份运行，并且还允许 adb 在重启时以 root 身份运行，因此手机受到了威胁。

##### 安装和使用平台工具

要查看手机是否已经成功 rooted，需要从`[http://developer.android.com](http://developer.android.com)`开始安装 Android SDK。你可以在 SDK 的`platform-tools`和`tools`目录中找到很多好东西，包括达尔维克调试监控服务(DDMS ),它可以让你像一样调试手机，还可以截图；电话模拟器；以及 dedexer 工具，它可以帮助您查看`classes.dex`文件的内部。

前面简单提到的 adb 工具将你的电脑和手机连接起来。使用 adb，可以连接手机或平板电脑，从其命令行执行 Unix 命令；参见[清单 4-1](#list_4_1) ，使用 Windows 7 机器显示。如果运行`su`命令后得到`#`提示，如图所示，那么你的手机就成功 rooted 了。

**清单 4-1。** *扎根手机*

`C:\Users\godfrey>adb devices
List of devices attached
0A3A9B900A01F014 device
C:\Users\godfrey>adb shell
$ su
su
#`

连接到计算机的根电话使您可以轻松访问电话上的所有 apk。您可以通过使用 adb shell 在您的设备上为付费或受保护的应用程序执行命令`ls /data/app`或`ls /data/app-private`来找到您的目标 apps 参见[清单 4-2](#list_4_2) 。

**清单 4-2。** *寻找 APK 下载*

`c:\android\android-sdk\platform-tools>adb shell
$ su
# ls /data/app
com.apps.aaa.roadside-1.apk
com.pyxismobile.Ameriprise.ui.activity-1.zip
com.s1.citizensbank-1.zip
com.hungerrush.hungryhowies-1.apk
com.huntington.m-1.apk
com.netflix.mediaclient-1.apk
com.priceline.android.negotiator-1.apk
com.google.android.googlequicksearchbox-1.apk
# ls /data/app-private
com.s1.citizensbank-1.apk
com.pyxismobile.Ameriprise.ui.activity-1.apk`

如果您在`/data/app`目录中看到一个`.zip`文件，那么 APK 就在`/data/app-private`目录中。

退出 adb shell，从您的计算机命令行使用`adb pull`命令将 APK 复制到您的本地文件夹；参见[清单 4-3](#list_4_3) 。

**清单 4-3。** *使用`adb pull`命令*

`c:\android\android-sdk\platform-tools>adb pull
data/app/com.riis.mobile.apk`

### 反编译 APK

在第三章的[中，你看到了`classes.dex`的格式与 Java 类文件格式截然不同。但是目前没有`classes.dex`反编译器——只有 Java 类文件反编译器。你必须等到](03.html)[第 5 章](05.html)和[第 6 章](06.html)来构建你自己的反编译器。同时，您可以使用 dex2jar 将`classes.dex`转换回类文件。

dex2jar 是一个将 Android 的`.dex`格式转换成 Java 的`.class`格式的工具。它从一种二进制格式转换到另一种二进制格式，而不是转换到源代码。并且可以从`[http://code.google.com/p/dex2jar](http://code.google.com/p/dex2jar)`买到。一旦转换成类文件格式，仍然需要使用像 JD-GUI 这样的 Java 反编译器来查看 Java 源代码。

从命令行，在 APK 上运行以下命令:

`c:\temp>dex2jar com.riis.mobile.apk
c:\temp>jd-gui com.riis.mobile.apk.dex2jar`

或者，您可以使用 Ryszard winiewski 的 apktool，它从`[http://code.google.com/p/android-apktool](http://code.google.com/p/android-apktool)`开始提供。在 Windows 上，安装 apktool 后，你可以用鼠标右键反编译一个 APK。apktool 解压 APK，运行 baksmali(一个反汇编器)，使用 AXMLPrinter2 解码`AndroidManifest.xml`文件，使用 dex2jar 将`classes.dex`转换为 jar 文件，然后在 JD-GUI 中弹出 Java 代码。

#### APK 档案里有什么？

apk 是压缩格式的。您可以通过将扩展名改为`.zip`并使用您最喜欢的解压缩工具来解压缩文件。(许多工具，如 7-Zip，会识别出它是一个 Zip 文件，并在不需要改变扩展名的情况下将其压缩。)这样一个 zip 文件的内容如图[图 4-5](#fig_4_5) 所示。

![Image](images/9781430242482_Fig04-05.jpg)

**图 4-5。** *解压缩后的 APK 文件的内容*

`META-INF`目录包含一个`manifest.mf`或清单文件，其中包含所有文件的清单摘要。`cert.rsa`拥有用于签署文件的证书，`cert.sf`拥有 APK 的资源列表以及每个文件的 SHA-1 摘要。`res`目录包含所有的 APK 资源，比如 XML 布局定义文件和相关的图像，而`assets`包含图像和 HTML、CSS 和 JavaScript 文件。`AndroidManifest.xml`包含 APK 的名称、版本号和访问权限。这通常是二进制格式，需要使用 AXMLPrinter2 转换成可读格式。最后，您得到了包含编译后的 Java 类文件的`classes.dex`文件；和`resources.asrc`，它包含任何不在 resources 目录中的预编译资源。AXMLPrinter2 在`[http://code.google.com/p/android4me](http://code.google.com/p/android4me)`可用。[清单 4-4](#list_4_4) 展示了如何使用它来解码`AndroidManifest.xml`文件。

**清单 4-4。** *`AXMLPrinter2.jar`命令*

`java -jar AXMLPrinter2.jar AndroidManifest.xml >
AndroidManifest_decoded.xml`

清单 4-5 显示了一个使用 AXMLPrinter2 解码后的`AndroidManifest.` xml 文件。

**清单 4-5。** *解码`AndroidManifest.xml`*

`<?xml version="1.0" encoding="utf-8"?>
<manifest
xmlns:android="http://schemas.android.com/apk/res/android"
android:versionCode="1"
android:versionName="1.0"
package="com.riis.agile.agileandbeyond.android"
>
<application
android:label="@7F070000"` `android:icon="@7F020015"
android:name=".OpenSourceBridgeApplication"
android:debuggable="true"
>
<activity
android:theme="@android:01030006"
android:label="@7F070000"
android:name=".LaunchActivity"
>
<intent-filter
>
<action
android:name="android.intent.action.MAIN"
>
</action>
<category
android:name="android.intent.category.LAUNCHER"
>
</category>
</intent-filter>
</activity>
<activity
android:theme="@android:01030006"
android:label="@7F070000"
android:name=".ScheduleActivity"
>
</activity>
</application>
<uses-sdk
android:minSdkVersion="3"
>
</uses-sdk>
</manifest>`

APK 中可以有其他目录。如果该文件是一个 HTML5/CSS 应用程序，那么它将有一个包含 HTML 页面和 JavaScript 代码的资源库。如果 APK 使用其他 Java 库或本地库中的任何 C++代码，那么在一个`lib`文件夹中会有`.jar`和`.so`文件。

#### 随机 APK 问题

在我下载的 50 个随机样本中，只有 1 个有任何形式的保护。随着反编译 Android 代码的问题变得更好理解，这种情况可能会改变。本节概述了我在示例中遇到的一些问题。所有公司名称、web 服务 URL 和 API 密钥或登录信息都已被修改，以保护无辜者。

##### Web 服务密钥和登录

虽然许多 Android 应用程序是独立的，但许多是经典的客户端应用程序，通过网络服务密钥与后端系统通信。[清单 4-6](#list_4_6) 显示了反编译的源代码，带有生产 web 服务的 API 密钥以及帮助和支持信息。这可能还不足以侵入 web 服务，但它邀请黑客进一步探索 API。

**清单 4-6。** *暴露网络服务 API 键*

`public class PortalInfoBuilder
{
public static List a(Context paramContext)
{
ArrayList localArrayList = new ArrayList();
Boolean localBoolean = Boolean.valueOf(0);
PortalInfo localPortalInfo = new PortalInfo("Production",
"https://runapiportal.riis.com/portal.svc",
"d3IWwZ9TjkoNFtNYtwsLYM+gk/Q=", localBoolean);

localPortalInfo.b("https://support.riis.com/riis_payroll//%d/help.
htm");
localPortalInfo.c("http://www.riis.com/ /guided_tours.xml");
boolean bool = localArrayList.add(localPortalInfo);
return localArrayList;
}
}`

清单 4-7 显示了一个受用户名和密码保护的 API。但是通过反编译 APK，黑客可以访问 API 传输的任何信息。在这种情况下，API 不会检查浏览器是否来自移动设备，也不会检查信息是否来自网站。如果你的 API 提供的信息是有价值的，那么最好隐藏用户名和密码；在本章后面的“保护您的源代码”一节中，您会看到如何做到这一点。

**清单 4-7。** *暴露 API 用户名和密码*

`private String Digest(ArrayList<String> paramArrayList)
{
// setup
String str5 = "CB8F9322-0C1C-4B28A4:" + str2 + ":" +
"cxYacuzafrabru5a1beb";
String str7 = "POST:" + "https://www.riis.com/api/";
}`

[清单 4-8](#list_4_8) 显示了相同的用户名和密码，它们无缘无故地在一个配置文件中重复出现。在发布应用程序之前，请确保所有用户名和密码无论出现在哪里都得到妥善保护。

**清单 4-8。** *暴露 Web 服务用户名和密码*

`public static final String USER_NAME = ”CB8F9322-0C1C-4B28A4";
public static final String PASSWORD = " cxYacuzafrabru5a1beb";`

##### 数据库模式

另一个值得关注的领域是数据库，敏感信息通常存储在这里。反编译 APK 允许黑客看到存储在电话上的 SQLite 或其他数据库的数据库模式信息。许多 apk 将个人的信用卡信息存储在本地数据库中。获取这些数据可能需要有人偷你的手机或者制造一个安卓病毒，这种可能性不大；但还是那句话，这又是一条不该曝光的信息。

[清单 4-9](#list_4_9) 显示了一个电话应用程序的一些数据库模式信息，而[清单 4-10](#list_4_10) 显示了一个本地存储信用卡信息的 HTML5 应用程序的信息。

**清单 4-9。** *创建模式和数据库位置信息*

`public class DB` `{
public static final String ACTIVATION_CODE = "activationcode";
public static final String ALLOWEDIT = "allowedit";
private static final String ANYWHERE_CREATE = "create table %s
(_id integer primary key autoincrement, description text,
phoneNumber text not null, isActive text not null);";
private static final String ANYWHERE_TABLE = "anywhere";
private static final String AV_CREATE = "create table
SettingValues
(_id integer primary key autoincrement, keyname text not
null,
attribute text not null, value text not null);";
private static final String AV_TABLE = "SettingValues";
private static final String CALLCENTER_CREATE = "create table
callcenters
(_id integer primary key autoincrement, ServiceUserId text
not null,
Name text, PhoneNumber text, Extension text,
Available text not null, LogoffAllowed text not
null);";
private static final String DATABASE_NAME = "settings.db";` `private static final int DATABASE_VERSION = 58;
}`

**清单 4-10。** *存储信用卡信息*

`// ****************************** Credit Cards Table

api.createCustCC = function (email,name,obj){
var rtn=-1;
try{
api.open();
conn.execute('INSERT INTO CustomerCC (Email,CCInfo,Name)
VALUES(?,?,?)',email,JSON.stringify(obj),name);
rtn=conn.lastInsertRowId;
}`

##### HTML5/CSS

相当数量的 Android APKs 最初是用 HTML5/CSS 编写的。使用 PhoneGap 等工具，HTML5/CSS 文件被转换成 apk，然后上传到 Android market。这些应用中的 Java 代码是一个框架，它只是从 Android 框架中调用 HTML5 应用。解压缩 APK，你可以在`assets`文件夹中找到原始的 JavaScript。

有时 JavaScript 包含比 Java 源代码更危险的信息，因为在创建 APK 之前，注释通常不会被删除。使用 JavaScript 压缩器有助于解决这个问题(参见本章后面的“混淆器”一节)。

##### 假冒应用

反编译 apk 通常不会导致 100%的代码被逆向工程。dex2jar 经常无法将`classes.dex`完全转换成 Java jar 文件。但是通过一些努力，可以调整生成的 Java 源代码，使其重新编译成一个被窃取或劫持的 APK，然后以不同的名字重新提交到 Android market。还可以创建虚假应用程序，从银行应用程序或任何需要登录的应用程序中获取用户名和密码。

迄今为止，最著名的假冒应用是一个收集网飞账户信息的假冒网飞应用。这个特殊的例子没有使用任何反编译的代码，但是一个看起来像真正的应用程序的被劫持的应用程序将提供一个复杂的水平，将欺骗大多数人放弃登录信息。假冒应用程序也是将恶意软件上传到手机或设备的良好载体，几乎没有被检测到的机会，因为安卓市场没有预先批准。不过，请注意，Android Bouncer 这个奇妙的名字现在正在捕捉这些假冒的应用程序。

### 反汇编程序

如果你花时间在 Android 字节码上，你会逐渐注意到不同的模式和语言结构。通过练习和大量的耐心，字节码变成了另一种语言。

到目前为止，您已经看到了两个反汇编程序:dx，它是 Android SDK 的一部分；以及 DexToXML，它将`classes.dex`反汇编成一个 XML 结构。你在[第三章](03.html)中使用了 Android 的 dx 工具将`Casting.class`编译成`classes.dex`格式，但它也可以将`classes.dex`文件反汇编成文本。

让我们简单看一下 dx 输出和其他一些替代方案，看看它们是否比 DexToXML 更好。首先，不要忘记十六进制编辑器，它通常可以提供黑客需要的所有信息。

#### 十六进制编辑器

多年来，黑客一直使用十六进制编辑器和其他更复杂的工具，如 Numega 的 SoftICE 和最近的 Hex-Rays 的 IDA，来绕过各种软件的定时炸弹版本的许可计划。破解 20 世纪 80 年代末和 90 年代几乎每本电脑杂志上的游戏演示版是我的许多程序员同事的必经之路。

通常，程序员试图通过检查日期是否在安装日期之后 30 天来保护他们的游戏和实用程序。30 天后，评估版停止运行。如果你买不起真货，你可以在电脑上设置永久的时间，在评估期前几天。或者，如果你够聪明，你会意识到开发人员必须将安装日期存储在某个地方:如果你够幸运，它就在某个简单的地方，比如在`.ini`文件或注册表中，你可以将它永久地设置为某个遥远的未来日期，比如 1999 年。

当你差不多能读懂汇编程序时，通过仪式就真正完成了；设置断点以缩小安全功能的范围；找到检查评估日期的那段代码并禁用它，或者创建一个程序可以接受的序列号或密钥，这样评估副本就成为了该软件的一个功能完整的版本。

有无数更复杂的机制来保护更昂贵的程序；许多昂贵的 CAD 程序上使用的加密狗立即跃入脑海。通常，大多数保护机制除了防止普通人禁用或破解它们之外，没有什么作用。在 Java 世界中，攻击这种机制的工具是十六进制编辑器。

大多数程序员非但没有从过去吸取教训，反而注定要重蹈覆辙。绝大多数许可证保护的例子都依赖于像条件跳转这样简单的东西。在[清单 4-11](#list_4_11) 中，来自 Google 的修改后的样本代码展示了如何在 2012 年底终止一个演示。

**清单 4-11。** *定时炸弹试用 App 代码*

`if (new Date().after(new GregorianCalendar(2012,12,31).getTime()))
{
AlertDialog.Builder ad = new
AlertDialog.Builder(SomeActivity.this);
ad.setTitle("App Trial Expired");
ad.setMessage("Please download Full App from Android
Market.");
ad.setPositiveButton("Get from Market", new
DialogInterface.OnClickListener() {
public void onClick(DialogInterface dialog, int whichButton) {
Intent i = new Intent(Intent.ACTION_VIEW,
Uri.parse("http://market.android.com/search?q=pname:com.riis.app_f
ull"));
startActivity(i);
finish();
}
}).show();
}`

使用[第三章](03.html)中的信息可以找到 Android 字节码。然后快速浏览一下，使用十六进制编辑器将`after`更改为`before`，将试用版应用程序变成完整版。一些十六进制编辑器，如 IDA，使这变得非常简单；参见[图 4-6](#fig_4_6) 。

![Image](images/9781430242482_Fig04-06.jpg)

**图 4-6。** *IDA 十六进制编辑器*

#### dx 和 dexdump

Dx 是 Android SDK 的一部分，可以与 dexdump 一起在`platform-tools`目录中找到。带有 verbose 选项的 dx 命令可以完全分解任何一个`classes.dex`文件，如果你想看到`classes.dex`的内部，这是目前最好的反汇编程序。以下命令输出`classes.dex`的反汇编版本:编译`casting`目录下的`Casting.class`文件，输出`casting.dump`:

`dx --dex --verbose-dump --dump-to=c:\temp\casting.dump
c:\temp\casting`

[清单 4-12](#list_4_12) 显示了文件头部分的输出。

*清单 4-12。`classes.dex`* 标题段的 Dx 输出

`000000: 6465 780a 3033 |magic: "dex\n035\0"
000006: 3500 |
000008: 628b 4418 |checksum` `00000c: daa9 21ca 9c4f |signature
000012: b4c5 21d7 77bc |
000018: 2a18 4a38 0da2 |
00001e: aafe |
000020: 5004 0000 |file_size: 00000450
000024: 7000 0000 |header_size: 00000070
000028: 7856 3412 |endian_tag: 12345678
00002c: 0000 0000 |link_size: 0` `000030: 0000 0000 |link_off: 0
000034: a403 0000 |map_off: 000003a4
000038: 1a00 0000 |string_ids_size: 0000001a
00003c: 7000 0000 |string_ids_off: 00000070
000040: 0a00 0000 |type_ids_size: 0000000a
000044: d800 0000 |type_ids_off: 000000d8
000048: 0700 0000 |proto_ids_size: 00000007
00004c: 0001 0000 |proto_ids_off: 00000100
000050: 0300 0000 |field_ids_size: 00000003
000054: 5401 0000 |field_ids_off: 00000154
000058: 0900 0000 |method_ids_size: 00000009
00005c: 6c01 0000 |method_ids_off: 0000016c
000060: 0100 0000 |class_defs_size: 00000001
000064: b401 0000 |class_defs_off: 000001b4
000068: 7c02 0000 |data_size: 0000027c
00006c: d401 0000 |data_off: 000001d4`

Dexdump 是 Java 类文件反汇编器 javap 的 Android SDK 等价物。产生清单 4-13 中的输出的 dexdump 命令如下:

`dexdump -d -h classes.dex`

**清单 4-13。** *带反汇编文件头的普通 Dexdump 输出*

`Processing 'classes.dex'...
Opened 'classes.dex', DEX version '035'
Class #0 header:
class_idx : 2
access_flags : 1 (0x0001)
superclass_idx : 4
interfaces_off : 0 (0x000000)
source_file_idx : 3
annotations_off : 0 (0x000000)
class_data_off : 914 (0x000392)
static_fields_size : 2
instance_fields_size: 0
direct_methods_size : 2
virtual_methods_size: 0

Class #0 -
Class descriptor : 'LCasting;'` `Access flags : 0x0001 (PUBLIC)
Superclass : 'Ljava/lang/Object;'
Interfaces -
Static fields -
#0 : (in LCasting;)
name : 'ascStr'
type : 'Ljava/lang/String;'
access : 0x0018 (STATIC FINAL)` `#1 : (in LCasting;)
name : 'chrStr'
type : 'Ljava/lang/String;'
access : 0x0018 (STATIC FINAL)
Instance fields -
Direct methods -
#0 : (in LCasting;)
name : '<init>'
type : '()V'
access : 0x10001 (PUBLIC CONSTRUCTOR)
code -
registers : 1
ins : 1
outs : 1
insns size : 4 16-bit code units
0001d4: |[0001d4]
Casting.<init>:()V
0001e4: 7010 0300 0000 |0000: invoke-
direct {v0},
Ljava/lang/Object;.<init>:()V //
method@0003
0001ea: 0e00 |0003: return-void
catches : (none)
positions :
0x0000 line=1
locals :
0x0000 - 0x0004 reg=0 this LCasting;

#1 : (in LCasting;)
name : 'main'
type : '([Ljava/lang/String;)V'
access : 0x0009 (PUBLIC STATIC)
code -
registers : 5
ins : 1
outs : 2
insns size : 44 16-bit code units
0001ec: |[0001ec]
Casting.main:([Ljava/lang/String;)V
0001fc: 1200 |0000: const/4 v0,
#int 0 // #0` `0001fe: 1301 8000 |0001: const/16 v1,
#int 128 // #80
000202: 3510 2800 |0003: if-ge v0,
v1, 002b // +0028
000206: 6201 0200 |0005: sget-object
v1, Ljava/lang/System;.out:Ljava/io/PrintStream; // field@0002
00020a: 2202 0600 |0007: new-instance
v2, Ljava/lang/StringBuilder; // type@0006` `00020e: 7010 0400 0200 |0009: invoke-
direct {v2}, Ljava/lang/StringBuilder;.<init>:()V // method@0004
000214: 1a03 1400 |000c: const-string
v3, "ascii " // string@0014
000218: 6e20 0700 3200 |000e: invoke-
virtual {v2, v3},
Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/St
ringBuilder; // method@0007
00021e: 0c02 |0011: move-result-
object v2
000220: 6e20 0600 0200 |0012: invoke-
virtual {v2, v0},
Ljava/lang/StringBuilder;.append:(I)Ljava/lang/StringBuilder; //
method@0006
000226: 0c02 |0015: move-result-
object v2
000228: 1a03 0000 |0016: const-string
v3, " character " // string@0000
00022c: 6e20 0700 3200 |0018: invoke-
virtual {v2, v3},
Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/St
ringBuilder; // method@0007
000232: 0c02 |001b: move-result-
object v2
000234: 6e20 0500 0200 |001c: invoke-
virtual {v2, v0},
Ljava/lang/StringBuilder;.append:(C)Ljava/lang/StringBuilder; //
method@0005
00023a: 0c02 |001f: move-result-
object v2
00023c: 6e10 0800 0200 |0020: invoke-
virtual {v2},
Ljava/lang/StringBuilder;.toString:()Ljava/lang/String; //
method@0008
000242: 0c02 |0023: move-result-
object v2
000244: 6e20 0200 2100 |0024: invoke-
virtual {v1, v2},
Ljava/io/PrintStream;.println:(Ljava/lang/String;)V // method@0002
00024a: d800 0001 |0027: add-int/lit8
v0, v0, #int 1 // #01` `00024e: 8e00 |0029: int-to-char
v0, v0
000250: 28d7 |002a: goto 0001 //
-0029
000252: 0e00 |002b: return-void
catches : (none)
positions :
0x0000 line=8` `0x0005 line=9
0x0027 line=8
0x002b line=11
locals :

Virtual methods -
source_file_idx : 3 (Casting.java)`

#### 驱动剂

Dedexer 是来自匈牙利工程师 Gabor Paller 的开源反汇编工具。在`[http://dedexer.sourceforge.net](http://dedexer.sourceforge.net)`有售。Dedexer 是 dx 的优秀替代产品。[清单 4-14](#list_4_14) 显示了执行以下命令后的 Dedexer `dex.log`输出文件:

`java -jar ddx1.18.jar -o -d c:\temp casting\classes.dex`

**清单 4-14。** *Dedexer 头段输出*

`00000000 : 64 65 78 0A
30 33 35 00
magic: dex\n035\0
00000008 : 62 8B 44 18
checksum
0000000C : DA A9 21 CA
9C 4F B4 C5
21 D7 77 BC
2A 18 4A 38
0D A2 AA FE
signature
00000020 : 50 04 00 00
file size: 0x00000450
00000024 : 70 00 00 00
header size: 0x00000070
00000028 : 78 56 34 12
00 00 00 00
link size: 0x00000000
00000030 : 00 00 00 00` `link offset: 0x00000000
00000034 : A4 03 00 00
map offset: 0x000003A4
00000038 : 1A 00 00 00
string ids size: 0x0000001A
0000003C : 70 00 00 00
string ids offset: 0x00000070
00000040 : 0A 00 00 00
type ids size: 0x0000000A
00000044 : D8 00 00 00` `type ids offset: 0x000000D8
00000048 : 07 00 00 00
proto ids size: 0x00000007
0000004C : 00 01 00 00
proto ids offset: 0x00000100
00000050 : 03 00 00 00
field ids size: 0x00000003
00000054 : 54 01 00 00
field ids offset: 0x00000154
00000058 : 09 00 00 00
method ids size: 0x00000009
0000005C : 6C 01 00 00
method ids offset: 0x0000016C
00000060 : 01 00 00 00
class defs size: 0x00000001
00000064 : B4 01 00 00
class defs offset: 0x000001B4
00000068 : 7C 02 00 00
data size: 0x0000027C
0000006C : D4 01 00 00
data offset: 0x000001D4
00000070 : 72 02 00 00`

#### 巴克斯马利

*Backsmali* 在冰岛语中是*拆卸器*的意思，延续了与 Dalvik 虚拟机相关的名称的冰岛语主题，你可能记得这是以一个冰岛村庄命名的，最初的程序员之一(丹·博恩施泰因)的祖先就来自那里。Baksmali 是由一个叫 JesusFreke 的人写的，可以在`[http://code.google.com/p/smali](http://code.google.com/p/smali)`和 *smali* 一起获得，后者在冰岛语中是*汇编器*。[清单 4-15](#list_4_15) 显示了执行以下命令时`classes.dex`的 baksmali 输出:

`java -jar baksmali-1.3.2.jar -o c:\temp casting\classes.dex`

**清单 4-15。**T3`Casting.smali`T4】

`.class public LCasting;
.super Ljava/lang/Object;
.source "Casting.java"

# static fields
.field static final ascStr:Ljava/lang/String; = "ascii "

.field static final chrStr:Ljava/lang/String; = " character "` `# direct methods
.method public constructor <init>()V
.registers 1

.prologue
.line 1
invoke-direct {p0}, Ljava/lang/Object;-><init>()V

return-void
.end method

.method public static main([Ljava/lang/String;)V
.registers 5
.parameter

.prologue
.line 8
const/4 v0, 0x0

:goto_1
const/16 v1, 0x80

if-ge v0, v1, :cond_2b

.line 9
sget-object v1, Ljava/lang/System;->out:Ljava/io/PrintStream;

new-instance v2, Ljava/lang/StringBuilder;

invoke-direct {v2}, Ljava/lang/StringBuilder;-><init>()V

const-string v3, "ascii "

invoke-virtual {v2, v3}, Ljava/lang/StringBuilder;-
>append(Ljava/lang/String;)Ljava/lang/StringBuilder;`  `move-result-object v2

invoke-virtual {v2, v0}, Ljava/lang/StringBuilder;-
>append(I)Ljava/lang/StringBuilder;

move-result-object v2

const-string v3, " character "

invoke-virtual {v2, v3}, Ljava/lang/StringBuilder;-
>append(Ljava/lang/String;)Ljava/lang/StringBuilder;

move-result-object v2

invoke-virtual {v2, v0}, Ljava/lang/StringBuilder;-
>append(C)Ljava/lang/StringBuilder;

move-result-object v2

invoke-virtual {v2}, Ljava/lang/StringBuilder;-
>toString()Ljava/lang/String;

move-result-object v2

invoke-virtual {v1, v2}, Ljava/io/PrintStream;-
>println(Ljava/lang/String;)V

.line 8
add-int/lit8 v0, v0, 0x1

int-to-char v0, v0

goto :goto_1

.line 11
:cond_2b
return-void
.end method`

### 反编译程序

自 20 世纪 90 年代初以来，至少已经发布了十几个反编译器:Mocha、WingDis、Java 优化和反编译环境(JODE)、SourceAgain、DejaVu、Jad、Homebrew、JReveal、DeCafe、JReverse、jAscii 和 JD-GUI。还有许多程序——例如 Jasmine 和 NMI——为命令行受损者提供了 Jad 或 Mocha 的前端。有些，比如最著名的摩卡，已经过时了；而且除了 JD-GUI 和 Jad 之外的大部分反编译器都已经不可用了。下面的章节回顾了其中的一些。

#### 摩卡

许多最早的反编译器早就消失了；Jive 甚至从未见过天日。摩卡的一生，就像它的作者汉彼得·范·弗利特一样，是短暂的。1996 年 6 月的最初测试版有一个姊妹程序 Crema，售价 39 美元；它保护类文件不被 Mocha 使用混淆反编译。

作为最早的反编译器之一，Mocha 是一个简单的命令行工具，没有前端 GUI。它使用 JDK 1.02，并作为类的 zip 文件分发，这些类被 Crema 混淆。Mocha 能够识别和忽略被 Crema 混淆的类文件。毫不奇怪，Mocha 不支持 jar 文件，因为在最初编写 Mocha 时它们还不存在。和所有早期的反编译器一样，Mocha 不能反编译内部类，这只出现在 JDK 1.1 中。

要使用 Mocha 反编译文件，请确保`mocha.zip`文件在您的类路径中，并使用以下命令反编译:

`java mocha.Decompiler [-v] [-o] Casting.class`

反编译器只是作为测试版发布；它的作者在把它变成你所说的生产质量之前就过早地死去了。Mocha 的流分析是不完整的，它在许多 Java 构造上都失败了。过去有几个人试图修补 Mocha，但这些努力基本上都白费了。现在使用 JD-GUI 或 Jad 更有意义。

就在他 34 岁死于癌症之前，汉彼得把摩卡和克莉玛的代码卖给了博兰；一些 Crema 混淆代码被加入到 JBuilder 的早期版本中。就在 1996 年新年前夜 Hanpeter 去世几周后，Mark LaDue 的 HoseMocha 出现了，它允许任何人保护他们的文件不被 Mocha 反编译，而不必支付 Crema。

#### 杰德

Jad 快速、免费且非常有效，是第一批正确处理内部类的反编译器之一。这是帕维尔·库兹涅佐夫的作品，他毕业于莫斯科国立航空学校应用数学系，杰德获释时他住在塞浦路斯。它可以从`[www.varaneckas.com/jad](http://www.varaneckas.com/jad)`获得，并且可能是本章中使用的最简单的命令行工具。

Jad 的最新可用版本是 2001 年的 v1.58。根据 FAQ，主要的已知错误是它不能很好地处理内联函数；这应该不是问题，因为大多数编译器都让 JIT 引擎来执行内联。

在大多数情况下，您需要做的只是键入以下内容:

`jad target.class`

对于一个人的表演来说，Jad 是非常完整的。它最有趣的特性是，它可以用类文件的字节码的相关部分来注释源代码，这样您就可以看到反编译代码的每一部分来自哪里。这是理解字节码的一个很好的工具；清单 4-16 显示了一个例子。

**清单 4-16。** *`Casting.class`被贾德反编译*

`// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3)
// Source File Name: Casting.java

import java.io.PrintStream;

public class Casting
{

public Casting()
{
}

public static void main(String args[])
{
for(char c = '\0'; c < 128; c++)
System.out.println((new StringBuilder()).append("ascii
").append(c).append(" character ").append(c).toString());`  `}

static final String ascStr = "ascii ";
static final String chrStr = " character ";
}`

#### JD-GUI

在 2012 年，JD-GUI 是事实上的 Java 反编译器。这是巴黎的 Emmanual Dupuy 写的，可从`[http://java.decompiler.free.fr](http://java.decompiler.free.fr)`开始获得。

拖放您的 Java 类文件，它们会立即被反编译。JD-GUI 还有一个 eclipse 插件 JD-Eclipse，以及一个可以与其他应用程序集成的核心库。

JD-GUI 是为 JDK 1.5 编写的，并且具有到目前为止的所有现代构造。它还可以无缝地处理 jar 文件。图 4-7 显示了运行中的 JD-GUI。

![Image](images/9781430242482_Fig04-07.jpg)

**图 4-7。** *`Casting.class`被 JD-GUI 反编译*

#### dex2jar

Dex2jar 是一个把 Android 的`.dex`格式转换成 Java 的`.class`格式的工具——只是把一种二进制格式转换成另一种二进制格式，而不是转换成 Java 源码。您仍然需要对生成的 jar 文件运行 Java 反编译器来查看源代码。Dex2jar 可从`[http://code.google.com/p/dex2jar/](http://code.google.com/p/dex2jar/)`获得，作者是潘晓波，浙江科技大学毕业生，目前在中国一家计算机安全公司工作。

Dex2jar 并不完美:它无法转换`classes.dex`文件中大量的方法。但是如果没有 dex2jar 和 undx(见下一节)，就不会有任何 Android 反编译。

要将 APK 文件转换为 jar 文件以便进一步反编译，请运行以下命令:

`c:\temp>dex2jar com.riis.mobile.apk
c:\temp>jd-gui com.riis.mobile.apk.dex2jar`

#### undx

Undx 是另一个鲜为人知的 DEX 文件到类文件的转换器。它最初是由 Marc Schoenefeld 在 2009 年写的，并在 `[www.illegalaccess.org](http://www.illegalaccess.org)`可用。它现在似乎是一个死项目，并且早于 Android SDK 文件夹中的 dexdump 从`tools`移动到`platform-tools`目录。

#### apktool

Apktool 是反编译器的一个可怕的补充。安装完成后，鼠标右键将解压 APK，运行 baksmali，然后运行 AXMLPrinter2 和 dex2jar，并启动 JD-GUI——它完全自动化了反编译 APK 的过程。这使得反编译过程从艺术变成了鼠标点击，并允许任何能安装 ASTRO 文件管理器的人都能看到 APK 的源代码。Apktool 从`[http://code.google.com/p/android-apktool/](http://code.google.com/p/android-apktool/)`开始可用。

### 保护您的信息来源

既然您已经理解了这个问题，并且已经看到了 dex2jar 和 JD-GUI 的有效性，那么您可能想知道是否有任何方法可以保护代码。如果你想问为什么你应该写 Android 应用程序，这是适合你的部分。

下面这段话有助于解释我所说的保护你的消息来源是什么意思:

> 我们希望通过使逆向工程在技术上变得如此困难，以至于变得不可能或者至少在经济上不可行，来保护代码。

—克里斯蒂安·科尔伯格、克拉克·汤普森和道格拉斯·洛 <sup>[1](#CH-4-FN-1)</sup>

你可能涉足两个阵营之一:程序员可能对理解其他人如何实现有趣的效果感兴趣，但是从商业的角度来看，没有人希望其他人将他们的代码作为自己的代码卖给第三方。更糟糕的是，在某些情况下，反编译 Android 代码可以让某人通过访问后端 web 服务 API 来攻击系统的其他部分。

__________

1“混淆转换的分类”，计算机科学技术报告 148 (1997)，`[https://researchspace.auckland.ac.nz/handle/2292/3491](https://researchspace.auckland.ac.nz/handle/2292/3491)`。

你在前面的章节中已经看到，出于多种原因，Android `classes.dex`文件包含了异常大量的符号信息。正如您所看到的，没有受到某种保护的 DEX 文件返回的代码几乎与原始代码相同——当然，除了完全没有程序员注释之外。这一节介绍了限制 dex 文件中的信息量并使反编译程序的工作尽可能困难的步骤。

理想的解决方案是一个黑盒应用程序，它将一个 DEX 文件作为输入，输出一个等效的受保护版本。不幸的是，到目前为止，还没有什么可以提供完全的保护。

很难定义评估每个当前可用保护策略的标准。但是您可以使用以下三个标准来衡量每种工具或技术的有效性:

*   反编译器(效能)有多混乱？
*   它能击退所有反编译的企图吗(弹性)？
*   应用程序开销(成本)是多少？

如果代码的性能严重下降，那么代价可能太高了。或者，如果您使用 web 服务将代码转换为服务器端代码，那么这将比独立应用程序产生更大的持续成本。

让我们看看市场上可用的开源和商业混淆器及其他工具，以及它们在保护您的代码方面有多有效。第 1 章介绍了保护你的代码的合法手段。以下是保护您的 Android 源代码的技术方法列表:

*   编写两个版本的 Android 应用程序
*   困惑
*   Web 服务和服务器端执行
*   给你的代码加指纹
*   本地方法

#### 编写两个版本的 Android 应用程序

软件业的标准营销实践，尤其是在网络上，是允许用户下载软件的全功能评估副本，该软件在一定时间或使用次数后停止工作。这个先试后买系统背后的理论是，在规定的时间后，比如说 30 天，用户已经习惯了你的程序，他们很乐意为完整版本付费。

但是大多数软件开发者都意识到这些完整版的评估程序是一把双刃剑。它们展示了程序的全部功能，但通常很难保护，不管你说的是什么语言。在本章的前面，您已经看到了十六进制编辑器是如何方便地通过许可方案，无论是用 C++、Visual Basic 还是 Java 编写的。

采用了许多不同类型的保护方案，但是在 Java 世界中，您只有一个非常简单的保护工具:

`if boolean = true
execute
else
exit`

这些类型的方案自从第一次出现在 VB 共享软件中就被破解了。通过将十六进制编辑器中的一位翻转为

`if boolean = false
execute
else
exit`

如果能编写一个演示小程序或应用程序，让潜在客户体验一下产品，而又不赠送商品，那该有多好。考虑通过删除除基本功能外的所有功能，而只保留菜单选项来削弱演示。如果这太多，那么考虑使用第三方供应商，如 WebEx 或 Citrix，这样潜在客户就可以看到您的应用程序，但永远没有机会运行它来对抗反编译程序。

当然，这并不能阻止任何人在购买完整功能版本后反编译该版本，删除任何许可方案，然后将应用程序转让给其他第三方。但是他们将不得不为此付出代价，而且通常这足以成为黑客在别处寻找的障碍。

#### 混淆

十几个 Java 混淆器已经出现了。这种技术的大多数早期版本现在很难找到。如果你足够努力的话，你仍然可以在网上找到它们的踪迹，但是除了一两个明显的例外，Java 混淆器大部分已经变得默默无闻了。

这留下了一个有趣的问题，如何辨别剩下的几个混淆器是否有用。也许最初的混淆器中一些非常有用的东西已经丢失了，这些东西本来可以保护你的代码，但在市场变得更糟时却不能坚持足够长的时间。你需要理解混淆是什么意思，因为否则你没有办法知道一个混淆器是否比另一个更好(除非市场需求是你的决定因素)。

> 当混淆被宣布为非法时，只有不法之徒才会使用 sifjdifdm wofiefiemf eifm。

—Paul Tyma，抢先软件公司

这一部分着眼于混淆理论。我将借用科尔伯格、汤普森和洛的观点来帮助阐明我的立场。在他们的论文中，作者将混淆分为三个不同的领域:

*   布局混淆
*   控制混淆
*   数据混淆

[表 4-1](#tab_4_1) 列出了一个合理完整的混淆集合，分为这三种类型，在某些情况下还会进一步分类。表中省略了文章中一些对 Java 特别无效的转换类型。

![Image](images/tab0401.jpg)

![Image](images/tab0401a.jpg)

![Image](images/tab0401b.jpg)

大多数 Java 混淆器只执行布局混淆，有一些有限的数据和控制混淆。这部分是由于 Java 验证过程丢弃了任何非法的字节码语法。如果你主要写小程序，Java 验证器是非常重要的，因为远程代码总是被验证的。如今，当小程序越来越少时，Java 混淆器没有采用更高级的混淆技术的主要原因是混淆后的代码必须在各种 Java 虚拟机(JVM)上工作。

尽管 JVM 规范定义得很好，但是每个 JVM 对规范都有自己的略微不同的解释，这导致了在 JVM 如何处理不再由 Java 源代码表示的字节码时有许多特殊之处。JVM 开发人员不太注意测试这种类型的字节码，您的客户对字节码的语法是否正确不感兴趣——他们只想知道为什么它不能在他们的平台上运行。

请记住，在高级形式的模糊处理中有一定程度的走钢丝——我称之为*高级模式模糊处理*——所以你需要非常小心这些程序会对你的字节码做什么。模糊处理越激烈，代码就越难被反编译，但是就越有可能使 DVM 崩溃。

最好的混淆器在不破坏 DVM 的情况下执行多次转换。毫不奇怪，混淆公司在谨慎方面犯了错误，这不可避免地意味着对你的源代码的保护更少。

##### 布局混淆

大多数混淆器的工作原理是模糊变量名或打乱类文件中的标识符，试图使反编译的源代码无用。正如你在[第 3 章](03.html)中看到的，这并不能阻止字节码的执行，因为 DEX 文件使用指向数据段中的方法名和变量的指针，而不是实际的名称。

混淆代码通过使用自动生成的垃圾变量重命名常量池中的变量，同时保持代码语法正确，从而破坏了反编译器的源代码输出。然后，这在 DEX 文件的数据部分结束。实际上，这个过程消除了程序员在给变量命名时给出的所有线索(大多数优秀的程序员选择有意义的变量名)。这也意味着，由于重名，反编译的代码在重新编译之前需要一些返工。

无论有没有变量名的提示，大多数有能力的程序员都可以通过混乱的代码。通过适当的关心和注意，也许借助于剖析器来理解程序流，也许借助于反汇编器来重命名变量，大多数混淆的代码都可以被改回更容易处理的东西，不管混淆有多严重。

早期的混淆器如 JODE 用`a`、`b`、`c`、`d`代替了方法名...`z()`。Crema 的标识符更加难以理解，使用类似 Java 的关键字来迷惑读者(见[清单 4-17](#list_4_17) )。其他几个混淆器更进了一步，使用了 Unicode 风格的名称，这有一个很好的副作用，使许多现有的反编译器崩溃。

**列表 4-17。** *克丽玛保护码*

`private void _mth015E(void 867 % static 931){
void short + = 867 % static 931.openConnection();
short +.setUseCaches(true);
private01200126013D = new DataInputStream(short
+.getInputStream());
if(private01200126013D.readInt() != 0x5daa749)
throw new Exception("Bad Pixie header");
void do const throws = private01200126013D.readShort();
if(do const throws != 300)
throw new Exception("Bad Pixie version " + do const
throws);
_fld015E = _mth012B();
for = _mth012B();
_mth012B();
_mth012B();
_mth012B();` `short01200129 = _mth012B();
_mth012B();
_mth012B();
_mth012B();
_mth012B();
void |= = _mth012B();
_fld013D013D0120import = new byte[|=];
void void = |= / 20 + 1;
private = false;
void = = getGraphics();
for(void catch 11 final = 0; catch 11 final < |=;){
void while if = |= - catch 11 final;
if(while if > void)
while if = void;
private01200126013D.readFully(_fld013D013D0120import,
catch 11 final, while if);
catch 11 final += while if;
if(= != null){
const = (float)catch 11 final / (float)|=;
=.setColor(getForeground());
=.fillRect(0, size().height - 4, (int)(const *
size().width), 4);
}
}
}`

大多数混淆器在减少类文件的大小方面比保护源代码要好得多。但是抢先软件拥有一项专利，它打破了原始源代码和混淆代码之间的联系，并在一定程度上保护了您的代码。所有的方法都被重命名为`a`、`b`、`c`、`d`等等。但是与其他程序不同，PreEmptive 使用运算符重载来重命名尽可能多的方法。重载的方法有相同的名字，但是参数的数量不同，所以不止一个方法可以被重命名`a()`:

`getPayroll() becomes a()
makeDeposit(float amount) becomes a(float a)
sendPayment(String dest) becomes a(String a)`

清单 4-18 中的[显示了抢占式的一个例子。](#list_4_18)

**清单 4-18。** *运算符重载*

`// Before Obfuscation

private void calcPayroll(RecordSet rs) {

while (rs.hasMore()) {
Employee employee = rs.getNext(true);` `employee.updateSalary();
DistributeCheck(employee);
}
}

// After Obfuscation

private void a(a rs) {

while (rs.a()) {
a = rs.a(true);
a.a();
a(a);
}
}`

给不同的方法取多个名字可能会非常混乱。的确，重载的方法很难理解，但也不是不可能理解。它们也可以被重新命名，以便于阅读。话虽如此，运算符重载已被证明是最好的布局混淆技术之一，因为它打破了原始代码和混淆后的 Java 代码之间的联系。

##### 控制混淆

控制混淆背后的概念是通过分解源代码的控制流来迷惑任何查看反编译源代码的人。属于一起的功能块被分开，不属于一起的功能块被混合在一起，使得源代码更加难以理解。

科尔伯格等人的论文将控制混淆进一步分为三类:*计算、聚合*和*排序*。让我们更详细地看看这些混淆或转换中最重要的一些。

###### 计算混淆

让我们看看计算混淆，它试图隐藏控制流，并加入额外的代码来迷惑黑客。

**(1)插入死代码或无关代码**

您可以插入死代码或伪代码来迷惑攻击者；它可以是额外的方法，或者仅仅是几行不相关的代码。如果您不希望您的原始代码的性能受到影响，那么以一种永远不会被执行的方式添加代码。但是要小心，因为许多反编译器甚至混淆器会删除那些永远不会被调用的代码。

不要把自己局限于插入 Java 代码——没有理由不能插入不相关的字节码。Mark Ladue 编写了一个名为 HoseMocha 的小程序，通过在每个方法的末尾添加一个`pop`字节码指令来修改类文件。就大多数 JVM 而言，这条指令是不相关的，被忽略了。但是摩卡处理不了，崩溃了。毫无疑问，如果摩卡的作者活了下来，这个问题很容易解决，但他没有。

**(2)扩展循环条件**

您可以通过使循环条件变得更加复杂来混淆代码。通过用第二个或第三个不做任何事情的条件来扩展循环条件，可以做到这一点。它不应该影响循环执行的次数或降低性能。尝试在扩展条件中使用 bitshift 或`?`操作符来增加一些趣味。

**(3)将可约转化为不可约**

混淆的圣杯是创建无法转换回原始格式的混淆代码。为此，您需要断开字节码和原始 Java 源代码之间的链接。混淆器将字节码控制流从原始的可约流转换成不可约的流。因为 Java 字节码在某些方面比 Java 更有表现力，所以可以使用 Java 字节码`goto`语句来帮助。

让我们重温一句古老的计算格言，它指出使用`goto`语句是任何自以为是的计算机程序员所犯下的最大罪过。埃德格·w·迪克斯特拉的论文“去发表被认为有害的声明”([http://dl.acm.org/citation.cfm?doid=362929.362947](http://dl.acm.org/citation.cfm?doid=362929.362947))是这种特殊宗教狂热的开端。反`goto`声明阵营在其全盛时期产生了足够多的反*-*`goto`情绪，足以将它与最好的 iPhone 与 Android 之战相提并论。

常识告诉我们，在某些有限的情况下使用`goto`语句是完全可以接受的。例如，您可以使用`goto`来替换 Java 使用`break`和`continue`语句的方式。问题在于使用`goto`来跳出一个循环，或者让两个`goto`语句在同一个范围内操作。您可能见过也可能没见过，但是字节码广泛使用了`goto`语句作为控制代码流的手段。但是两个`goto`T10 的作用域从不交叉。清单 4-18 中的 Fortran 语句说明了一个`goto`语句脱离控制循环。

**清单 4-18。** *使用`goto`语句*中断控制循环

`do 40 i = 2,n
if(dx(i).le.dmax) goto 50
dmax = dabs(dx(i))
40 continue
50 a = 1`

反对使用这种类型的编码风格的一个主要论点是，它几乎不可能对程序的控制流进行建模，并且给程序引入了任意性——从定义上来说，这几乎是一种灾难。控制流已经变成*不可约*。

作为一种标准的编程技术，尝试这样做是一个非常糟糕的想法，因为它不仅可能引入不可预见的副作用——不再可能将流减少到单个流图中——而且还会使代码变得难以管理。

但是有一种观点认为这是保护字节码的完美工具，如果你能假设编写保护工具来产生非法的`goto`的人知道他们在做什么，并且不会引入任何讨厌的副作用。这无疑使得字节码更难逆向工程，因为代码流确实变得不可约了；但是重要的是，添加的任何新构造都要尽可能与原始构造相似。

在我结束这个话题之前，我要提出几点警告。尽管传统的模糊类文件几乎肯定在功能上与它的原始对应物是相同的，但重新排列的版本就不一样了。你必须非常信任这个保护工具，否则它会因为奇怪的间歇性行为而受到指责。如果可能，总是在目标设备上测试转换后的代码。

**(4)添加冗余操作数**

另一种方法是在一些基本计算中加入额外的无关紧要的项，并在使用结果之前对结果进行四舍五入。例如，[清单 4-19](#list_4_19) 中的代码打印“k = 2”。

**清单 4-19。**冗余操作数前的*前的*

`import java.io.*;

public class redundantOperands {
public static void main(String argv[]) {
int i=1;
int j=2;
int k;`  `k = i * j;
System.out.println("k = " + k);
}
}`

给代码添加一些冗余的操作数，如[清单 4-20](#list_4_20) 所示，结果会完全一样，因为你在打印之前把`k`转换成了整数。

**清单 4-20。** *冗余操作数后*

`import java.io.*;

public class redundantOperands {

public static void main(String argv[]) {
int i = 1, j = 2;
double x = 0.0007, y = 0.0006, k;

k = (i * j) + (x * y);
System.out.println(" k = " + (int)k);
}
}`

**(5)去掉编程习惯用语(或者写马虎的代码)**

大多数优秀的程序员在其职业生涯中积累了大量的知识。为了提高生产率，他们一遍又一遍地使用相同的组件、方法、模块和类，每次的方式都略有不同。就像潜移默化一样，一种新的语言逐渐进化，直到每个人都决定用或多或少相同的方式做一些事情。Martin Fowler 等人的书*Refactoring:Improving the Design of Existing Code*(Addison-Wesley，1999 年)是一部优秀的收集现有代码并对其进行重构的技术的书。

但是这种类型的语言标准化创造了一系列的习惯用法，给了黑客太多有用的提示，即使他们只能反编译你的部分代码。因此，扔掉你所有的编程知识，停止使用你知道已经被许多其他程序员借用的设计模式或类，并且*破坏*你现有的代码。

编写草率的代码，或者篡改代码，是很容易的。这是一种异端的方法，它让我恼火，并最终影响代码的性能和长期维护，但如果您使用某种自动化的篡改工具，它可能会工作得很好。

**(6)并行化代码**

将代码转换为线程会显著增加其复杂性。代码不一定是线程兼容的，正如你在清单 4-21 的[中的`HelloThread`例子中看到的。控制流程已经从顺序模式转变为准并行模式，每个线程负责打印不同的单词。](#list_4_21)

**清单 4-21。** *添加线程*

`import java.util.*;

public class HelloThread extends Thread
{
private String theMessage;

public HelloThread(String message) {
theMessage = message;
start();
}

public void run() {
System.out.println(theMessage);
}

public static void main(String []args)
{
new HelloThread("Hello, ");
new HelloThread("World");
}
}`

这种方法的缺点是，要确保线程计时正确以及任何进程间通信都正常工作，以使程序按预期执行，这涉及到编程开销。有利的一面是，在现实世界的例子中，可能需要很长时间才能意识到代码可以折叠成一个顺序模型。

###### 聚合混淆

在聚合混淆中，你把应该在一起的代码分开。您还可以合并通常或逻辑上不属于一起的方法。

**(1)内联和概述方法**

内联方法——用方法的实际主体替换每个方法调用——通常用于优化代码，因为这样做消除了调用的开销。在 Java 代码中，这有使代码膨胀的副作用，常常使代码变得更难理解。您还可以通过创建一个虚拟方法来扩充代码，该方法采用一些内联方法并将它们概括成一个虚拟方法，该方法看起来像是被调用了，但实际上并不做任何事情。

Mandate 的 OneClass obfuscator 将这种转换发挥到了极致，它将应用程序中的每个类内联到一个 Java 类中。但是像所有早期的混淆工具一样，OneClass 已经不复存在了。

**(2)交错方法**

尽管交替使用两种方法是一项相对简单的任务，但是将它们分开要困难得多。清单 4-22 显示了两个独立的方法；在[清单 4-23](#list_4_23) 中，我将代码交错在一起，这样方法看起来是连接的。这个例子假设您想要显示余额并通过电子邮件发送发票，但是没有理由不允许您通过电子邮件发送发票。

**清单 4-22。***`showBalance``emailInvoice`*

`void showBalance(double customerAmount, int daysOld) {
if(daysOld > 60) {
printDetails(customerAmount * 1.2);
} else {
printDetails(customerAmount);
}
}
void emailInvoice(int customerNumber) {
printBanner();
printItems(customerNumber);
printFooter();
}`

**清单 4-23。**T3`showBalanceEmailInvoice`T4】

`void showBalanceEmailInvoice(double customerAmount, int daysOld,
int customerNumber) {` `printBanner();
if(daysOld > 60) {
printItems(customerNumber);
printDetails(customerAmount * 1.2);
} else {` `printItems(customerNumber);
printDetails(customerAmount);
}
printFooter();
}`

**(3)克隆方法**

您可以克隆一个方法，以便在几乎相同的情况下调用相同的代码但不同的方法。您可以根据一天中的时间调用一个方法而不是另一个方法，以给出存在外部因素的表象，而实际上并不存在。在这两种方法中使用不同的风格，或者将克隆与交错转换结合使用，这样这两种方法看起来非常不同，但实际上执行相同的功能。

**(4)循环变换**

编译器优化通常会执行许多循环优化。您可以手动执行相同的优化，或者在工具中对它们进行编码以混淆代码。*循环展开*减少循环被调用的次数，*循环裂变*将单个循环转化为多个循环。例如，如果你知道`maxNum`能被 5 整除，你可以展开`for`循环，如[清单 4-23](#list_4_23) 所示。清单 4-24 显示了一个循环分裂的例子。

**清单 4-23。** *循环展开*

`// Before
for (int i = 0; i<maxNum; i++){
sum += val[i];
}
// After
for (int i = 0; i<maxNum; i+=5){
sum += val[i] + val[i+1] + val[i+2] + val[i+3] + val[i+4];
}`

**清单 4-24。** *循环裂变*

`// Before
for (x=0; x < maxNum; x++){` `i[x] += j[x] + k[x];
}
// After
for (x=0; x < maxNum; x++) i[x] += j[x];
for (x=0; x < maxNum; x++) i[x] += k[x];`

###### 排序混淆

使用这种技术，您将变量和表达式重新排序成奇怪的组合和格式，以在反编译器的头脑中制造混乱。

**(1)重新排序表达式**

重新排序语句和表达式对混淆代码的影响很小。但是有一个例子，当字节码和 Java 源代码之间的链接再次断开时，在字节码级别重新排序表达式会产生更大的影响。

抢先软件使用一个被称为瞬时变量缓存(TVC)的概念来重新排序字节码表达式。TVC 是一种简单的技术，已经在 DashO 中实现。假设你想交换两个变量，`x`和`y`。最简单的方法是使用一个临时变量，如[清单 4-24](#list_4_24) 所示。否则，可能会导致两个变量包含相同的值。

**清单 4-24。** *变量互换*

`temp = x;
x = y;
y = temp;`

这产生了清单 4-25 中的字节码来完成变量交换。

**清单 4-25。** *字节码中的变量交换*

`iload_1
istore_3
iload_2
istore_1
iload_3
istore_2`

但是 JVM 的堆栈行为意味着不需要临时变量。临时变量缓存在堆栈上，堆栈现在兼作内存位置。你可以删除临时变量的加载和存储操作，如[清单 4-26](#list_4_26) 所示。

**清单 4-26。** *使用 DashO 的 TVC 在字节码中交换变量*

`iload_1
iload_2
istore_1
istore_2`

**(2)重新排序循环**

你可以转换一个循环，让它返回(见清单 4-27 )。这可能不会在优化方面做太多，但它是更简单的混淆技术之一。

**清单 4-27。** *循环反转*

`// Before
x = 0;
while (x < maxNum){
i[x] += j[x];
x++;
}
// After
x = maxNum;
while (x > 0){
x--;
i[x] += j[x];
}`

###### 数据混淆

科尔伯格等人的论文将数据混淆进一步分为三种不同的分类:*存储和编码、聚合、*和*排序*。到目前为止，您看到的许多转换都利用了这样一个事实，即程序员如何编写代码有标准的约定。把这些惯例颠倒过来，你就有了一个好的混淆过程或工具的基础。您使用的转换越多，任何人或任何工具理解原始源代码的可能性就越小。这一节讨论将数据重新塑造成不太自然的形式的数据混淆。

**(1)存储和编码**

存储和编码通过将数据编码到位掩码或拆分变量来寻找存储数据的不寻常方式。数据最终应该总是和最初一样。在别人甚至你自己的代码写了 6 到 12 个月之后，通常很难理解，但是如果它以这些新颖的方式存储，那么这种类型的编码会使理解变得更加困难。

**(2)改变编码**

Collberg 等人的论文展示了一个简单的编码例子:一个整数变量`int i = 1`被转换成`i' = x*i + y`。如果您选择`x = 8`和`y =3`，您将得到如[清单 4-28](#list_4_28) 所示的转换。

**清单 4-28。** *可变混淆*

`// Before // After

int i = 1; int i = 11;

while (i < 1000) { while (i<8003) {

val = A[i]; val = A[(i-3)/8];

i++; i+=8;

} }`

**(3)分裂变量**

变量也可以分成两部分或更多部分，以创建更高级别的混淆。科尔伯格建议使用查找表。例如，如果你试图定义布尔值`a= true`，那么你将变量分成`a1=0`和`a2=1`，并在[表 4-2](#tab_4_2) 中查找，将其转换回布尔值。

![Image](images/tab0402.jpg)

**(4)将静态数据转换成程序数据**

一个有趣但不太实用的转换是通过将数据从静态数据转换为过程数据来隐藏数据。例如，字符串中的版权信息可以在您的代码中以编程方式生成，可能使用前面讨论的组合交错转换。输出版权声明的方法可以使用查找表方法，或者将应用程序中几个不同变量的字符串组合起来。

**(5)聚合**

在数据聚合中，通过合并变量、将变量放入不相关变量的数组中以及在不需要的地方添加线程来隐藏数据结构。

**(6)合并标量变量**

变量可以合并在一起，也可以转换成不同的基数再合并。变量值可以存储在一系列位中，并使用各种位掩码运算符提取出来。

**(7)类转换**

我最喜欢的转换之一是使用线程来迷惑试图窃取代码的黑客。这是一个开销，因为线程更难理解，也更难正确处理。如果有人愚蠢到试图反编译代码而不是自己写代码，那么他们很可能会被大量的线程吓跑。

有时线程不实用，因为开销太大；下一个最好的混淆是使用一系列的类转换。类的复杂度随着类的深度而增加。我所讨论的许多转换违背了程序员对世界上什么是好的和正确的自然感觉，但是如果您将继承和接口使用到了极致，那么您将会很高兴地听到这创建了黑客需要时间来理解的深层层次结构。

如果你不想的话，你也不必污损它(参见“删除编程习惯用法”一节)；你也可以重构。将两个相似的类重构为一个父类，但留下一个或多个重构类的错误版本。您还可以将两个不同的类重构为一个父类。

**(8)数组变换**

像变量一样，数组可以被拆分、合并或交织成一个数组；折叠成多个维度；或者展平成一维或二维阵列。一种简单的方法是将数组分成两个独立的数组，一个包含数组的偶数索引，另一个包含数组的奇数索引。程序员使用二维数组是有目的的；改变数组的维数会对理解代码造成很大的障碍。

###### 排序

对数据声明进行排序会删除任何反编译代码中的大量实用信息。通常，数据是在方法的开始或第一次被引用之前声明的。将数据声明分散到整个代码中，同时仍然将数据元素保持在适当的范围内

##### 混淆结论

最好的混淆器会使用本节中介绍的一些技术。但是你不需要购买混淆器——你可以自己添加许多这样的转换。目的是通过删除尽可能多的信息来尽可能多地迷惑潜在的反编译器。您可以通过编程方式或在编写代码时实现这一点。一些转换要求开发者模拟在编译器的优化阶段发生了什么；其他的只是糟糕的编码实践来迷惑黑客。

在离开本节之前，有几个注意事项。首先，请记住，如果您在常量池中多次使用相同的标识符来混淆代码，您可能需要先与抢先软件讨论，因为它拥有这项技术的专利。第二，你可以尝试任何形式的高模式模糊处理，因为通常你不会坚持你的代码只能在特定的手机或设备上运行。

最后，编写非常糟糕的代码会使你的代码非常难以阅读。小心不要把婴儿和洗澡水一起倒掉。模糊代码很难维护，并且根据转换情况，可能会破坏代码的性能。注意你应用的变换。从长远来看，自动化外观设计以便可以自动重构会对你有所帮助。如果你需要的话，ProGuard 和 DashO 都可以让你恢复混淆。

##### 网络服务

有时候最简单的想法是最有效的。保护代码的一个更简单的想法是分割你的 Android 源代码，让远程服务器上的大部分功能远离任何窥探。下载的 APK 是一个简单的 GUI 前端，没有任何有趣的代码。服务器代码不必用 Java 编写，web 服务可以用轻量级 RESTful API 编写。但是正如你在本章前面看到的，小心隐藏任何用户名和密码，这样黑客就不会攻击你的 web 服务。不过，拆分代码也有一些缺点，因为如果设备离线，它将无法工作。

##### 给你的代码加指纹

虽然它实际上并不能保护你的代码，但是在你的软件中放一个数字指纹可以让你以后证明*你*写了*你的*代码。理想情况下，这个指纹——通常是一个版权声明——就像一个软件水印，即使你的原始代码在进入其他人的 Java 应用程序或小程序之前经历了许多的改变或操作，你也可以在任何时候恢复它。正如我多次说过的，没有 100%万无一失的方法来保护你的代码，但是如果你可以通过证明你写了原始代码来挽回一些损失，那就没关系了。

如果你感到困惑，请注意对你的代码进行数字指纹识别和对你的小程序或应用程序进行签名是完全不同的。当涉及到保护你的代码时，签名的小程序没有任何作用。签署 applet 有助于下载或安装软件的人通过查看与软件相关联的数字证书来决定是否信任 applet。这是一种保护机制，让使用你的软件的人证明这个应用程序是由 XYZ Widget Corp .编写的。用户可以在继续下载小程序或启动应用程序之前，决定他们是否信任 XYZ Widget Corp。另一方面，数字指纹通常使用解码工具来恢复。它有助于保护开发者的版权，而不是最终用户的硬盘。

指纹识别的几种尝试试图使用例如定义的编码风格来保护整个应用程序。更原始的指纹类型将指纹编码到一个伪方法或变量名中。这个方法名或变量可能由各种参数组成，比如日期、开发人员姓名、应用程序名称等等。但是这种方法会产生一个第 22 条军规。假设你在你的代码中放了一个虚拟变量，有人碰巧把反编译的方法，连同虚拟变量一起，剪切并粘贴到他们的程序中。如果不反编译他们的代码并且在这个过程中可能违反了法律，你怎么知道这是你的代码呢？

大多数反编译器，甚至一些混淆器都去除了这些信息，因为在代码被解释或执行时，这些信息并没有发挥积极的作用。最终，您需要能够通过调用伪方法或使用一个永远不会为真的假条件子句，使反编译器或混淆器相信任何受保护的方法都是原始程序的一部分，这样该方法就永远不会被调用:

`if(false) then{
invoke dummy method
}`

一个聪明的人可以看到一个伪方法，即使反编译器看不到前面的子句永远不会为真。他们会得出结论，伪方法很可能是某种指纹。因此，您需要在方法级别附加指纹信息，以获得更健壮的指纹。

最后，您不希望指纹损害应用程序的功能或性能。正如您所看到的，Java 验证器通常在决定您可以对代码应用什么保护机制方面起着重要的作用，所以您需要确保您的指纹不会阻止您的字节码通过验证器。

让我们用这个讨论来定义一个好的数字指纹系统的标准:

*   它不使用死代码伪方法或伪变量。
*   即使只是程序的一部分被盗，指纹也需要工作。
*   应用程序的性能不应该受到影响。最终用户不应该注意到指纹代码和非指纹代码之间的区别。
*   指纹代码应该在功能上等同于原始代码。
*   指纹必须足够健壮或隐蔽，以经受住反编译攻击以及任何混淆工具。否则，可以简单地删除它。
*   字节码应该语法正确，才能通过 Java 验证程序。
*   类文件需要能够经受住其他人用他们自己的指纹对代码进行指纹识别。
*   你需要一个相应的解码工具来恢复和查看指纹，最好是使用密钥。指纹不应该被肉眼或其他黑客看到。

你不需要担心指纹是否高度可见。一方面，如果它既可见又健壮，那么它很可能会吓跑偶尔的黑客。但是，经验更丰富的攻击者会知道攻击的确切位置。如果偶然的黑客不知道应用程序受到保护，那么就没有预先的威慑去查看其他地方。抢先的 DashO 有一个指纹选项。

##### 本地方法

一种有助于隐藏关键信息(如登录用户名和密码)的方法是将密码移动到本地库中。原生代码反编译成汇编代码，要难读得多，只能反汇编，不能反编译。

Android 原生开发工具包(NDK)是 Android SDK 的配套工具，允许开发者用原生代码创建应用程序的一部分。要创建一个使用 Java 本地接口(JNI)的本地库，在项目的根目录下创建一个名为`jni`的文件夹。JNI 文件可以称为`decompilingandroid-jni.c`。它必须有一个后缀`-jni.c`，这样 NDK 才能拿起它。[清单 4-29](#list_4_29) 是`decompilingandroid-jni.c`中返回字符串的一个简单方法的例子。

**清单 4-29。** *土法`decompilingandroid-jni.c`*

`jstring Java_com_riis_decompilingandroid_getPassword(JNIEnv* env,
jobject thiz)
{
return (*env)->NewStringUTF(env, "password");
}`

对该方法的引用在`com.riis.decompilingandroid`中处理:

`static
{
// Load JNI library
System.loadLibrary("decompilingandroid-jni");
}

/* Native methods that is implemented by the
* 'decompilingandroid-jni' native library, which is packaged
* with this application.` `*/
public native String getPassword();`

返回类型是`jstring`，方法名以`Java_`开头，后面是类路径、类名和方法。这个全名对于 JNI 将这个方法映射到`com.riis.example`类很重要。

创建一个名为`Android.mk`的 make 文件，描述 NDK 构建的本地源代码:

`LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE := decompilingandroid-jni
LOCAL_SRC_FILES := decompilingandroid-jni.c
include $(BUILD_SHARED_LIBRARY)`

通过运行项目目录中的`ndk-build`脚本来构建您的本地代码。`ndk-build`脚本作为 NDK SDK 的一部分安装，必须在 Linux、OS X 或 Windows(带 Cygwin)平台下运行:

`cd <project>
<ndk>/ndk-build`

如果构建成功，您将得到以下文件:

`<project>/libs/armeabi/libdecompilingandroid-jni.so`

简单地将静态字符串移入本地库并不一定能消除不安全字符串的问题。在前面的例子中，通过在文本编辑器中查看`libdecompilingandroid-jni.so`可以很容易地找到字符串“password”。为了进一步保护密码，将它分成多个块，然后将结果连接在一起。[清单 4-30](#list_4_30) 是破解`cxYacuzafrabru5a1beb` web 服务 API 密码的一个例子。

**清单 4-30。** *对反汇编者隐藏密码*

`char str[80];
char *str1 = "bru";
char *str2 = "1beb";
char *str3 = "5a";
char *str4 = "fra";
char *str5 = "cxY";
char *str6 = "uza";
char *str7 = "ac";`  `strcpy(str, str5);
strcat(str, str7);
strcat(str, str6);
strcat(str, str4);
strcat(str, str1);
strcat(str, str3);
strcat(str, str2);

return (*env)->NewStringUTF(env, str);`

本机代码只能在编译时针对的特定处理器上运行。每个 Android 设备都运行在 ARM 处理器上，除了少数几个不是普遍可用的，但未来可能会改变。谷歌电视不支持 NDK。

##### 非混淆策略结论

Java 类文件和现在的 DEX 文件包含如此多的信息，这使得保护底层源代码变得异常困难。然而，大多数软件开发商继续忽视后果，让他们的知识产权处于危险之中。一个好的混淆过程应该需要多项式时间来产生和指数时间来逆转。我希望本节中相当详尽的模糊转换列表能够帮助您接近那个目标。至少，Collberg 等人的论文包含了足够的信息，可供任何想在这一领域入门的开发者参考。

表 4-3 总结了本章讨论的方法。值得注意的是，许多最初的混淆工具没有在互联网泡沫破灭后幸存下来，这些公司要么已经倒闭，要么转向其他专业化领域。

![Image](images/tab0403.jpg)

最后一句话:非常小心依赖混淆作为唯一的保护方法。请记住，反汇编程序也可以用来拆开您的`classes.dex`文件，并允许某人直接编辑字节码。不要忘记，网络上的交互式演示或软件的有限功能演示版本会非常有效。

##### 混淆器

基于您对混淆技术的新认识，让我们快速浏览一下现有的 Android 混淆器。

###### 克丽玛

虽然对 Android APKs 不起作用，但因为历史原因，还是值得提一下 Crema。像当时的许多 Java 混淆器一样，它已经不存在了。正如本章前面提到的，Crema 是最初的混淆器，是经常提到的由已故的 Hanpeter Van Vliet 编写的 Mocha 的补充程序。摩卡是免费赠送的，但克莉玛大约要 30 美元。为了抵御摩卡咖啡，你必须买克莉玛。

Crema 执行一些基本的混淆，并且有一个有趣的副作用:它标记类文件，这样 Mocha 拒绝反编译任何以前通过 Crema 运行的小程序或应用程序。但是市场上很快出现了其他对 Crema 不友好的反编译器。

###### 阿帕尔德

ProGuard 是 Android SDK 附带的一个开源混淆器。为了在您的构建过程中启用它，在构建发布版本之前，将以下内容添加到您的`project.properties`文件中。每个人都应该这样做，以便在他们的 Android 项目中获得基本的混淆:

`proguard.config=proguard.cfg`

ProGuard 主要提供布局混淆保护，正如你从[图 4-8](#fig_4_8) 中看到的。它不隐藏用户名和密码，而是重命名方法和字符串，使它们不再向黑客提供任何上下文信息。

![Image](images/9781430242482_Fig04-08.jpg)

**图 4-8。** *程序保护码*

如果你使用 ProGuard，要注意你使用了多少公共类，因为默认情况下它们不会被混淆。使用 ProGuard 时，实践良好的面向对象设计是有回报的。一个很好的经验法则是在混淆后总是反编译你的 APK，以确保它确实在做你认为它在做的事情。

###### 达绍

DashO 是一个商业混淆器，来自于早期 Java 时代就已经存在的抢先软件。它执行布局、控制和数据混淆。使用向导让 DashO 混淆一个 Android 应用程序。[图 4-9](#fig_4_9) 显示了 DashO GUI 在左侧菜单中，您可以看到控制流、重命名和字符串加密选项。

![Image](images/9781430242482_Fig04-09.jpg)

**图 4-9。** *妫办公会*

[图 4-10](#fig_4_10) 使用了与[图 4-8](#fig_4_8) 中相同的应用程序，但是这一次用 DashO 代替了 ProGuard。请注意字符串加密。

![Image](images/9781430242482_Fig04-10.jpg)

**图 4-10。***DashO-保护代码*

###### JavaScript 混淆器

就像 Java 混淆器一样，JavaScript 混淆器也有很多种。如果你使用 HTML5/CSS 方法来编写你的 Android 应用程序，那么使用 JavaScript 混淆器或压缩器至少可以从你的代码中删除注释。对于那些试图黑你的应用的人来说，评论简直太有用了。黑客也不需要反编译 HTML5/CSS 应用程序——他们需要做的只是解压缩它。这使得创建一个假版本的应用程序变得非常容易。

这里有两个 JavaScript 混淆器值得研究:

*   YUI 压缩机，从`[https://github.com/yui/yuicompressor](https://github.com/yui/yuicompressor)`开始供应
*   JSMin，可从`[www.crockford.com/javascript/jsmin.html](http://www.crockford.com/javascript/jsmin.html)`获得

我没有包括任何基于 web 的产品，因为您希望能够从命令行运行混淆器，以将其包括在您的构建过程中。这样，您可以确保您的 JavaScript 总是模糊的。

YUI 压缩器的调用如下，其中最小化版本的 JavaScript 文件被命名为`decompilingandroid-min.js`而不是`decompilingandroid.js`:

`java -jar yuicompressor.jar -o '.js$:-min.js' *.js`

[清单 4-31](#list_4_31) 显示 YUI 压缩机之前的代码，[清单 4-32](#list_4_32) 显示 YUI 压缩机之后的代码。

**清单 4-31。** *在 YUI 压缩机之前*

`window.$ = $telerik.$;
$(document).ready(function() {
movePageElements();

var text = $('textarea').val();

if (text != "")
$('textarea').attr("style", "display: block;");
else
$('textarea').attr("style", "display: none;");

//cleanup
text = null;
});

function movePageElements() {
var num = null;
var pagenum = $(".pagecontrolscontainer");
if (pagenum.length > 0) {
var num = pagenum.attr("pagenumber");
if ((num > 5) && (num < 28)) {
var x = $('div#commentbutton');
$("div.buttonContainer").prepend(x);
}
else {
$('div#commentbutton').attr("style", "display: none;");
}
}

//Add in dropshadowing
if ((num > 5) && (num < 28)) {
var top = $('.dropshadow-top');
var middle = $('#dropshadow');
var bottom = $('.dropshadow-bottom');
$('#page').prepend(top);
$('#topcontainer').after(middle);` `middle.append($('#topcontainer'));
middle.after(bottom);` `}

//cleanup
num = null;
pagenum = null;
top = null;
middle = null;
bottom=null;
}

function expandCollapseDiv(id) {
$telerik.$(id).slideToggle("slow");
}

function expandCollapseHelp() {
$('.helpitems').slideToggle("slow");

//Add in dropshadowing
if ($('#helpcontainer').length) {
$('#help-dropshadow-bot').insertAfter('#helpcontainer');
$('#help-dropshadow-bot').removeAttr("style");
}
}

function expandCollapseComments() {
var style = $('textarea').attr("style");
if (style == "display: none;")
$('textarea').fadeIn().focus();
else
$('textarea').fadeOut();

//cleanup
style = null;
}`

**清单 4-32。***YUI 压缩机后*

`window.$=$telerik.$;$(document).ready(function(){movePageElements(
);var
a=$("textarea").val();if(a!=""){$("textarea").attr("style","displa
y: block;")}else{$("textarea").attr("style","display:
none;")}a=null});function movePageElements(){var e=null;var
b=$(".pagecontrolscontainer");if(b.length>0){var
e=b.attr("pagenumber");if((e>5)&&(e<28)){var
a=$("div#commentbutton");$("div.buttonContainer").prepend(a)}else{
$("div#commentbutton").attr("style","display:
none;")}}if((e>5)&&(e<28)){var f=$(".dropshadow-top");var` `d=$("#dropshadow");var c=$(".dropshadow-
bottom");$("#page").prepend(f);$("#topcontainer").after(d);d.appen` `d($("#topcontainer"));d.after(c)}e=null;b=null;f=null;d=null;c=nul
l}function
expandCollapseDiv(a){$telerik.$(a).slideToggle("slow")}function
expandCollapseHelp(){$(".helpitems").slideToggle("slow");if($("#he
lpcontainer").length){$("#help-dropshadow-
bot").insertAfter("#helpcontainer");$("#help-dropshadow-
bot").removeAttr("style")}}function expandCollapseComments(){var
a=$("textarea").attr("style");if(a=="display:
none;"){$("textarea").fadeIn().focus()}else{$("textarea").fadeOut(
)}a=null};`

YUI 压缩程序混淆并最小化，而 JSMin 只是最小化了 JavaScript。需要注意的是，也有 JavaScript 美化器可以逆转这个过程；参见`[http://jsbeautifier.org](http://jsbeautifier.org)`。

### 总结

在这一章中，你已经学会了如何找到一个电话的根，下载和反编译一个 APK，并使用一些工具混淆 APK。有很多东西需要消化。在接下来的两章中，您将构建自己的 Android 混淆器和反编译器。在第五章第一节中，你负责设计，在第六章第三节中，你完成了反编译器的实现。在本书的最后一章，你将回到你在本章中首次使用的许多工具，看看它们对一系列现实世界的 Android 应用程序有多有效。它们中的每一个都将作为一个案例研究，在这个案例中，您拥有原始源代码来测试您的源代码对反编译器和反汇编器的保护。