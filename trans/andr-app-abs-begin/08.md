© Wallace Jackson 2017Wallace JacksonAndroid Apps for Absolute Beginners10.1007/978-1-4842-2268-3_8

# 8.Android 设计模式:UI 设计范例

Wallace Jackson<sup>1</sup>(1)Lompoc, California, USAAndroid Studio includes a number of popular user interface design approaches, called “patterns,” as pre-coded Activity subclasses found in the Create New Project series of dialogs that you used during Chapter [3](03.html). Since this is an Absolute Beginner title, we will be leveraging these application design and user experience templates to teach you how to quickly create apps using some of the most popular Android 7 UI approaches. At the same time, I will teach you what the Java code or XML markup is doing for the application, so that you will learn Android 7.1.1 development rapidly and efficiently, while also creating several types of Android applications.This approach will make some very advanced (and popular) user interface layout designs immediately available to every Absolute Beginner Android Studio developer. This is precisely why I am including this chapter in the book, and only halfway through the book, to accelerate us into professional Android 7.1.1 application development, now that we have covered the basics of what Android is, how to install it, how to create an application, how to design a user interface, how to make a UI interactive, and now how to access popular UI design patterns recently included in Android Studio’s “coding and UI design helper” functionality introduced in 2016 in Android Studio 2.2.To be able to implement advanced Android UI design patterns right out of the gate as Absolute Beginners is a real testament to the quality and reach of Android Studio 2.3, and the advanced nature of the new Android APIs, which are focusing on making code structures, and design patterns, available to developers who might just be Absolute Beginners. Google’s marketing motivation regarding this is to get many more developers creating Android 7.1.1 applications, as you probably have already surmised.One of the ways that I am “refreshing” this Android Apps for Absolute Beginners title in its fourth edition is the incorporation of many of the changes that have taken place with Android Studio 2.3 and in Android 7.1.1 APIs that are specifically targeted at helping Absolute Beginners. Two of the areas that have had the most change in Android Studio 2.3 and Android 7 include the area of drag-and-drop user interface design (Visual Design Editor, Chapter [6](06.html)) and creating new bootstrap applications with the Create New Android Application series of dialogs (Chapter [3](03.html)). We will be looking at the Create New Application series of dialogs further in this chapter. Three of the most popular UI design pattern Activity application design approaches have been added to this series of dialogs since Android became 64-bit (in Version 5), so I added these to the book, to expose them to Absolute Beginners.In this chapter, we will be covering Android design patterns. These will assist you in making Android applications that conform to what Android users expect from a user experience. We’ll also cover several application design approaches provided as Activity classes in the Create New Android Application dialogs. These also include, and conform to, the Android design patterns, making for a very synergistic chapter.

## Android 设计模式:确保应用程序的视觉质量

An [Android](http://developer.android.com/reference/android/content/Intent.html) design pattern is a work process for, that is, a way of going about, designing Android application user interfaces (UI) and user experiences (UX) . These Android applications are hosted in the Google Play marketplace, and therefore Google has an interest in having all their apps conform to a stringent UI design standard.In the first section of the chapter I will be going over what would be included in these Android design patterns, all of which are targeted at increasing the user experience of Android users so that they’re captivated by your Android application.Besides captivating Android users with your visually exciting Android UI design and content, Google also wants to make sure that you keep your applications simple to use and easy to comprehend. This involves making sure the app is usable even for first-time users, and that users are not overwhelmed by a plethora of choices or by complex tasks, which should be performed in the background whenever possible.We’ll be conforming to, and covering, these Android design patterns throughout the rest of this book. I wanted to have a chapter specifically covering this topic, before we got too far along in the book. Let’s start by looking at material design.

### 材料设计:i3D 动画用户体验设计

Material design is a definition of how visual elements, animated motion, and GUI interactivity should work across all Android devices (smartphone, tablet, iTV set, e-book reader, smartwatch, auto dashboard, game console, etc.) and Android platforms (Android TV, Android Auto, Android Wear 2, Android Glass, etc.). Android now contains material design components that we’ll be referencing and using throughout the book, so that you can develop the most professional Android applications as an Absolute Beginner.Material design is a three-dimensional environment that will allow Android developers to control light, shadowing, and materials, sometimes called textures or shaders in 3D software packages. This runs in sharp contrast to the “flat design” currently in use in HTML5, iOS, and template-driven systems, such as WordPress and Wix. These 3D features will allow Android application developers and i3D designers to set themselves apart from the crowd, allowing the visual sensation that Google wants to set Android apps far apart from the rest of the marketplace, and continuing to increase their dominant market share.Each material design object in Android 7 supports an X, Y, and Z dimension, as well as a variable that holds its current Z axis (height) position in the layer stack, which will be used to calculate automated shadowing features and options. Material design support for key lights allows developers to create directional and even animated shadows. Ambient light is also supported to create softer shadows, for realistic 3D effects.Material design attributes sets Android distinctively apart from flat template-driven 2D design. Material design occupies XYZ coordinates for 3D spaces, allows 3D mutable (morphable) shapes, enables seamless joins with other material design components, allows UI elements and content to split (separate) and heal (join), can move along any axis, and can be created (placed into memory) or destroyed (removed from memory) in real time, and interactively, using Java code within your Android applications.Some of the new material design components available for 64-bit Android (5-7) apps include new themes, widgets, and layout containers, a visual design editor, and new APIs that allow custom shadowing and animation. We have already covered some of the material design features in this book, such as themes and the visual design editor, and we’ll continue to cover the other ones during the course of this book .

### 硬件设备:跨设备的代码设计模式

As there are a plethora of consumer electronics hardware genres that will run Android OS, some of which we will cover in this section specifically, it’s becoming a challenge to design a UI that can morph between different screen sizes, shapes, and orientations. Android provides tools and capabilities that address this issue directly, and other operating systems, including four HTML5 OSes, are copying these features to deal with running apps, and websites, on hundreds of different devices.

#### 智能手机、平板电脑、平板手机和电子书阅读器:核心 Android API

In the beginning, with Android 1.x, the operating was a mobile operating system used for mobile phones. Android 2.x added tablet support, and 2.3 was used for the popular Amazon Kindle Fire e-book reader. Android 3 added features for phablets, or phone-tablet hybrids. At this point in the Android API, there were no specialized APIs like the ones we will cover later on in this section; those started around Android 4\. The “core” Android API, that is, the one that holds the primary features and has been known as “Android OS ” since day one is the Android API that is used on smartphones, tablets, e-book readers and now even on laptops and personal computers.These four devices will require two user interface designs, one for users using their device vertically, or up and down, called “portrait mode ,” and one for those who prefer using their device horizontally, or widescreen, called “landscape mode .” The trend is toward landscape mode due to previously popular devices (laptops and personal computers), as well as the more rapidly growing (in sales figures) device, the iTV set, or interactive television set, hardware device. These only function in widescreen (landscape) mode, allowing better use of screen real estate for working and cinematic entertainment.These devices used to vary widely in resolution, however, this is changing again, due to iTV technology and content, which exists in three primary HD and UHD resolutions: 1280 by 720 (1280 by 800 devices) 720P Blu-ray, 1920 by 1080 (1920 by 1200) 1080P HD, and 3840 by 2160 (or 4096 by 2160 devices) 2160P UHD. Most popular content is also developed and distributed using these formats, so the trend for all device manufacturers has been to support one of these three resolutions, so that content does not have to be scaled, which can take up most of a devices memory and CPU capacity by calculating pixel arrays. Scaling also reduces image quality. A good example of this is the recent 2560 by 1440 resolution, which plays 1280 by 720 Blu-ray content with no reduction in quality, as if scaling is done by 100% (2X) up or down, the visual quality is maintained. If you want to learn more about pixels and scaling, check out the Digital Image Compositing Fundamentals title (Apress, 2015).There are three primary screens used on all these devices: an apps screen that contains all of the launcher icons for the apps on the device; a Home screen, which contains widgets, icons for your favorite apps, folders and the like; and a recent screen, which shows your recently used applications.The core Android OS has two system bars for OS UI functions, your top-mounted Status Bar for system, network, and hardware status indicators; and notifications. For hardware that does not have hardware navigation keys, there is also sometimes a bottom-mounted Navigation Bar that provides the Back (triangle), Home (circle), and Recent (square) icons. Developers can also provide their own Action Bar, underneath the Status Bar as well as Navigation Drawers, which we’ll be looking at during this chapter, along with other popular user interface design and content navigation approaches that will enhance usability, overall user experience and Wow-Factor.

#### 智能手表和可穿戴技术:Android Wear 2 API

An Android Wear API , now in its second version , was introduced in Android 4.4W, a special version of Android 4.4.4\. Android versions previous to Version 5 were 32-bit, and therefore only able to address 3.24 GB of system memory. Smartwatches are square and therefore have a unique 1:1 aspect ratio (screen shape), and thus will require a third UI design for optimal user interaction and user experience. Initially smartwatch devices had a low resolution of 240 or 320 pixels, later devices supported 400 or 480 pixel screens; and I expect to see 640 or 800 pixel resolution screens out by 2018, or even sooner. High-resolution smartwatches will further enable innovation by new media content developers.Wearable devices demand a totally different user interface and user experience than phones, tablets or iTV sets, as they have different ergonomics, usage profiles, and hardware specifications. The smaller (in resolution, width, and height) form-factor portends that you use what Google terms the “suggest and demand” design approach, which is why Android 5 introduced card-based UI layouts and widgets, for use with smartwatches.To suggest, Android uses the “context stream,” a list of cards that scrolls in a vertical dimension to show top or home cards, and which can be swiped horizontally, to show additional cards underneath the home (top or title) card. Background images can provide visual context, so users can browse the context stream to see what is going on in their devices, and drill down into only what currently interests them.For user demands, Android provides the “cue card” that can be opened by saying “OK Google.” Swiping up on a cue card will show a list of commands; these can be touched to select, or spoken for use with the smartwatch voice recognition features. Each top or voice command is wired to a different Intent object, which you learned about in Chapter [7](07.html). If an implicit Intent object is used, applications that conform to the category and action of this Intent will be listed for preferential selection by the smartwatch user. Intents can trigger the launch of an application, Activity, or an update (or addition) of a context stream card.Android smartwatches also feature a Home screen that is usually a custom-watch face design, created by using the Android WatchFaces API. If you are interested in the WatchFaces API, check out the Pro Android Wearables title (Apress, 2015). There are also status icons in the watch face showing charge, watch modes, and unread card status (count). Watch faces can also show “peek cards,” which show a portion of the card at the bottom of the WatchFace design.

#### 汽车仪表盘:Android Auto API

Around the same time as the Wear API was introduced, Google also added the Auto API to provide a custom Android user interface for automobile dashboards, which are increasingly using digital OLED displays, rather than expensive analog dashboard gauges. This API is designed toward minimizing driver distraction by optimizing quick selection of as few salient options as possible displayed prominently on the screen, a design approach that I’ve been implementing for my international clients for decades now.When the driver connects their Android device to their auto, they will encounter the Android Auto “Overview screen,” which displays widescreen context cards based on the auto location, weather, time, date, and so forth. This screen can also display a user’s messages and also supports voice recognition. Touching a headphone icon will give users a list of all Auto apps installed. Auto apps use a standard transport UI that can be customized as needed to add feature icons to the audio playback icon. Android Auto also supports different color themes for day (light) and night (dark).

#### 独立电视集:安卓电视应用编程接口

The next customized API that Google released for Android products in the international marketplace targeted the exploding interactive television set product currently replacing “dumb TV sets” in all big brand brick and mortar stores, as well as in online retail. Android TV competes with HTML5 iTV OSes , including Firefox OS (Panasonic HDTVs), Opera OS (Sony Bravia HDTVs), and Google Chrome OS (ChromeCast).Most iTV sets use one of two resolutions currently: True HD (1920 by 1080P); or Ultra HD (3840 by 2160P), which is twice the resolution of True HD on each X/Y axis, or four times the resolution of True HD in total. This much resolution, 2,073,600 pixels (HD) to 8,294,400 pixels (UHD) allows iTV set device screens to span several feet across with high-quality imagery. This gigantic screen size yields by far the best user experience of any Android hardware device type, especially if you have the 24-bit HD Audio piped into your home stereo system and Dolby THX 5.1 speaker system with 24 inch sub-woofers! Interactive Television Sets also can hook into the types of peripherals (game controllers, keyboards, mouse, HD camera, etc.) that can enhance the interaction with the iTV set using USB, Bluetooth, or Wi-Fi connections.Finally, iTV sets are used in a situation where your users can (and will) focus 100% of their attention on the application being used on their iTV set, as they are in their favorite easy chair, undistracted in the comfort of their bedroom or living room. Compare this to using phones, tablets, or auto dashboards out in public, and you will see a major difference in ergonomics and environment for the iTV set device type.Again, Android UI design can be customized to fit iTV set ergonomics and iTV end use case scenarios, in order to optimize the end user experience, which should be vastly different than smartphone, smartwatch, dashboard, e-reader, or tablet usage.The Android TV Home screen is the entry point into the iTV user experience, and offers content search, recommendations, and application launch. Developers can offer cinematic previews or animated overviews of their content in this Home screen area.Game and iTV applications both have their own separate areas on the Home screen and will be placed in the order that reflect the user’s usage and allow easy access to the most often used games and applications. Settings and Wi-Fi networks are also accessible at the bottom of the Home screen.Interactive Television design guidelines are similar to good UI design for tiny devices such as smartphones, because the iTV set is mounted up on the wall a good distance (10 feet or more) from the user (viewer). A large 16 to 24 pixel font size for text with a sans serif (Arial or Roboto) typeface will be readable by anyone from any distance, and easy-to-select buttons can be quickly accessed via remote or touchscreen without having to figure out how to zoom or scroll around, which should be unnecessary on a screen with that resolution and dimension using good UI design .

#### 未来的 API:安卓眼镜、安卓 Home、安卓 VR、安卓机器人

If Google brings Google Glass back, there will be an Android Glass API added to Android Studio, and with all of the VR goggles out there, I expect an Android VR API sometime in the future as well for use with i3D, VR and AR (Augmented Reality). I’d also like to see an Android Home API sometime soon for Home Appliance and Security; and an Android Robot API, for a growing number of Android-powered robots! I already have several Android robots already, for use in my Pro Android IoT book, (which is slated to come out in 2018). As long as Android keeps dominating consumer electronics device verticals, these customized APIs should continue to be released.

### 纯 Android:应用设计品牌一致性

Android OS powers billions of smartphones, tablets, e-book readers, iTV sets, game consoles, smartglasses, smartwatches , home appliances, home media centers, and new emerging devices that come under the heading of IoT, or Internet of Things. The devices support a wide variety of screen sizes, form factors (shapes, or aspect ratios), and orientation (portrait and widescreen or landscape). This means that developers must properly leverage Android's layout system in their Java 8 code, XML markup, and user interface design. If you optimize your application so that it can morph UI layout design between device types, you can create apps that seamlessly accommodate display screens from smartwatches to smartphones to tablets to laptops to PCs to game consoles to home media centers (often called set-top boxes) iTV sets.

#### 显示形状、分辨率和方向:变形的用户界面

To do this your user interface design approach must be flexible enough to fit your UI layout design in such a way that optimized the design to use the screen real estate to a wide variety of screen aspect ratios (shapes), heights, and widths.On larger (usually widescreen) iTV set , laptop and tablet devices, you should take advantage of valuable screen real estate with a user interface that stays out of the way on the top and sides of the screen allowing your content to dominate the view, rather than a logo, banner, or user interface panels. Gone are the landing pages of old, replaced by immediate gratification of content surrounded by a touch-once go anywhere user interface design optimized for touchscreen, not mouse scroll-wheels. How often on your widescreen tablet or iTV set do you go to a blog site where 40% of the screen is used in the center (with 30% on each side unused) where you have to endlessly scroll for miles to find that content needle in the digital haystack?Android now has hundreds of API features that allow developers to correct this design malady that plagues almost all current content; all you have to do is to design, optimize, implement, and code your user interface to utilize every pixel on every screen optimally to give the user a fast and easily understandable user experience.To do this is not easy (like drag-and-drop, template-driven CMSes are), as you must provide three or four different sets of digital asset resources for different screen densities (MDPI, HDPI, XHDPI) to ensure that apps look great on all devices.Designing for multiple screens is an art form that few have sought to master due to the ease of drag-and-drop CMS and templates, which don’t make for a unique brand experience, which a “Pure Android” standard requires. The best approach is to work in UHD (4K), designing for the far more popular (and usable) widescreen devices with the larger screen sizes, and then scale down (down-sampling pixels retains quality, while up-sampling pixels reduces quality); then figure out any UI “compromises” you will need to make on smaller screens, portrait smartphones, and square smartwatches .

#### 向后兼容:支持 32 位 Android 版本和设备

Android 7 has enhanced the OS backwards compatibility capabilities, which we’ll be leveraging in this book, since it is an Absolute Beginner title, and since these features are also tied into the Visual Design Editor, as you have already seen over the course of the first half of the book. This ensures apps work on 32-bit Android 2.37 (Kindle Fire) and Android 4.4.4 devices, which are still in use (phones and tablets).

#### 确认和承认:我们都在同一页上吗？！

Part of Pure Android Design involves staying in sync with your users. When your users take part in a user interface interaction in your app, which we covered in Chapter [7](07.html), it is a good idea to confirm or acknowledge that action through text if there are no change to the screen’s content (such as loading a new Activity screen).Confirming involves asking a user to verify that they want to proceed with the action they just invoked using your user interface. In some cases, the confirmation will be presented along a warning dialog and (or) important information related to the result of that action that you feel that they will need to consider.Acknowledging involves a display of text that lets a user know that the action they just requested be performed has been completed. This removes any uncertainty about background (Service) operations that the operating system may be undertaking to accomplish (complete) that action. In some cases, an acknowledgment is presented along with an option dialog allowing the user to undo (reverse) the performed task.Communicating to users using confirmation and acknowledgment helps to remove any uncertainty regarding actions that have been undertaken or that are about to be performed by the Android OS have happened. This ensures a good user experience for your users by making them think about what they are doing, preventing them from making mistakes that they otherwise might regret using your (branded) application.

#### 可访问性:为听力和视力受损的人设计你的应用程序

Accessibility is defined as the measure of how successfully your product can be utilized by a wide range of people who have disabilities of one type or another. Examples of these would include visual impairment, hearing impairment, color deficiency (commonly called “color blind”), hearing loss, limited manual dexterity, and afflictions which cause symptoms such as these.Universal accessibility design involves including code that makes your product user interface and user experience easily accessible to all users regardless of their physical capabilities. An Android design pattern should be optimized to be in accordance with universal design principles. Adhering to universal design means you should enabling all of the Android accessibility-related tools and API features, so as to make your application, game, iTV show, e-book, etc. as accessible as possible.Android includes a number of features that support access for users with visual impairments. These are built into the Android API and do not require drastic visual changes to your app; however, they do require Java code or XML markup to implement in your user experience design patterns. TalkBack is a pre-installed screen reader service that is provided by Google. It uses vocal feedback to describe the result of end user actions, like launching an app or Activity, dialogs, and notifications. The Explore by Touch operating system feature works hand in hand with TalkBack, allowing users to touch the device screen and hear what's under your finger (or the cursor) via TalkBack vocal feedback. Android OS accessibility settings allow users to modify the device display, as well as audio options. This includes increasing font sizes, changing the speed at which text is spoken, and similar settings.The Pure Android design principle, “Users should always know where they are” is key for a successful accessibility user interface design. As users navigate through an application, they need visual feedback as well as a GUI model of where they are, like navigation tabs or 3D UI buttons that show where you are in the content. Users will always benefit from this strong sense of hierarchy and logical content access.All users benefit from visual, haptic (sense of touch) feedback during their UI navigation. This is aided by 3D, button labels, color, icons, single touch feedback and logically placed UI elements. Low-vision users can benefit from explicit verbal descriptions, large font sizes, large buttons, and large visuals with high contrast. The following are Pure Android Design guidelines that enable effective navigation.The first objective is to design intuitive, easy-to-use, navigation. You should design well-defined, clear, information or task flow with minimal navigation steps, and minimum navigation levels (called “flat” navigation). Make sure that tasks and information are navigable via user interface design elements that pass focus (which UI element is active or in use is said to have “focus”) in a logical, ordered fashion.A second objective is to use recommended UI element “touch target” sizes. Small buttons or tabs with small text labels will not be usable on small screen displays. 48 DIP (or Density Independent Pixels) is the Pure Android recommended touch target size for screen UI elements. For some users it might even be appropriate to use a larger touch target. An example of this is educational apps and games where buttons larger than the minimum recommended size are easier to use for children with developing motor skills and disabled people who have manual dexterity challenges.A third objective is to label your visual UI elements with short, concise text, using a large font size, with a word that sums up a description of that information or function. If you want to use glyphs (picture-based navigation icons), be sure to use the contentDescription attribute to label functional UI components that have no visible text. Those components can be buttons, icons, tabs with icons, and icons with state (like stars) information. As you’ve experienced already in Chapter [6](06.html) on Visual Design, developers must use a contentDescription attribute to set the glyph’s label .The Android system-wide font size control is not often considered by developers. Users can enable a system-wide large font size under their OS Settings. Using the default system font size in an application will enable a user's system font size preferences to be used in your application as well. To enable system font size in your app, mark text UI elements and their associated UI layout containers to be measured using SP (scale pixels) instead of DP (Density Pixels) or DIP.

#### 主屏幕部件:小型化应用

Android Widgets are an essential aspect of your home screen customization. They are essentially entire applications that can be viewed at a glance and can contain important data and functionality that is accessible right from the user's home screen. Users can move widgets across their home screen panels, and, if supported, resize them to tailor the amount of information displayed. For example, if you were a pharmaceutical company, you could create a widget that advised customers when to take their dosages throughout the day. Widgets classify as one of these categories:

*   信息小工具通常实时显示关键信息元素，这些元素对用户来说很重要，并且将跟踪信息如何随时间变化。信息窗口小部件的例子有健康窗口小部件、天气窗口小部件、时钟窗口小部件、游戏或体育比分追踪器。触摸一个信息小部件以启动相关的应用程序，这将打开小部件信息的详细视图。
*   收藏小工具专门展示同一类型的众多元素，比如来自图库应用的图片收藏、来自新闻应用的文章收藏，或者来自通讯应用的邮件/消息收藏。集合小部件通常关注两个用例:浏览集合，以及打开集合的一个元素到它的细节视图以供使用。
*   控件可以用来显示经常使用的功能，用户可以直接从主屏幕上选择，而不必先打开应用程序。这有点像给你的应用程序配备一个遥控器。控制小部件的一个例子是音乐应用程序小部件，它允许用户在音乐应用程序本身之外播放、暂停或选择音乐曲目。虽然窗口小部件倾向于显示上述三种类型的属性，但许多窗口小部件结果是混合窗口小部件，它结合了这些不同类型窗口小部件的设计元素。

#### 滑动视图:现代设备更高效的内容浏览

Efficient content navigation is one of the hallmarks of a well-designed digital application. While websites and apps have historically been built in a hierarchical fashion, where many levels of information nesting and scrolling are the norm, there are many instances on most consumer electronics devices where horizontal navigation can “flatten” vertical hierarchies, eliminate vertical scrolling, and make access to related data items faster and more enjoyable. Swiping views to the side allows your users to far more efficiently and effortlessly move from item to item, using simple swipe gestures. This makes browsing (consuming content) a more seamless experience.We will be creating some user interface design patterns during this chapter that involve swiping gestures that allow easy UI access and content browsing. For instance, you can swipe from tab to tab in a tabbed UI paradigm, which we will be looking at in detail. If your app uses an action bar tab user interface approach, the user will be able to simply swipe to navigate between the different page views.Now that we have reviewed some of the most important aspects of Pure Android and Android Design Patterns, let’s take a look at how we can get Android Studio 2.3 to create a Sliding UI Drawer paradigm for use in an Activity that does Sliding Drawer Navigation. After we create and test this bootstrap application, I will show you what the XML markup and the Java 8 code does to create this type of UI, which you can use in your own applications, user interface design and content delivery pipelines. As an Absolute Beginner, this is the fastest way that I can get you up and running using advanced, Pure Android 7.1.1 application design and programming.

## 创建滑动抽屉:只有在用户需要时才创建用户界面

First, let’s close the current MyApplication Hello Universe project. The way to do this in Android Studio is to use the File ➤ Close Project menu sequence, shown on the top left in Figure [8-1](#Fig1).![A324674_4_En_8_Fig1_HTML.jpg](A324674_4_En_8_Fig1_HTML.jpg)Figure 8-1.Use File ➤ Close Project to close Hello Universe MyApplication projectThis will close Android Studio and open up the Welcome to Android Studio dialog, which you get when you first install Android Studio 2.3, and which can be seen in Figure [8-2](#Fig2).![A324674_4_En_8_Fig2_HTML.jpg](A324674_4_En_8_Fig2_HTML.jpg)Figure 8-2.Welcome to Android Studio dialog, where you Start new Android ProjectsThere is a difference in this welcome dialog now, as you can see, since we have a project that we have developed, and now closed, but not deleted, which is shown on the top left of the dialog in blue. What this means that we can reopen this project, or any project(s) we have created and closed, at any time. This means that you can work on more than one project at a time.We will be using this feature during this book, as we reopen and enhance projects we will be creating during the next few chapters, as we add content, special effects, digital imagery (called “Drawables” in Android ), digital audio, and animation, among other things, as chapters continue to get more advanced throughout the book. This allows us to focus on Android Design Patterns during this chapter.During the rest of this chapter we will be exploring a popular user interface design paradigm that Android Studio will code for us using the Start a new Android Studio Project dialog series, which you are about to get some more practice using.Select the Start a new Android Studio project option seen in red in Figure [8-2](#Fig2).In the New Project dialog, seen on the left in Figure [8-3](#Fig3), name the application NavDrawerPattern. Target the core Android Phone and Tablet API (Figure [8-3](#Fig3) middle), and use a standard MainActivity naming convention for a main activity for this app.![A324674_4_En_8_Fig3_HTML.jpg](A324674_4_En_8_Fig3_HTML.jpg)Figure 8-3.Name app NavDrawerPattern, select Phone & Tablet API, name MainActivitySelect a Navigation Drawer Activity for your UI pattern, as seen in Figure [8-4](#Fig4).![A324674_4_En_8_Fig4_HTML.jpg](A324674_4_En_8_Fig4_HTML.jpg)Figure 8-4.Select the Navigation Drawer Activity for your Android Design PatternOnce you click Finish, Android Studio 2.3 will open with a NavDrawerPattern project already created for you, with the content_main.xml file open in an editing tab. For the rest of the section we will dissect how the XML UI definition is set up using four XML files in the app/res/layout folder. All of this can be seen in Figure [8-5](#Fig5).![A324674_4_En_8_Fig5_HTML.jpg](A324674_4_En_8_Fig5_HTML.jpg)Figure 8-5.Android Studio opens with NavDrawerPattern project and content_main.xmlAs you might have surmised, content_main.xml is where your application content will be displayed, and currently contains the bootstrap Hello World placeholder text, as you can see on the right side of Figure [8-5](#Fig5), in the Android Studio Preview pane.This content UI layout uses one of Android’s legacy layout container classes, the RelativeLayout design pattern , which, as you may have guessed, lays out your UI elements relative to each other. This is similar to the ConstraintLayout class, but you have to create the XML, whereas ConstraintLayout uses the Visual Design Editor.The RelativeLayout (layout container or ViewGroup) UI design pattern positions its children (widgets or View objects) in relation to each other as well as to the parent RelativeLayout container. It was created in Android V1 (API Level 1) using the ViewGroup superclass, which is a subclass of the View superclass, as you know. If you want to research the RelativeLayout class in greater detail, you can do so at the following Android Developer website URL:[https:// developer.android.com /reference/android/widget/ RelativeLayout .html](https://developer.android.com/reference/android/widget/RelativeLayout.html)As you can see in the XML markup in the center editing pane in Figure [8-5](#Fig5), the content layout ID is content_main, the layout_width and layout_height scale to fill the screen using a match_parent (the parent container’s dimensions) constant, the padding references the @dimens dimension constants in /app/res/values/dimens.xml.At the end of the RelativeLayout container parent tag there are two xmlns:tools parameters that wire up the content view to the rest of the application. Context references the MainActivity class and tools:showIn tells the content view to locate itself inside (under) the app_bar_main.xml UI definition, which we will be looking at after we look at the primary activity_main.xml top-level UI definition XML file.Next, let’s take a look at the activity_main.xml top-level UI definition that is called from the MainActivity.java class onCreate() method, as is standard operating procedure in Android application development. Right-click on activity_main.xml, and select the Jump to Source menu option to open this XML file in its own editing tab.As you can see in Figure [8-6](#Fig6), this is the user interface definition that wires most of the XML files in the res/layout and res/menu folders to create a navigation drawer, shown in the Preview area, on the right side of the Android Studio IDEA.![A324674_4_En_8_Fig6_HTML.jpg](A324674_4_En_8_Fig6_HTML.jpg)Figure 8-6.Right-click on activity_main.xml to Jump to Source to view DrawerLayoutThe UI definition uses a DrawerLayout class for the parent layout container and uses an <include> child class to include the app_bar_main navigation bar, which you know contains the content view as well. Over this slides a navigation drawer, which uses the NavigationView class to define the sliding UI drawer layout definition, as you can see in Figure [8-6](#Fig6), highlighted in red. The NavigationView child tag uses an app:headerLayout to reference a nav_header_main.xml file and the app:menu attribute to reference the activity_main_drawer.xml menu hierarchy definition as shown by red lines drawn between the XML editor onto the Project hierarchy pane, in Figure [8-6](#Fig6).This child NavigationView class is part of the support.design library’s widget package, and is a subclass of the FrameLayout class, which provides fixed UI layout design containers. This class was designed to be used to provide developers with a standard navigation menu for their application. This NavigationView will typically be nested inside of a DrawerLayout, so the drawer slides out with a menu of options in it. This menu’s selection options can be created using an XML menu resource file as we will see later on during this section. If you want to investigate this class further, you can visit the NavigationView page at the following developer URL:[https:// developer.android.com /reference/android/ support / design /widget/ NavigationView .html](https://developer.android.com/reference/android/support/design/widget/NavigationView.html)The parent DrawerLayout class is part of the support.v4 library’s widget package, as you see highlighted in blue at the top of Figure [8-6](#Fig6), and as a layout container, is created (subclassed) using the ViewGroup superclass. The DrawerLayout serves as the top-level container, in this case, that is a UI drawer, to contain UI elements. This class was designed to allow developers to relatively easily create interactive “sliding drawers” that can be pulled out from one (left or primary) or even from both (left and right) sides (also called “edges”) of the display screen.Drawer position and direction are specified using a layout_gravity attribute set in child views, in this case, NavigationView. This attribute constant will define which side of the user interface design you want the drawer to open from. This will be left or right, unless you are supporting multi-directional language (left to right as well as right to left), in which case you will use start or end. You should only define one drawer for each vertical edge of your UI. If your layout configures more than one drawer per side, an exception (an error) will be “thrown” at runtime.As you can see in Figure [8-6](#Fig6), you specify, using an <include>, the app_bar_main layout as a first child, setting width and height to match_parent using no layout_gravity. Next, add drawers as child views after the content view, and set the layout_gravity to left or start. Drawers commonly use match_parent for height with a fixed width; in this case, we use wrap_content, so that the drawer conforms to the menu content.As per the Pure Android design pattern guidelines, any drawer positioned to the left (or start) would always contain content for navigating around the application. Any drawer positioned to the right (or end) would always contain actions to take on the content in the content view. This preserves the Pure Android navigation to the left, actions to the right, design pattern present in the ActionBar and applications. If you want to research the DrawerLayout class further, visit the following URL:[https:// developer.android.com /reference/android/ support / v4 /widget/ DrawerLayout .html](https://developer.android.com/reference/android/support/v4/widget/DrawerLayout.html)Let’s drill down further into the UI design and take a look at the app_bar_main.xml file referenced in the <include> child tag in the <DrawerLayout> parent tag. Include is used to reference and nest a UI design component. Right-click the app_bar_main.xml file and select Jump to Source to open the tab seen in Figure [8-7](#Fig7).![A324674_4_En_8_Fig7_HTML.jpg](A324674_4_En_8_Fig7_HTML.jpg)Figure 8-7.Right-click app_bar_main.xml; Jump to Source and view CoordinatorLayoutAs you can see, this UI design component uses CoordinatorLayout, and references content_main.xml using another child <include> tag, as shown in red. Above the content view is an <AppBarLayout> layout container child tag containing a <Toolbar> widget as its child tag. Below the content view is a <FloatingActionButton> widget.Android’s CoordinatorLayout class is part of the Android support design library and widget package as you see highlighted in blue at the top of Figure [8-7](#Fig7), and as a UI layout container, is created using the ViewGroup superclass. A CoordinatorLayout is similar to a FrameLayout, and can be used to create fixed, top-level application user interface design such as a navigation bar over a content view, as Android Studio is doing here. It is used as a layout container to coordinate interactions between one or more child views, in this case, this includes a Toolbar, a FloatingActionButton, and the content view. To learn more about the CoordinatorLayout, visit this URL:[https:// developer.android.com /reference/android/ support / design /widget/ CoordinatorLayout .html](https://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.html)A Toolbar layout container is also a ViewGroup subclass, added in Android 5 API Level 21 to provide a standard toolbar for use in application content or UI design. The Toolbar design element is a generic ActionBar for use with application layouts. Whereas the Android ActionBar is part of an Activity that is controlled by the Android framework, the Toolbar is controlled by the developer and can be located at any (nesting) level of your UI design view hierarchy. An application can even designate this Toolbar to serve as the ActionBar for your Activity. This is done by using the .setActionBar() method call or the .setSupportActionBar() method call.From left (or start, for bidirectional text language support) to right (or end) a Toolbar UI element can contain a number of different types of nested UI elements. The most common, located on the left, would be a navigation button, which can be seen as a three-bar icon in the Toolbar for the app on the left side in Figure [8-12](#Fig12) in the AVD. Notice that your Android Studio Preview does not include this, as it is passed through from the OS to the Toolbar using the .setSupportActionBar() method call. Navigation elements supported include the Up arrow, navigation menu icon, close icon, collapse icon, finished icon, or another icon of the application developer’s choice. This button should be used to access navigation destinations within Toolbar UI layout container. The navigation button icon will be vertically aligned with, and scaled relative to, the Toolbar height attribute.You can include a brand (sometimes called a “logo”) image for your application, and this will come next in the Toolbar. This will be vertically aligned with, and scaled relative to, the Toolbar height attribute, and can be as wide as you like. I recommend a 2:1 or 3:1 aspect ratio, so you don’t take up too much of your Toolbar.Next comes a title, and (optionally) a subtitle. A title should be an indicator of the Toolbar's current position in the navigation hierarchy and content contained there. A subtitle, if present, should indicate any additional information about the current content. After the title you can optionally add one or two UI elements such as icons, if you have room, based on your logo and title size. The application can also dynamically add views to the Toolbar. They will appear at this center position within a Toolbar. If your Toolbar.LayoutParams attribute for a UI element indicates a Gravity value of CENTER_HORIZONTAL that view will attempt to center in available space that remains in the Toolbar, after all the other elements have been measured.The Action Menu, in this case the Settings menu item, will pin to the right (or end) of the Toolbar. This is shown in Figure [8-13](#Fig13) as three dots on the right side of the Toolbar. This offers important or typical actions along with an overflow menu for additional actions. Action buttons are vertically aligned with the Toolbar height. If you want to delve further into the Toolbar class, visit this URL:[https:// developer.android.com /reference/android/widget/ Toolbar .html](https://developer.android.com/reference/android/widget/Toolbar.html)The FloatingActionButton class does not involve the ViewGroup class and is thus a UI widget and not a UI layout container. It’s created using the ImageButton class, which is in turn created using the ImageView class (a direct View subclass itself).Floating action buttons are often used to expose actions (UI options) you wish to prioritize for your users. In this case, this is e-mail access, as you can see in Figure [8-7](#Fig7). These are earmarked using a circular icon, floating (using shadows) above the UI surface. These floating action buttons come in two sizes, default and mini. The size can be controlled with the fabSize (Floating Action Button Size) attribute, but most developers will use the Pure Android design constants provided.Because this class descends from ImageView, it inherits the .setImageDrawable() method, so you will be able to control the drawable (graphic) which is used in the Button using a .setImageDrawable(Drawable drawable) method call. The background color for this FloatingActionButton is preset to utilize your OS theme colorAccent attribute. If you wish to change the color, you can specify a different color using the .setBackgroundTintList(ColorStateList) method call.Whereas the app_bar_main.xml UI definition contains the AppBarLayout container, which contains the Toolbar, includes the content_main.xml UI definition and finally a FloatingActionButton, the nav_header_main.xml UI definition, shown in Figure [8-8](#Fig8), is referenced with a NavigationView layout container in the top-level activity_main XML UI definition. This combines it with the navigation menu, which we will be looking at next. This main navigation header design uses another “legacy” Android layout container from API Level 1 called a LinearLayout, which is used to create a horizontal or vertical (in this case) orientation collection of UI design elements.![A324674_4_En_8_Fig8_HTML.jpg](A324674_4_En_8_Fig8_HTML.jpg)Figure 8-8.Right-click on nav_header_main.xml; Jump to Source to view LinearLayoutThe LinearLayout container, seen in Figure [8-8](#Fig8), contains ImageView and TextView UI elements (View widgets) just like the Hello Universe application you designed in Chapter [6](06.html), so you already know what these widgets do for your UI design. The result of this design can be seen in the Android Studio Preview pane (on the right side).

### 为 UI 设计创建菜单结构:Android 菜单界面

In Android , most of the heavy lifting to create and implement a menu is done by Android OS, making this perfect for an Absolute Beginner title, so we’ll cover it here in Chapter [8](08.html). Developers design their Menu objects using XML menu definition files, contained in the app/res/menu folder, as seen on the left in blue in Figure [8-9](#Fig9).![A324674_4_En_8_Fig9_HTML.jpg](A324674_4_En_8_Fig9_HTML.jpg)Figure 8-9.Right-click activity_ main _drawer.xml and Jump to Source and view MenuAndroid supports several important types of menus, each of which have different features. Context menus are like right-click context-sensitive menus in popular OS platforms, and in Android these do not support key shortcuts and visual icons. The long-click on any UI or layout element is used to access these context menus (using a touchscreen) if a right-mouse button is not available to the user.Options menus are provided in the OS chrome (remember chrome is perimeter OS-provided UI functions and decoration), as shown in Figure [8-13](#Fig13). Icon menus don’t support item check marks, and can only display the “condensed” (shortened) title for each menu item.Expanded options menus become available if six or more menu items are visible. These can be accessed via a 'More' item in the icon menu and don’t show item icons. Pure Android design principles also recommend against using item check marks so the menu stays compact for the user. However, you can use them, if they are necessary.Menus can also feature submenus. Submenus do not support icons for menu items and do not allow nested submenu structures, to try to keep Pure Android menuing as simple as possible for the users.Android provides the Menu interface for managing the MenuItem objects contained in a Menu object. By default, every Activity supports an options menu of actions or options. You can add items to this menu and handle clicks on your additions. The easiest way of adding menu items is by “inflating” an XML file into the menu via the MenuInflater method. The easiest way of attaching Java code to clicks is via onOptionsItemSelected(MenuItem) and onContextItemSelected(MenuItem) method calls.The important thing for you to learn regarding menu design in Android is how to create the parent <menu> XML structure with child <group> and <item> substructures. This can be seen in the activity_main_drawer.xml file, which is seen in Figure [8-9](#Fig9).To view the activity_main_drawer Menu object XML definition, right-click on the XML file and select Jump to Source. As you can see, there is a parent <menu> object, which contains a child <group> object that contains four <item> MenuItem objects. These MenuItem objects each contain an ID, icon (drawable) and title (text) values, which provide Import, Gallery, Slideshow, and Tools menu options, in a sliding navigation drawer. The drawables are kept in the app/res/drawable folder and can be seen in Figure [8-14](#Fig14), if you want to see the actual files that are referenced.After the main menu group , there is an <item> tag used as a menu header, using only an android:title attribute (or parameter if you prefer that term). Since it is not a MenuItem that will generate click events, it does not need an android:id attribute because the object will not be referenced in your Java code; it is simply decorative. There is a child <menu> tag under this <item> tag, which creates your submenu structure, under which are your child <item> tags, defining submenu items. Submenus are thus created using child <menu> objects under a parent <menu> object. There are two submenu items created using <item> tags for share and send functions.Finally, let’s right-click on the other application main.xml definition file and select Jump to Source and take a look at the Settings menu item available using the overflow (three vertical dots in the ActionBar) menu, as shown in Figure [8-10](#Fig10). The main.xml holds the top-level menu for the application, and uses the same design process of a parent <menu> tag and child <item> tags; in this case, the settings for the application are all that we need in the menu, at least for the moment. We could add a Help menu item, for instance, to explain how this application should be used.![A324674_4_En_8_Fig10_HTML.jpg](A324674_4_En_8_Fig10_HTML.jpg)Figure 8-10.Open the menu.xml application menu; preview your Settings menu (right)Now that we’ve taken a look at how the XML UI design definitions have been put together, let’s take a high-level view of how this all wires together, to cement how this all works together in your mind, and then we’ll run the application in the AVD and see how it works. Then we’ll look at the Android Manifest XML definition, and finally at how the Java 8 code works.

#### 可视化 UI 设计:XML 和所用类的高级视图

Let’s visualize the complex layout using a diagram, which can be seen in Figure [8-11](#Fig11), since there is a lot of nesting (at least three levels of nested XML definitions) and Java classes used within all of these XML definitions. As an Absolute Beginner, you should always do this, either in your head or on paper (or using GIMP, as I did), to make sure that you comprehend exactly what’s going on in Android to create a design pattern, using Android’s View (widget) and ViewGroup (layout container) classes. As you become a more advanced Android developer, you’ll need to do this less and less.![A324674_4_En_8_Fig11_HTML.jpg](A324674_4_En_8_Fig11_HTML.jpg)Figure 8-11.High-Level Diagram of XML definitions, references, and classes utilizedAs you can see the top-level activity_main.xml UI design pattern definition has the DrawerLayout class as its parent tag, and as the parent class, from a UI design perspective. As you can see in the right side of Figure [8-13](#Fig13), when the options menu (the three horizontal bar icon) is clicked, the sliding drawer will cover the other major UI components (ActionBar, or AppBar, and main content view), and contains the navigation header and drawer menu system, seen on the right portion of Figure [8-11](#Fig11).The app_bar_main.xml second-level definition, seen on the left, handles the AppBarLayout, which contains the Toolbar, using the CoordinatorLayout to combine this AppBar with the FloatingActionButton, and uses an Include to tie in the third-level content_main.xml definition, which contains your content for each screen referenced using the Menu’s MenuItems. This is also contained in this top-level DrawerLayout.The nav_header_main.xml is contained in a NavigationView in the DrawerLayout, and uses LinearLayout to build a header bar for the sliding drawer using an Image (ImageView) and Text UI elements. Also contained in this NavigationView is your activity_main_drawer.xml Menu object definition, with four MenuItem objects in one group and two MenuItems at the end of the Menu definition that are not in a group.

#### 在 Nexus 5 AVD 中预览 UI 设计:渲染 UI 设计

Let’s use your Nexus 5 AVD, and preview the design in an Android device, so you can see the menu icon in the app_bar_main.xml, which is provided by the Android OS menu system but which is not (as yet) supported in the Android Studio Preview pane. Use the Run ➤ Run ‘app’ menu sequence, and launch the AVD, as shown in Figure [8-12](#Fig12). Select the Nexus 5 and click the OK button. After the AVD loads into memory the app will launch in the emulator, which you can see in Figure [8-13](#Fig13). Click the menu icon, to make sure a UI drawer slides onto the screen, seen on the right, in Figure [8-13](#Fig13).![A324674_4_En_8_Fig12_HTML.jpg](A324674_4_En_8_Fig12_HTML.jpg)Figure 8-12.Use the Run menu to run the app, which will initialize the Nexus 5 AVDClick on menu items to make sure they do nothing, for now. The menu will close.![A324674_4_En_8_Fig13_HTML.jpg](A324674_4_En_8_Fig13_HTML.jpg)Figure 8-13.Click the Menu icon at the top left and test the sliding nav drawerNow that we have tested (and analyzed) the Android Studio code, let’s take a quick look at the Android manifest, and then dive into the Java code, which is the most complex part of the Android application created by Android Studio for you.

#### 应用程序配置 XML:Android manifest . XML

All of this functionality does not require any special Android manifest XML definition permissions, and only a couple of new settings, which we will go over in this section, to reinforce your knowledge of working with the Android manifest XML.As you can see in Figure [8-14](#Fig14), highlighted in green, Android Studio has set the android:label attribute, for both the <application> and the <activity> section, to label the app NavDrawerPattern.There is a new attribute (parameter) called android:supportsRtl that turns on the bidirectional screen language display (LTR or RTL for some non-ASCII languages), which is highlighted in yellow in Figure [8-14](#Fig14). This is why we are using start instead of left and end instead of right in the UI design XML definitions in this chapter, and since this is an application-wide setting it is in the <application> tag, along with the android:theme, android:icon and android:allowBackup parameters, which you are already familiar with, from the first application we created earlier.Also, notice that in the <activity> tag we set the NoActionBar application theme since we have provided our own decorative ActionBar in this user interface design. In the next section, you will see how to make the AppBarLayout and its Toolbar into the ActionBar for this UI design pattern using Java methods of the Activity superclass, allowing us to use the NoActionBar theme to remove the Android OS ActionBar, which would be redundant (and confusing to the user) since the UI design provides one of its own, with features customized to the sliding drawer UI pattern.![A324674_4_En_8_Fig14_HTML.jpg](A324674_4_En_8_Fig14_HTML.jpg)Figure 8-14.Right-click AndroidManifest.xml, and Jump to Source to preview the XMLNext, let’s get a bit more advanced, and take a look at what the Java code is doing for this admittedly more advanced sliding drawer Android application design pattern, while at the same time learning more about the Android classes involved in making this main activity reference the UI design XML, and making it interactive.

#### 应用程序编程逻辑:查看 Android API Java 代码

Finally, let’s get a bit complicated (for the Absolute Beginner, at least), and take a look at the MainActivity.java code generated by Android Studio. Click on the MainActivity.java editing tab, shown selected on the left in Figure [8-15](#Fig15), and look at five methods that comprise this public class, which extends AppCompatActivity, which we covered in detail earlier in the book, in Chapter [6](06.html), and which implements a NavigationView.OnNavigationItemSelectedListener Java interface. Let’s start with the smaller (shorter) methods, which deal with menu processing and UI navigation, and then cover the two larger (longer) methods that deal with the event processing (onNavigationItemSelected) and creating the objects for the application in system memory (onCreate). All this code is needed to make the sliding UI fully functional.![A324674_4_En_8_Fig15_HTML.jpg](A324674_4_En_8_Fig15_HTML.jpg)Figure 8-15.Click on the MainActivity.java editing tab to look at the five methodsThe public Boolean onCreateOptionsMenu(Menu menu) method creates the options menu in system memory by inflating (turning XML definitions into Java objects) an XML menu definition, called main.xml, in your app/res/menu/ directory, by using the getMenuInflater().inflate() method , and returns a true value to the calling method, signifying the menu is inflated into memory. Your method Java code looks like this:@Overridepublic boolean onCreateOptionsMenu(Menu menu) {getMenuInflater().inflate(R.menu.main, menu);return true;}Although used with a Menu object, onCreateOptionsMenu(Menu menu) is a part of the Activity superclass, and therefore its subclass. This is where you’ll initialize the contents of your Activity’s options menu, using a MenuInflater object using a method chain. The getMenuInflater() method chains to (calls) the .inflate() method, which takes the XML Menu object definition and loads it into the Menu object named menu. After this has been done, the onCreateOptionsMenu() method returns true, to signify successful inflation of the Menu object named menu, passed into the method.Although also used with the Menu class, onOptionsItemSelected(MenuItem item) is also a part of the Activity superclass, and therefore its subclasses. This is where you process your menu item selections in your Activity’s options menu, by using the .getItemId() method from the Adapter class (object) that is used to process lists.This method takes a MenuItem object named item passed into the method, and then calls the .getItemId() off of that item MenuItem object, and places that integer value into an id variable, which is then processed using an if-then-else loop, to determine which MenuItem has been selected by the user. In this case, if the “Settings” MenuItem has been selected the method will return a true value. Finally, the method calls the superclass method with the same name, for further processing, using super.onOptionsItemSelected(item), using the following Java code method structure:@Overridepublic boolean onOptionsItemSelected(MenuItem item) {int id = item.getItemId();if (id == R.id.action_settings) { return true; }return super.onOptionsItemSelected(item);}The onBackPressed() is also a part of the Activity superclass, and therefore each of its subclasses. This is where you define what is to be done when the Back button is used in the Android OS or the Android device hardware. In this case, this will close the sliding drawer UI, if it is open, or pass the onBackPressed() up to the superclass for further processing using the super keyword, if the sliding drawer UI is closed. The Java 8 code will look something like this:@Overridepublic void onBackPressed() {DrawerLayout drawer = (DrawerLayout)findViewById(R.id.drawer_layout);if (drawer.isDrawerOpen(GravityCompat.START) { drawer.closeDrawer(GravityCompat.START); }else { super.onBackPressed(); }}What this does is to instantiate a DrawerLayout object (named drawer), and call the .isDrawerOpen() method, to see if the sliding drawer is open on the screen. If it is, the .closeDrawer() method is called to close the drawer. The GravityCompat class (a backwards compatibility gravity constants helper class defining constants) is used with the START constant we have been using for our bidirectional interface design (supports RTL and LTR text and user interface design). If the drawer is not open, then the else part of the statement passes the onBackPressed() method call up to the superclass for processing, using super.onBackPressed().The onNavigationItemSelected() method also takes in a MenuItem object named item as its input and processes it, however, this menu is the one inside of the drawer, not in the Activity menu, which has only one Settings option. This menu is accessed through a NavigationView parent, as you saw earlier in the XML definition.Our Activity subclass definition implements a NavigationView Java interface for the onNavigationItemSelectedListener, using the following class declaration code:public class MainActivity extends AppCompatActivityimplements NavigationView.OonNavigationItemSelectedListener { code body }The next method that we need to examine is onNavigationItemSelected(MenuItem). This is in the body of our class code due to the implements keyword, which wires in the NavigationView.onNavigationItemSelectedListener interface, and therefore requires that we override this method with one of our own, which processes MenuItem selections. Since this is an “empty method body” for now, while we get the bootstrap infrastructure code working, we need to add the @SupressWarnings statement, telling the Android Studio compiler that our application UI doing nothing is not an error, and that we know what we are doing, so it can suppress the errors regarding this.@SupressWarnings(“StatementWithEmptyBody”)@Overridepublic boolean onNavigationItemSelected(MenuItem item) {int id = item.getItemId();if (id == R.id.nav_camera) { // Camera Logic Here }else if (id == R.id.nav_gallery) { // Gallery Logic Here }else if (id == R.id.nav_slideshow) { // Slideshow Logic Here }else if (id == R.id.nav_manage) { // Manage Logic Here }else if (id == R.id.nav_share) { // Share Logic Here }else if (id == R.id.nav_send) { // Send Logic Here }DrawerLayout drawer = (DrawerLayout)findViewById(R.id.drawer_layout);drawer.closeDrawer(GravityCompat.START);return true;}The actual onNavigationItemSelected() method takes in a MenuItem object, names it item, inside of the parameter area of the method, and processes it within the body of the method and returns a Boolean result (true if the processing completed).Inside the method an id integer variable is created and assigned to the item ID value using a .getItemId() method call. The majority of the method body is a 6-line if-else-if evaluation loop that ascertains which MenuItem has been clicked by using XML ID values referenced by using the R.id.name method used by Android to reference XML-defined application UI objects.After the if-else-if processing, a DrawerLayout object is instantiated, and the .closeDrawer() method is called with the GravityCompat.START constant to show which direction the drawer should slide shut. When you tested this application, you saw that selecting any of the menu options automatically closes this sliding UI drawer.Let’s split the onCreate() into logical sections to examine it object by object to see how the sliding drawer UI is inserted to memory and controlled by the events queue (CPU). The first two lines of onCreate() are standard fare in Android, and set up the object’s instance states in a Bundle passed up to the Activity class onCreate() using the super keyword, and wire the ContentView object to your top-level UI definition, activity_main, which we analyzed during the first two-thirds of this chapter. After that Android instantiates a Toolbar object named toolbar and wire it up to the <toolbar> definition seen in the middle of Figure [8-7,](#Fig7) by using an android:id parameter, inside of a findViewById(Resource) method call. The next line sets support for that Toolbar object named toolbar to serve as the ActionBar object for the Activity. The code for this Activity creation and Toolbar instantiation looks like the following:@Overridepublic void onCreate(Bundle savedInstanceState) {super.onCreate(savedInstanceState);setContentView(R.layout.activity_main);Toolbar toolbar = (Toolbar)findViewById(R.id.toolbar);setSupportActionBar(toolbar);The next section of code instantiates the FloatingActionButton object and names it fab, referencing the UI widget’s XML definition in app_bar_main.xml using the ID parameter. Then it uses the fab object to call the .setOnClickListener() method and sets up an onClick() event handler structure , which you learned about in Chapter [7](07.html).FloatingActionButton fab = (FloatingActionButton)findViewById(R.id.fab);fab.setOnCLickListener(new View.OnClickListener() {@Overridepublic void onClick(View view) {Snackbar.make(view, "Replace with your own action", Snackbar.LENGTH_LONG).setAction("Action", null).show();}});Inside of the onClick() event handler Android Studio 2.3 creates a Snackbar object, using the Snackbar.make() method call, and chains a .setAction() and .show() method call to this creating a Snackbar.make().setAction().show()code chain. The .make() method takes in the onClick() method’s view object, the message, and the Snackbar.LENGTH_LONG constant, which defines the length of time to display the message. The .setAction() method allows users to interact with a Snackbar, and allows you to specify the button name value, in this case “Action” and the action to execute, for this empty bootstrap application this is currently null (do nothing).Android Snackbar is a fairly new class, which is used to display brief messages on the lower portion of the screen to update users as to what is happening with the processing of your application logic for the current action or operation. Snackbars appear above all the other UI elements on the screen. One Snackbar can be displayed at a time, and will automatically disappear, after the specified length of time, or after user interaction elsewhere on the screen. Snackbars may be swiped off-screen.The next section of code instantiates a DrawerLayout object and names it drawer and references the DrawerLayout ID of drawer_layout, in the activity_main.xml file. Then an ActionBarDrawerToggle object is instantiated and named toggle, using a Java new keyword and the ActionBarDrawerToggle() constructor method, which takes Context (this), DrawerLayout and Toolbar objects, as well as content description strings to be used by users who may have physical impairment, such as blindness, for instance.DrawerLayout drawer = (DrawerLayout)findViewById(R.id.drawer_layout);ActionBarDrawerToggle toggle = new ActionBarDrawerToggle( this, drawer, toolbar,"Open navigation drawer","Close navigation drawer" );drawer.setDrawerListener(toggle); // Deprecated Method!toggle.syncState();The ActionBarDrawerToggle class provides an object that will wire together the functionality of this DrawerLayout sliding drawer UI design pattern and the Android ActionBar functions, which have been replaced with a custom Toolbar in this design.The .setDrawerListener(toggle) method call off the drawer object wires the DrawerLayout object to the toggle ActionBarDrawerToggle object. You will notice that this method is deprecated (lined-out in Android Studio) which means that it is scheduled for removal from the API. We will look at the solution to this in the next section. The final line of code calls the .syncState() method off the toggle object. This synchronizes the toggle indicator with the state of your DrawerLayout.The last two lines of Java code instantiates a NavigationView object, and names it navigationView and uses the nav_view ID in the activity_main.xml UI definition file to inflate the NavigationView object, configuring it with the specified XML parameters, which can be seen in Figure [8-6](#Fig6). Notice that you do not always have to use an .inflate() method to configure (inflate) a Java object with XML specified parameters in Android. Finally, the .setNavigationItemSelectedListener(Context) method call is used to attach an event listener to the NavigationView object.NavigationView navigationView = (NavigationView)findViewById(R.id.nav_view);navigationView.setNavigationItemSelectedListener(this);Finally, let’s take a look at how you would deal with recently deprecated code, so that you know the work process regarding how to research this scenario using the search engine of your choice (since I am a Google Android and Chrome developer, I’d logically select Google for this task).

## 弃用的 Java 代码:研究替代 API

The last thing I want to show you in this chapter, since Android Studio coded a deprecated method that was lined-out in the editing pane, which to me is not optimal, is how to research what to do if the Google Android OS Development Team takes away one of your API calls that you are utilizing for your application. The fastest way to find a solution is to use a keyword pair “API-component deprecated,” in this case, this would put setdrawerlistener deprecated in your search bar, as is shown at the top of Figure [8-16](#Fig16). As you can see in the search result, you’ll often find the solution to the problem in the short description of the search listing, in this case, “Use addDrawerListener( ) instead” as shown at the bottom of Figure [8-16](#Fig16).![A324674_4_En_8_Fig16_HTML.jpg](A324674_4_En_8_Fig16_HTML.jpg)Figure 8-16.Search for information with search term “setdrawerlistener deprecated”It can often be that easy, and luckily, it is here, since this is an Absolute Beginner title! So, let’s try this simple solution, and see if it works. Click on the MainActivity.java editing tab and change the onCreate() method’s fourteenth line of code, drawer.setDrawerListener(toggle); to be drawer.addDrawerListener(toggle); as can be seen highlighted in light blue and yellow near the bottom of Figure [8-17](#Fig17). No wavy red error highlights appear, so the next step is to use a Run ➤ Run ‘app’ menu sequence and test the application in the Nexus AVD emulator to see if it works the same way.![A324674_4_En_8_Fig17_HTML.jpg](A324674_4_En_8_Fig17_HTML.jpg)Figure 8-17.Replace the .setDrawerListener(toggle) with .addDrawerListener(toggle)I will forgo another screenshot that would be a duplicate of Figure [8-13](#Fig13), as the application works in exactly the same way as it did with the deprecated method call. Congratulations, you have now created a second more advanced user interface design pattern, which we can enhance during the second half of the book with new media assets and special effects as we learn about advanced Android API components .

## 摘要

In this eighth chapter, you learned about Android design patterns, as well as implementing a sliding drawer user interface, which conforms to the sliding/swiping UI design pattern, as well as the concept of optimizing screen real estate, so the user has the best experience possible.We covered Android design patterns, including material design; hardware device characteristics; specialized APIs; future APIs, for emerging market verticals; and Pure Android concepts, such as accessibility, compatibility, confirmation, acknowledgment, widgets, swiping, and sliding view designs.Next we looked at another popular Android design pattern and learned how to have Android Studio create this design pattern for us, using the Create New Android Application series of dialogs. We analyzed the XML markup, user interface design, and Java programming logic to learn new Android API components and design concepts.We learned how to diagnose and solve deprecated API components, even if these are introduced by Android Studio, and how to correct and test these upgrades and get a clean, functional application.Next, in Chapter [9](09.html), you’ll learn about digital imaging concepts, and how to use digital image assets in Android applications, like NinePatch assets and multi-state ImageButton user interface elements. We’re going to start getting more advanced from this point on out in the book, so you will no longer be an Absolute Beginner!