© Wallace Jackson 2017Wallace JacksonAndroid Apps for Absolute Beginners10.1007/978-1-4842-2268-3_6

# 6.Android 用户界面设计:使用 Activity、View 和 ViewGroup 类

Wallace Jackson<sup>1</sup>(1)Lompoc, California, USANow that you’ve been exposed to the Android 7 operating system and have seen how it works from a high-level view, using XML and Java, and how these are used in Android application development, the next thing we need to do is take a closer look at how Android addresses, or writes things to, a device screen, to display UI and content.In this new age of touchscreen devices, such as smartphones, tablets, e-book readers, and smartwatches, your display screen has become the center of not only the visual feedback for the application but also for interacting with it. This chapter will cover those classes that allow your Android app to write things to the device display screen, such as your Activity class; core User Interface (UI) classes ; and, of course, your Android application primary subject matter, text, audio, video, animation and graphics content.There are some very important Android superclasses, such as Activity, View, and ViewGroup, which provide a foundation for the subclasses that you will utilize to get your application content and UI onto the display screen. These superclasses are not used directly in your application, but you need to know about them nonetheless.We will look at AppCompatActivity subclasses, which provide support across all Android versions, and can be utilized for organizing your application’s functional screens, which ultimately will provide the structure for your end-user’s workflow; let’s call it the “use-flow” for your Android application.We will look at View subclasses used for creating your application’s UI element components, which as you know are known as widgets in Android jargon. We’ll look at the ViewGroup subclasses, used for creating Android UI layout containers. Layout containers are used to contain View (subclassed) UI widgets, which make up the body of the UI design, providing the UI layout with its functionality. Since Android Studio now has drag-and-drop UI design functionality, we will use the UI layout compatible with the Application Compatibility (AppCompat) Android 7 backward support (support.v7) library. This is so that I can show you how to develop Android 7.1.1 applications with as little coding and XML markup as possible, leveraging Android Studio 2.3 as thoroughly as possible.Finally, you will put all of this newfound knowledge to use and will create your first original Hello Universe UI design so that you get some hands-on experience in creating your own UI design. We will create a Hello Universe Galaxy and Smiley Face user interface design for your Hello World bootstrap application.

## Activity、View 和 ViewGroup 类如何相互关联

Before we look at the Android Activity, View, and ViewGroup UI superclasses and their more functional subclasses (those classes that you should actually utilize to construct your apps), it is important to understand how these relate to each other, within the user interface design and display context of your Android 7.1.1 application.The reason I am not including the Menu superclass and its functional subclasses in this chapter is because Android menus are handled separately from UI widget View and UI layout ViewGroup UI design elements. Menus pop up over a screen triggered by a hardware MENU button or the ActionBar Overflow menu. For this reason, we are going to cover Menu objects separately, in a future chapter.As you’ve learned already, the Android runtime environment (ART) resides on top of a Linux kernel, and talks to the Android 7.1.1 OS, under which your application executes (or runs). Your application defines itself to ART using the AndroidManifest.xml application definition XML file that we looked at in detail, in Chapter [4](04.html).For each functional display screen in an app, which will generally contain some sort of UI design, as well as related app content, your application will define an Activity subclass . Your Hello World application currently has one of these Activity subclasses already, as you saw in Chapter [3](03.html) in Figure [3-8](03.html#Fig8) with an AppCompatActivity Activity subclass, used in your public class MainActivity extends AppCompatActivity declaration at the top of the class.Each Activity subclass in your Android application would be required to have an .onCreate() method defined, and this method will in turn be required to contain the setContentView() method call, to load a user interface ViewGroup (layout), and View (widget) UI elements. The setContentView() parameters contain the reference to your Activity subclass’s UI layout XML definition. For the MainActivity.java class, this reference is R.layout.activity_main, which is Android shorthand to reference the /res/layout/activity_main.xml file, as you can see in Figure [3-8](03.html#Fig8), which, after our Java primer during Chapter [5](05.html) should be making a whole lot more sense to you!A parent tag in a UI layout XML definition will generally reference a ViewGroup subclass such as the ConstraintLayout class, which in the activity_main.xml file is represented by a <ConstraintLayout> parent tag. The ViewGroup superclass in Android is used to subclass (create) custom layout container classes in Android, which I’ll be covering in detail throughout the rest of this book. There are a large number of custom layout container classes in Android, because these UI layout classes provide the foundation of UI design in Android.Inside of ViewGroup UI layout container parent tags are child tags representing UI elements, which are called widgets in Android. UI widgets are based on Android’s View superclass . Each widget, like that <TextView> child tag you used in Chapters [3](03.html) and [4](04.html), references your Android TextView widget class, which is subclassed using the View superclass. Inside each (View subclass) UI widget child tag, you set parameters that reference the new media assets for your application, such as drawables (images and bitmap animation), animation (procedural, tween, or vector animation), audio or video, scalable vector graphic (SVG) shapes, custom UI elements and similar assets.Thus, getting your app’s assets onto the Android device display screen involves putting parameters in child widget tags inside of parent UI layout tags referenced by the Activity subclass that you have declared in the application Android manifest XML file. All of this can be done in Android Studio.Code is passed over to the ART engine, which then converts all this into machine language, and then passes it over to the Linux kernel, whose job it is to interface the OS software with the hardware, and to render your application’s UI design and content to the Android device display screen hardware with pixel-perfect accuracy. Whew! This chain from Android Runtime to app resources looks like this:Android RunTime > Manifest > Activity Subclass > ViewGroup Parent Tag > View Child Tag > ResourcesTo make this even easier to visualize, I created a diagram, seen in Figure [6-1](#Fig1), which shows layers (and connections) between your application’s new media resources, your UI widgets that hold them, UI layouts that hold your UI widgets and resources, and the Activity subclasses that defines and control your UI layout XML definition, by referencing it using your .setContentView() method call. It is important to note that since you can set a background image or animation for the UI layout container, so a ViewGroup can also reference new media resources; thus, the new media resource area of the diagram in Figure [6-1](#Fig1) connects with both View and ViewGroup subclasses.![A324674_4_En_6_Fig1_HTML.jpg](A324674_4_En_6_Fig1_HTML.jpg)Figure 6-1.Stratification of Android app, from new media resources up to executionAs you learned in Chapter [3](03.html), your Android manifest defines for ART what Activity classes an application contains, as well as what your application is allowed to do; and other information about your application’s version history, support, structure, permissions, communications, intents, network access, Google Play access, and so on.Next, you will take a closer look at the relationship between ViewGroup (layout container) and View (UI widget) superclasses in Android, since the ViewGroup superclass is actually a subclass of the View superclass . It is interesting to remember that a superclass can also be a subclass.ViewGroup inherits characteristics from View like margin settings, which as you will see, are supported in both layout containers (ViewGroup subclasses) as well as UI widgets (View subclasses), thanks to Java inheritance and how well the Android OS developers have designed and coded the user interface design superclass structures.

### ViewGroup 类:View 的一个已知的直接子类

Even though View widgets are nested inside of ViewGroup layout containers, the ViewGroup superclass is actually subclassed from the View superclass in Android’s Java class hierarchy. Starting with the Java Object master class, the inheritance hierarchy is structured as follows:java.lang.Object> android.view.View> android.view.ViewGroupThe reason that the Android OS development team structured the View class hierarchy in this fashion is because View class attributes such as top, bottom, left, and right margin attributes (properties, or parameters), should also be available for use in a ViewGroup layout container, as well as in every View UI widget. So, the logical Java structure would be subclassing ViewGroup from View, so that the ViewGroup subclasses inherit all of those same variables, constants, and methods that the View subclasses will include.If you look at the ViewGroup class documentation page, on the Android developer website, you will see that the ViewGroup class has 18 known direct subclasses . Some of the most common UI layouts include your LinearLayout, for horizontal or vertical UI design; GridLayout for grid UI design; Toolbar for UI toolbars; ViewPager for UI page viewing; DrawerLayout and SlidingDrawer for UI in drawers; AbsoluteLayout and FrameLayout for fixed layouts, or fullscreen content; SlidingPaneLayout for sliding UI design; TvView for iTV set UI design; RecyclerView for efficient, long-item list UI design (recycles or optimizes memory use); and several others for specialized UI.NoteA known direct subclass is a subclass that has been created from the class that is being documented on that developer website class reference page. Known means it has been officially added to the Android API. If you subclass your own Android class, it would be called an unknown direct subclass, because it is unknown to the public Android API. A known indirect subclass will represent a subclass of a known direct subclass. It is indirect to the class being documented, because it is more than one level away from, and not a direct subclass of the documented class.There are 55 known indirect subclasses of this ViewGroup class. These are the subclasses of the 18 known direct subclasses. These are even more highly customized user interface layout container classes, and thus you have around 75 user interface layout containers to choose from. There are a couple that have not yet been added to the developer documentation since they are new in Android 7, including the one we are going to using with the Visual UI Layout Designer tool (ConstraintLayout).You’ll be learning about some of these UI layouts over the course of this book. ViewGroup UI layout subclasses are just as important as View UI widget subclasses; however the ViewGroup class doesn’t have as many subclasses as the View class does. If you want to explore the ViewGroup documentation further, it’s found at this URL:[http://developer.android.com/reference/android/view/ ViewGroup.html](http://developer.android.com/reference/android/view/ViewGroup.html)We’ll be looking at several popular ViewGroup subclasses during the rest of the book. When using ViewGroup subclasses, termed UI layout containers in Android, and View subclasses, termed UI widgets in Android, your View widgets will be contained inside of the ViewGroup layout containers. This is why the ViewGroup class is named the way it is, as it groups View objects together into a UI layout design, as shown in Figure [6-2](#Fig2). The ViewGroup layout container specifying your user interface design is then referenced inside of, and contained in, your Activity using R.layout.uiName inside of a setContentView() method that loads the UI and content into the display.![A324674_4_En_6_Fig2_HTML.jpg](A324674_4_En_6_Fig2_HTML.jpg)Figure 6-2.Activity contains UI created using ViewGroup layout and View UI widgetsIt’s important to note that even though a ViewGroup subclass must be used for a parent object in an XML UI layout design, ViewGroup subclass objects might also be nested underneath a parent ViewGroup, such as a LinearLayout UI containing Buttons.ViewGroup objects are able to be used as both parent and child objects, whereas View widgets are child UI design element objects. Hands-on experience is the best way to show you all of this UI design theory, which we will be doing a bit later on during this chapter as well as during the second half of the book. Before we get into more UI design, let’s take a closer look at the Android View superclass.

### 视图类:用户界面设计的基础

As you may have surmised from its class name , a View object is designed to hold anything that needs to be viewed in an Android app using the device display screen. Since devices are almost 100% comprised of display screen on their front; this is ostensibly the most important class in Android at least from your visual design and user interface usability standpoint. Since I already showed the class hierarchy in the previous section, this time I will show you the View class declaration from the developer documentation (this is always at the very top of the class documentation):public class Viewextends Object implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSourceThis tells us that View can be publicly used by all Android application classes in the API, that it extends the Object superclass, and that it implements Java interfaces for graphics (Drawable.Callback interface) and interactivity (KeyEvent.Callback interface), and supports users with disabilities (AccessibilityEventSource interface).If you look at the View class documentation page on Android’s developer website, you will see that this View class has a dozen known direct subclasses, one of which is the ViewGroup. Some of the most common UI widget objects are created using these classes include your ImageView, which you have already used in Chapter [4](04.html); TextView, which Android Studio created for you in Chapter [3](03.html); TextureView for texture mapping; SurfaceView for rendering graphics; AnalogClock for creating clocks; KeyboardView for creating virtual keyboards; ProgressBar for creating progress bars; and several utility classes relating to View user interface design.Because of ViewGroup, there are hundreds of known indirect subclasses for View, some of which we will be using during this book, but each of which we would not be able to cover even in one book, and especially in an Absolute Beginner Android book – as you can imagine. Even advanced Android users are not familiar with all of these! Many of them are covered in the 2014 Apress title Pro Android UI, however.If you want to take a closer look at what the Android View superclass includes, you can see for yourself, by visiting the following URL:[http://developer.android.com/reference/android/view/View.html](http://developer.android.com/reference/android/view/View.html)Whereas View subclasses in Android 7 control what you see on the screen, each Activity object controls how the Activity that hosts the View(s) and ViewGroup(s) start, load in memory, stop, and manage the View object hierarchy that you will create in the Android Studio Visual Design Editor .

### Activity 类:一个用户界面设计容器

As you’ve seen in Chapter [5](05.html), whereas a View UI design hierarchy is crafted with XML markup, an Activity is crafted using Java , and references that XML UI design definition. The Activity fuses the OS theme, as you can see below in the class definition that extends ContextThemeWrapper, with your user interface design. It implements Java 8 interfaces for UI inflation, window, keyboard, menu, and components.public class Activityextends ContextThemeWrapperimplements LayoutInflater.Factory2, Window.Callback, KeyEvent.Callback,View.OnCreateContextMenuListener, ComponentCallbacks2This tells us that an Activity inflates (turns XML elements into Java objects) your UI design, handles OS windowing calls, listens for ContextMenu usage, handles Android components, and passes through KeyEvents to user interface elements.If you look at the Activity class documentation page on the developer website, you will see that this Activity class has 7 known direct subclasses; the AppCompatActivity subclass you are using in your Hello World app is an indirect subclass of the FragmentActivity direct Activity subclass. Some of the most common Activity subclasses besides the indirect subclass AppCompatActivity, which allows your app to be used across all versions of Android currently in the marketplace, include the FragmentActivity, which allows you to assemble UI fragments into one Activity; ListActivity and ExpandableListActivity, which manage lists (i.e., data collections); and AccountAuthenticatorActivity, used for log-in (account authentication) screens. There is also a NativeActivity, declared in the manifest, for use with the Android NDK (Native C++ Development Kit) and an AliasActivity for aliasing Activity classes (also declared using the manifest), both of which are used for advanced Android developer use.There are five known indirect subclasses for Activity according to the Android documentation, including the AppCompatActivity used with the Visual Design Editor (ConstraintLayout), TabActivity (tabbed UI design), ActionBarActivity (ActionBar UI design), LauncherActivity (launchers of other activities), and PreferenceActivity (preference screen UI design). As you can see, Android offers Activity subclasses that are already customized for most of those application UI tasks you want to do. Android applications will almost always contain more than one Activity (functional screen with its own purpose and a user interface design to accomplish the purpose ).An Activity object in Android contains a single UI focused on a specific task or feature that your application offers to the user. Almost all activities interact with the user, so each Activity object must take care of creating a window, using a call to the Android OS so the user can interact with a UI that is loaded using the setContentView(R.layout.uiDesignName) method call. Activities are usually presented to a user in a fullscreen window. They can be used in floating windows (windows and their styling is called the operating system’s UI elements or “Chrome”) to simulate a conventional OS, using a theme with a windowIsFloating parameter set.All activity classes will have a corresponding <activity> declaration in their package Android manifest XML file. You have already seen this in Chapters [3](03.html) and [4](04.html) in your Android Studio AndroidManifest.xml editing pane. We’ll be adding more of these <activity> child tag (and their child tag) entries in the <manifest> parent tag as we add Activity UI design screens to our Hello World application during the first half of the book. You’ll be adding Activity UI screens for all apps created during this book, in fact, so be sure to understand the material contained in this chapter.There is one Activity class method Android classes must implement to get your UI design screen into system memory: the onCreate(Bundle), where you initialize the Activity object and use setContentView() to reference and load your UI design. You can also use six other Activity state methods, including onPause(), onResume(), onStart(), onStop(), onRestart() and onDestroy() to control what your Activity does throughout each of the stages of an Activity object’s life cycle. I have outlined these seven life-cycle states in Figure [6-3](#Fig3), and shown how they are logically paired and how they are logically classified in the create, utilize, and destroy phases of the Activity object (constructed using your Activity subclass) in your Android device’s system memory. As you can see creating and starting launch the Activity, a pause and resume can be used for a running the Activity, and a stop and destroy end the Activity life cycle. They are logically paired as one might expect from their names.![A324674_4_En_6_Fig3_HTML.jpg](A324674_4_En_6_Fig3_HTML.jpg)Figure 6-3.The Activity class (object) life cycle spanning creation to destructionIt is important to note that these other six methods do not need to be implemented, unless you wanted to do something other than what the Activity superclass will already do to make your Activity work well with other Android apps installed on the same end-user device. So if in onCreate() you opened up a socket on a media server, in onDestroy() you will want to close that socket so as not to hang your media server. If in onStart() you start streaming data of some kind, in onStop() you may want to stop streaming that data to save bandwidth. You may want to tell your users “Welcome Back” in onResume(), or check what your Activity is doing regarding its given functionality. You might want to resume your data stream onRestart(), for instance.If you want to take a closer look at what the Activity superclass includes, you can see for yourself, by visiting the following URL:[https://developer.android.com/reference/android/app/ Activity.html](https://developer.android.com/reference/android/app/Activity.html)Next, let’s get back into UI Design in Android Studio, using the Design Editor.

## 从头开始创建 UI 设计

Let’s use all of this knowledge you have learned over the past few chapters and implement a new Activity. The first step that we need to take to do this is to do a UI design for the screen that the Activity will display; in this case that would be your Hello Universe screen, which you can select at the bottom of the current Hello World user interface in your main Activity (activity_main.xml). In the last half of this chapter we will learn how to design a user interface design from scratch using your Android Studio Design Editor, which will write your XML for you. Over this chapter, and the next one on interactivity, we will connect these two Java Activity classes together using interactivity (Events and Intents). Since this chapter is on user interface design, we will focus on creating your new user interface design XML definition , called activity_universe.xml, so we have everything we need for Chapter [7](07.html), where we will focus on the Java programming part of creating this new Activity.Let’s fire up Android Studio to create a new user interface design XML definition for the new Activity we’re going to create in Chapter [7](07.html). As you will see in Figure [6-4](#Fig4), Android Studio does a Gradle build on your current project, when you first start the IDE. If there are any issues, or problems, the Gradle Build Messages window (pane) appears at the bottom. Android requires lowercase letters and numbers to be used in asset file names, so it points out the SmileyFace PNG32 asset uses the capital S, and advises us that “File-based resource names must contain only lowercase a-z, 0-9, or underscore” characters. So, let’s fix this now!![A324674_4_En_6_Fig4_HTML.jpg](A324674_4_En_6_Fig4_HTML.jpg)Figure 6-4.Gradle build upon Android Studio launch reveals a file naming errorFind your SmileyFace.png file in your User/AndroidStudioProjects/MyApplication/ folder hierarchy on your hard disk drive, and rename it to smileyface.png. Also make sure to change the referencing to this asset file name in your XML UI definition to also be lowercase. This is seen circled in red in Figure [6-5](#Fig5), as well as the Tools ➤ Android ➤ Sync Project with Gradle Files command, which will trigger a rebuild so that you can see if you have fixed this particular problem.![A324674_4_En_6_Fig5_HTML.jpg](A324674_4_En_6_Fig5_HTML.jpg)Figure 6-5.Rename smileyface.png using all lowercase and Sync Project with GradleRemember if you can’t find your project files on your hard disk drive using the operating system file management utility, you can right-click on the SmileyFace.png file in your /app/res/drawable/ folder, and select your File Path context-sensitive menu option, which will show you where to go with the file management utility. Once you right-click on that file, and rename it smileyface.png, it will show up in your Android Studio project with the correct name. This can be seen in Figure [6-5](#Fig5) on the left side of the screen. Also shown is the updated markup in the activity_main.xml.Now we are ready to create the new user interface design for the Activity we’re going to code in Chapter [7](07.html). Let’s call this activity_universe.xml since we’re going to call this new Activity class UniverseActivity.java. The way you create a new XML UI layout definition is to right-click on your app/res/layout/ project folder, then select New ➤ Layout resource file from the context-sensitive menu, seen on the left side of Figure [6-6](#Fig6). This will open the New Resource File dialog, shown on the right side of Figure [6-6](#Fig6). Name the XML resource file activity_universe, and select a Root element class value of android.support.constraint.ConstraintLayout as seen highlighted.![A324674_4_En_6_Fig6_HTML.jpg](A324674_4_En_6_Fig6_HTML.jpg)Figure 6-6.Right-click on app/res/layout and select the New ➤ Layout resource fileLeave the other data fields at their default values and click on the OK button. This will create the new activity_universe.xml file in the app/res/layout/ folder, and open it in an editing tab at the top middle of Android Studio. Click on the Design tab at the bottom of the XML editing pane to switch into Visual XML UI Design mode, which can be seen in Figure [6-7](#Fig7) with an empty screen design ready for you to create your new design in. We will create a universe UI from scratch to use in the UniverseActivity that we will be creating in Chapter [7](07.html), to learn about events and Intents, and how these can add interactivity to your Android 7.1.1 applications.![A324674_4_En_6_Fig7_HTML.jpg](A324674_4_En_6_Fig7_HTML.jpg)Figure 6-7.Select your activity_universe.xml editing tab, and the Design mode tabIn the Properties panel name the ID for the UI design universe, as shown on the right of Figure [6-7](#Fig7), and click on the View all properties link at the bottom of the pane. Make sure that the Component Tree panel has the ConstraintLayout selected, which is should be, as it’s the only layout in use in the user interface design currently!The first thing that you want to do is to set a black background color for this universe UI, since a universe is largely black. Mouse-over the background property that actually tells you how to use #ff000000 to specify a Black color background .![A324674_4_En_6_Fig8_HTML.jpg](A324674_4_En_6_Fig8_HTML.jpg)Figure 6-8.Mouse-over the background property to see how to set the color to blackSelect the ImageView UI widget, shown selected in Figure [6-9](#Fig9), then drag it into the upper-left corner of the UI design, which now has your Black background color. Select a galaxy.jpg image from the Resources dialog and click the OK button .![A324674_4_En_6_Fig9_HTML.jpg](A324674_4_En_6_Fig9_HTML.jpg)Figure 6-9.Drag an ImageView into the upper-left corner; select a galaxy.jpg imageIn the blueprint mode, seen on the right in Figure [6-10](#Fig10), drag your ImageView so that it fits into your UI screen. Notice the @drawable/galaxy reference.![A324674_4_En_6_Fig10_HTML.jpg](A324674_4_En_6_Fig10_HTML.jpg)Figure 6-10.Drag the ImageView into position in the UI screen using blueprint modeNext, let’s add a CheckBox UI element so that the user can switch back to Hello World mode if they so desire.

### 向您的设计中添加复选框用户界面元素

Select the CheckBox UI widget , as is shown on the left side of Figure [6-11](#Fig11), and drag it to the bottom-left side of the user interface design underneath the galaxy. Keep the default (suggested) checkBox ID and enter “Hello World” in the text field, in the Properties dialog, as shown on the right side in Figure [6-11](#Fig11).![A324674_4_En_6_Fig11_HTML.jpg](A324674_4_En_6_Fig11_HTML.jpg)Figure 6-11.Add and Position a CheckBox UI widget, and set its text to Hello WorldYou can see in Figure [6-11](#Fig11) that we have a problem, since the default text color is set to Black and our background is now black to accommodate the Universe design. The checkbox itself is also not showing, as it also uses black in its default color configuration. Let’s address this issue first before we move on with our UI design .The property (or attribute, or parameter if you prefer that term) that controls the color of the checkbox part of the UI element is buttonTint, shown at the bottom right portion of Figure [6-12](#Fig12).![A324674_4_En_6_Fig12_HTML.jpg](A324674_4_En_6_Fig12_HTML.jpg)Figure 6-12.Set textColor and buttonTint to white, using a constant or hexadecimalThe property (or attribute, or parameter if you prefer that term) that controls the color of the checkbox text for the UI element is textColor, which you can find if you scroll down the Properties dialog using the scrollbar shown at the top-right corner in Figure [6-12](#Fig12).After you scroll down to the UI text parameters, which are shown in Figure [6-12](#Fig12) on the left-hand side, click the three dots (called ellipses), on the right of your textColor parameter (numbered as 1), and open the Resources dialog and select white (numbered as 2). Click the OK button (numbered as 3), which should install the white color constant in the property field as @android:color/white. Click your View fewer properties link (numbered as 4), and then enter the hexadecimal #ffffffff value for the buttonTint property (numbered as 5) as is shown in Figure [6-12](#Fig12).It’s important to note that you could also use the same work process as you did for the textColor property for the buttonTint property if you wish, since the white color constant ultimately installs this hexadecimal value into system memory at the end of the day, so you can use either of these in your specification of color. Next set your constraints, as shown in Figure [6-13](#Fig13), and set textSize to 18sp and specify the sans typeface. To better match the Hello World UI design use the Bold textStyle as well. All these settings make your CheckBox element significantly more readable.![A324674_4_En_6_Fig13_HTML.jpg](A324674_4_En_6_Fig13_HTML.jpg)Figure 6-13.Add side and bottom constraints and adjust your textSize and textStyleNotice that I have constrained the left and right of this CheckBox to the sides of the screen to center it, but only constrained the bottom of the CheckBox to the bottom of the screen, which keeps it at the bottom of the design where we need it. You are not required to implement all of the constraint sides if you don’t need to.

### 为您的标题添加一个 TextView 用户界面元素

Next, select a TextView widget , shown selected in blue in Figure [6-14](#Fig14), and drag it into the top center of your UI design. Keep the textView suggested (default) ID, and set the text value to “Hello Universe” using 36sp textSize and set an #ffffffff textColor value and a Bold textStyle setting as seen in red in Figure [6-14](#Fig14). Set the side constraints to center the TextView heading at the top center of the UI design.![A324674_4_En_6_Fig14_HTML.jpg](A324674_4_En_6_Fig14_HTML.jpg)Figure 6-14.Add a TextView widget; configure its parameters as an Activity headingNext, let’s add a UI Button widget, so that the end user can return their Hello Universe app back to being just a simple Hello World app again.

### 为交互性添加一个按钮用户界面元素

Next, select a Button widget , seen selected in blue in Figure [6-15](#Fig15), and drag it into the bottom center of your UI design. Keep the button suggested ID, and set the text value to “Downgrade App,” because when your user clicks it, it will return the user to the Hello World MainActivity.java Activity subclass.![A324674_4_En_6_Fig15_HTML.jpg](A324674_4_En_6_Fig15_HTML.jpg)Figure 6-15.Drag a Button UI widget in the design and center it above the CheckBoxLet’s use default textSize, textStyle, and textColor values. All you have to do now is to set the side constraints to center the Button and add a bottom constraint that attaches the Button to the top of the CheckBox, so that these UI elements stay aligned relative to each other. Let’s do that next, and then we can see if there are any errors that we need to address, and how that’s done in the Visual Design Editor.Set your side constraints to center your Button at the bottom center of your UI design, as shown circled in red in Figure [6-16](#Fig16), and drag the bottom constraint onto your CheckBox widget, to show the constraint system you want to constrain these two UI widgets to each other. Set constraints have a dot in the middle of each circle .![A324674_4_En_6_Fig16_HTML.jpg](A324674_4_En_6_Fig16_HTML.jpg)Figure 6-16.Set side constraints for the Button widget so it centers in the designYou can see the bottom constraint dot for the Button widget has not been set in Figure [6-16](#Fig16), but that it has been set in Figure [6-18](#Fig18) (look for a tiny center dot). Let’s take a break from our user interface design creation and see if we can remove some of the errors, which are shown circled in red at the top right in Figure [6-16](#Fig16).

### 在设计编辑器中消除错误

If you click on the red square with a number (of errors) in it, as seen circled in red in Figure [6-16](#Fig16), you will pop up the Lint Warnings in Layout dialog, shown in Figure [6-17](#Fig17). This dialog lists errors and warnings, regarding user interface design in the Visual Design Editor; in this case, there are half a dozen issues that we should address.![A324674_4_En_6_Fig17_HTML.jpg](A324674_4_En_6_Fig17_HTML.jpg)Figure 6-17.A Lint Warnings in Layout dialog organizes errors and warnings for youNoteThe Android Studio editors, both Text Editor (Java code and XML markup) and the Visual Design Editor, will give you hints, suggestions, warnings, and errors, using different colored wavy underlines (text editors) and colored squares (design editor). You can mouse-over these and get pop-up helpers or click on them in the Visual Design Editor to get a Lint Warnings in Layout dialog. Android Lint was added in Android Tools API 16 and scans Android project Java code and XML markup in real time to find bugs (errors) and issues (warnings) of varying severity in your Android application project.The top of the Lint Warnings dialog contains the errors and warnings themselves in red (Error) or black (Warning). Click on any of these, and in the bottom you will get your Issue Explanation (right), and Applies To (left) UI element description and location, as you can see in Figure [6-17](#Fig17). I left the top constraint for the TextView unset, so that I could show you this feature, and how to fix it, which we are going to do next. In fact, let’s fix all six of the issues, before we finish this user interface design.As you can see selected in Figure [6-17](#Fig17), Lint will tell you it needs the vertical (top) constraint, which will bind the UI element to the top of the screen .To fix this first error, drag the top TextView constraint to the top of your UI design screen, until it says “Release to Create Top Constraint,” as shown in Figure [6-18](#Fig18).![A324674_4_En_6_Fig18_HTML.jpg](A324674_4_En_6_Fig18_HTML.jpg)Figure 6-18.Create TextView top constraint; click error count flag, to show errorsAlso notice that now that you have invoked Lint, the wavy red underlines appear under those files in the project that contains errors . The next error applies to an ImageView, and says that it is not constrained, as shown in Figure [6-19](#Fig19). This error is more difficult to solve, because the ImageView fills the design, thus you cannot simply pull the constraint markers to each edge to set this widget’s constraints.![A324674_4_En_6_Fig19_HTML.jpg](A324674_4_En_6_Fig19_HTML.jpg)Figure 6-19.Click second error, to see what it applies to, and is needed to solve itWhenever I am looking for a solution I always right-click and check the context-sensitive menu, to see if there is a solution. As you can see in Figure [6-20](#Fig20), this is exactly what I did to find the solution to how to set constraints when there is no room to drag the arrow indicator. I right-clicked inside the hatched area of the ImageView, and in the ConstraintLayout submenu, I found the solution: the algorithm that will Infer Constraints for you in situations such as this one. After clicking this, my error count decreased yet again, and I was ready to deal with the Warnings.![A324674_4_En_6_Fig20_HTML.jpg](A324674_4_En_6_Fig20_HTML.jpg)Figure 6-20.Right-click the ImageView and use ConstraintLayout ➤ Infer ConstraintsThe next three warnings suggest using the @string/ method of entering text constants in the strings.xml file, even though the Hello World app was created by Android Studio using literal (hard-coded in quotes) string constants! I modified the strings.xml file to add the new constants, by using this following XML markup:<resources><string name="app_name">My Application</string><string name="app_message">Hello World!</string><string name="app_button">Upgrade App</string><string name="app_checkbox">Hello Universe</string><string name="app_message2">Hello Universe!</string><string name="app_button2">Downgrade App</string><string name="app_checkbox2">Hello World</string><string name="image_desc_world">Hello World Image</string><string name="image_desc_galaxy">Hello Universe Image</string></resources>Once you modify the strings.xml file accordingly, you can use those three dots, called ellipses , at the end of the text parameter in the Properties pane, to access the Resources dialog, seen in Figure [6-21](#Fig21), which will list text (string) resources.![A324674_4_En_6_Fig21_HTML.jpg](A324674_4_En_6_Fig21_HTML.jpg)Figure 6-21.Select the app_message2 string constant for your TextView UI elementAs you can see in Figure [6-22](#Fig22), your TextView UI element’s text parameter is now referencing an @string/app_message2 constant and the error count has now gone down.![A324674_4_En_6_Fig22_HTML.jpg](A324674_4_En_6_Fig22_HTML.jpg)Figure 6-22.Error count decreased, as TextView text parameter referencing @string/Once you have replaced all of the text parameters for your widgets with @string references, there is only one Warning left, regarding using your contentDescription parameter to reference text describing the ImageView for use by the sight impaired. I added two string constants for this, for both Activity UI designs for Hello World as well as Hello Universe. Figure [6-22](#Fig22) shows this contentDescription referencing in place, and the removal of all errors and warnings, shown in red at the top right of the screenshot.As you can see on the left side of Figure [6-23](#Fig23), there are still errors in your XML file, which means you can eliminate errors in your Visual Design Editor, and still have errors or issues in the Text (XML Markup) Editor. Let’s take a look at how you eliminate those next. You will be eradicating errors in both Java and XML using Lint throughout the rest of the book. It is important to note this is one of the best ways to learn Android application programming (Java and XML markup) because your IDEA is guiding you as to the latest rules for Android 7.1.1 (and later, as new APIs come out) development.![A324674_4_En_6_Fig23_HTML.jpg](A324674_4_En_6_Fig23_HTML.jpg)Figure 6-23.Add an @string/image_desc_galaxy contentDescription for your ImageView

### 使用 XML 文本编辑器消除任何剩余的错误

Click on your Text (XML Editor) tab, at the bottom of the activity-universe.xml editing tab. The results, before and after the fix, are shown in Figure [6-24](#Fig24). What is causing a problem is the textAlignment parameter, which the Visual Design Editor has set to textStart as it was generating the XML markup for the UI design. Since I want the title to center at the top of the design, I clicked on the Design tab at the bottom of the editing pane, and found the textAlignment parameter, which needs to be changed from textStart to a different (better) setting so that I do not have to add yet another layout gravity parameter .![A324674_4_En_6_Fig24_HTML.jpg](A324674_4_En_6_Fig24_HTML.jpg)Figure 6-24.Mouse-over wavy red underline parameter to see what is needed to solveThe fewer parameters you can utilize to achieve your user interface design, the less code your Android application has to process, and less device memory is used.Once you find the textAlignment parameter, click on the drop-down selector, and select the center option, as can be seen on the right-hand side of Figure [6-25](#Fig25). I then went back into the Text tab and confirmed that the error had been removed from the XML markup, as shown on the right-hand side of Figure [6-25](#Fig25).![A324674_4_En_6_Fig25_HTML.jpg](A324674_4_En_6_Fig25_HTML.jpg)Figure 6-25.Find the textAlignment parameter, and select a center alignment optionYou can choose to address these errors and warnings at any time; most choose to deal with them as they notice them. I will suggest keeping an eye on the error icon and dealing with them as they pop up, as the more they accumulate the harder they will be to find and fix, especially if any of them are related or reference each other! I saved up a half a dozen of them for this section of the chapter, to show you how to address several of these different issues; and now that we have, I will continue on with the chapter and add more advanced UI design features to the Hello Universe Activity user interface design we’re creating in the Visual Design Editor.

## 摘要

In this chapter, you learned about several important Android superclasses that are used to create Android applications, and get them running on the device display screen. These include the Activity class, the View class, and the ViewGroup class; and the subclasses of these classes, which are actually used to create your Android applications, such as the AppCompatActivity class that you’ve seen in use already.You already know you do not have to write an Activity subclass all by yourself, and as far as View and ViewGroup subclasses are concerned, Android 7.1.1 has generously written all of these subclasses for you as well. All you have to do is to “include” them in your Android application code, by using an import statement, and of course you have to implement their features correctly, which, as you have seen in this chapter, the new Visual Design Editor will do for the Absolute Beginner as well, as long as you use it correctly. This feature makes Android 7.x development more accessible to all Absolute Beginners!You learned about the inter-relationships between the Activity class, the View class, and the ViewGroup class, and how these can be used together to get your application UI design and content onto the device display screen. You learned how to create a user interface layout XML definition from scratch in Android Studio using the Visual Design Editor, Lint, and the right-click context-sensitive menu and the New ➤ Layout Resource dialog.In Chapter [7](07.html), you will start to learn about how Android 7.1.1 handles Events and uses Intent objects, and all about how to make your UI design interactive, by using Event Handlers and Intent objects.