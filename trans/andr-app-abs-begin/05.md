© Wallace Jackson 2017Wallace JacksonAndroid Apps for Absolute Beginners10.1007/978-1-4842-2268-3_5

# 5.Java 简介:对象、方法、类和接口

Wallace Jackson<sup>1</sup>(1)Lompoc, California, USAThe programming language used for developing your Android applications is Oracle’s Java SE, which was created by Sun Microsystems and later acquired by Oracle. As you learned in Chapter [2](02.html), Java SE stands for Java Standard Edition, though many programmers shorten this to just “Java.” Java is what is called an object-oriented programming (or “OOP”) language , which you are going to learn all about during this chapter. It is important to note that all of these Java programming concepts, components, and constructs that you will be learning during this Java primer chapter will apply equally well to both the 32-bit Android 4.4.4 OS; as well as to the 64-bit Android 5.0 OS, released in 2014; Android 6.0 released in 2015; Android 7.0, released in the fourth quarter of 2016, and Android 7.1.1, released in the first quarter of 2017.OOP is based on the programming concept of developing modular, self-contained constructs that are called objects . These OOP constructs can contain their own attributes and characteristics. In this chapter, you will learn a great deal about the OOP characteristics of Java, and the logic behind using a modular programming approach and OOP techniques to build applications that are easy to share and debug due to an OOP approach. You’ll also learn about all of the other Java programming language constructs, like packages and classes, methods and interfaces, loops and arrays, variables and constants, and application programming interfaces (APIs) , which tie everything together into one coherent computing ecosystem, such as the 100 Android Java platform APIs discussed in Chapter [2](02.html). Together these Java constructs will allow you to create the application’s objects and then modify them according to the programming logic that the application will utilize. This creates a user experience for your end users. We will also learn what the bootstrap Java code in your existing application is doing.

## Java 的三个版本

There are two other “editions,” or versions of the Java programming language, in addition to the Java SE. These are called Java EE , short for Java Enterprise Edition ; and Java ME, or Java Micro Edition, which was originally used for mobile application development, thus a lot of people incorrectly assume that Java ME stands for Java Mobile Edition . Many mobile phones now use the Android OS, which uses the more powerful Java SE, instead of Java ME, due to much more powerful hardware that is utilized.Java EE was designed for use on massive computer networks. These types of computing networks are used to run large enterprises, that is, corporations with thousands of active users. This could be termed “server-side” computing . Conversely, Java SE could be termed “client-side” computing, as the Java application, in the case of this book, an Android application, runs on a user’s personal computing device, which is termed the “client” in the computer programming industry.It is important to note Java EE can also be run on smaller installations, as long as they have enough system memory and a couple of processing cores, and this is sometimes done in companies that are developing applications for use on Java EE installations, so that they can work in, and simulate, that type of environment for their testing. Java EE’s differentiating feature to Java SE is Java EE features a multi-user, scalable design, whereas Java SE has been designed for use by a single user, on a single computer system, say a home PC or a laptop, or better yet, on an Android device such as an iTV Set, e-book reader, tablet, smartphone, game console, set-top box, auto dashboard, or smartwatch.Java ME was designed for low-power, embedded systems, to create highly portable computers such as mobile phones. It has fewer features than Java SE, so that it can fit onto a phone without using too much memory and resources to run it. Most mobile flip-phones run Java ME, but Android phones run the more powerful Java SE. Android phones can run Java SE because most have a gigabyte or more of memory, and a 1GHz or faster CPU, so essentially, today’s Android devices are Linux computers.

## 面向对象构造的基础:对象

The foundation of OOP is the object itself. Everything you create in Java is an object and uses other objects (and data primitive values). Objects in OOP languages are similar to the objects that you see around you every day, except Java objects are virtual, and are not tangible, since computers will use zeroes and ones (binary) to represent things. Just like tangible real-world objects, Java objects have characteristics, called states or attributes, and things that they do, called behaviors . One way to think about this distinction is that Java objects are nouns, or things that exist in and of themselves, whereas their behaviors are like verbs, or things that these nouns can do.As an example of Java objects, let’s define a Java object based on a popular real object that we see around us every day in all of our lives: the automobile. Some of the characteristics, or states, of the common automobile might be defined as follows:

*   颜色(例如糖果苹果红)
*   方向或航向(北、南、东或西)
*   速度(例如，每小时 45 英里)
*   发动机类型(燃气、柴油、生物燃料、氢气、丙烷、电动或混合动力)
*   档位设置(1、2、3、4、5、6 或倒档)
*   动力传动系统类型(2WD 或 4WD)

The following are some things that you can do with a car, that is, the car’s behaviors:

*   加速
*   换挡
*   踩下刹车
*   转动车轮
*   打开音响
*   使用前灯
*   使用转向灯

You get the idea. Objects can be as complicated as you wish them to be, and Java objects can nest, or contain, other Java objects within their object structure, just like XML . An object hierarchy is like a tree structure, with a main trunk, branches, and sub-branches as you move up (or down) its structure. An example of a hierarchy you use every day would be your multi-level directory, or folder structure, which is on your computer’s hard disk drive (refer to Figure [4-17](04.html#Fig17) in Chapter [4](04.html) for a visual example). The directories or folders on your hard disk drive can contain other directories or folders, which can in turn contain yet other directories and folders, allowing complex hierarchies of organization to be created. We saw another great example of this in Chapter [3](03.html) in Figure [3-8](03.html#Fig8), where your Android MyApplication project folder was shown in the Android Studio Project pane, showing project subfolder hierarchies, with an app folder, Java and resource folder, and subfolders for layout, drawable, values, and so on.Figure [5-1](#Fig1) shows the simple “Anatomy of a Car Object” diagram of the Java object structure, using a car as the example. It shows the characteristics, or attributes, of the car, which are central to defining the car object, and around those, behaviors that the car object can perform, and which effect changes on the attributes or states of the car. The states and behaviors serve to define the car to the outside world, just like your application objects will define the states and behaviors regarding the functionality of your Android application for your end users. It’s all very logical, as you will see during this chapter.![A324674_4_En_5_Fig1_HTML.jpg](A324674_4_En_5_Fig1_HTML.jpg)Figure 5-1.A car object showing the car attributes or characteristics (inner oval) and car behaviors (outer oval)You can do this same hierarchical construction by using Java objects, which can contain subobjects, which can themselves contain further subobjects, and so on and so forth, as needed to create your object hierarchy structure. You will see nested object hierarchies when you are working with Android, because nested objects are very useful for grouping related objects that are used together, but that are used in more than one place, as well as for more than one type of use. After all, one of the goals of modular code in object-oriented programming is to foster effective code reuse.In other words, some types of objects are also useful to other types of objects in an Android app. You will see examples of this during this book, as we will be covering all of the primary Java-based classes (which as you will soon see, are used to create objects) in the Android 7.1.1 OS during the course of this book.As an exercise, you should practice identifying different objects in the room or space around you, and then break down their definition or description into various states (variable characteristics, and fixed, or constant, characteristics) as well as behaviors (things that the object can or will do). This is a good exercise to perform, because this is exactly how you’ll need to start thinking in order to become more successful in your OOP endeavors using the Java programming language, and even using the XML markup language, for that matter, which you learned about in Chapter [4](04.html).It is important to remember that you can use both Java programming logic, as well as XML markup, to define objects for Android applications, as you learned in the previous chapter, when you learned about object inflation from XML object definitions. You’ve already defined a TextView user interface object, having several characteristics, in Chapter [4](04.html), using XML markup, as well as a Button UI object and a CheckBox UI object. You have also defined an ImageView object as well, so you are well on the way to defining hundreds of objects for use in Android 7.1.1 applications over the course of this book.

## 一些编程术语:变量、方法和常量

Next, let’s cover some of the technical terminology used in Java. First, objects have data fields to hold variable data, constants to hold fixed data, and methods to define behaviors, as follows:

*   保存 Java 对象状态的数据字段可以随时间改变，称为变量。以汽车为例，你行驶的方向、档位和速度几乎都在实时变化，因此都是变量。
*   保存不随时间变化的对象状态的数据字段被称为常数。以汽车为例，汽车上的糖果苹果红色油漆工作可能是一个常数，汽车的发动机类型也是如此(除非你拥有一家油漆和车身商店，或者是一名汽车机械师)。
*   方法是编程逻辑或程序代码例程，操作并将改变对象的内部变量数据字段。方法也将允许对象本身外部的其他 Java 对象与该对象通信，只要该方法被声明为公共的。我们将在这一章的稍后部分更详细地讨论这些方法，所以我不会在这里讨论它们到底是如何工作的。

One of the key concepts of OOP is data encapsulation . In Java, data encapsulation is implemented by only allowing a Java object’s variable data fields to be modified directly through that same Java object’s internal methods. This allows a Java object to be self-sufficient, or encapsulated.Using the car example, in order to turn the car, you would use the .turnWheels() method, shown in Figure [5-1](#Fig1) on the bottom right of the diagram. This method would be comprised of Java programming logic that would correctly position the wheels of the car, ultimately causing it to move in the desired direction. You would not see details of how the object's wheels are turned, because of encapsulation. That detail is left to the private, internal functionality contained (encapsulated) inside the method in the Java object.NoteNotice the empty parentheses I am using after my method names in the text. These are always used when writing about a method, so that the reader knows that the author is referencing a Java method. Additionally, since method calls are invoked using dot notation, I usually will preface the method names with a dot, further reinforcing that this is a method call, so that you can visualize it. You will see this method naming convention used throughout the rest of this book.Using data encapsulation, you can individually build and test each object that is part of a larger object construct, without requiring any data to be accessed from other objects, or modules, of an application. External data access can translate into bugs, so encapsulation helps when developing complicated, large-scale applications. Without data encapsulation, developers on your team could simply access any part of your object data and use it however they pleased. This could introduce bugs affecting the methods you have perfected to manipulate your object and to provide your encapsulated solution. So data encapsulation promotes the core concept in OOP of modularity . Once an object is created and tested, other objects can use it without worrying about its integrity.Data encapsulation thus allows code reuse, so programmers can develop libraries of useful objects, which don’t need to be rewritten or retested by other programmers. You can see how this might save developer time and money by structuring only the work that needs to be done and avoiding redundant work processes related to testing multiple code modules in conjunction with one another at the same time. Data encapsulation will also allow developers to hide the data and the internal logic of their Java object, if that is so desired.In the car object example, the attributes of our car are encapsulated inside of the car object, and can thus be changed only via the methods that surround them in each diagram. For instance, one would use a .shiftGears() method to change the Gears=1 field variable to Gears=2.Finally, Java objects make debugging easier, because you can add or remove them modularly, or isolate them during testing in order to ascertain where bugs are located within the overall code.

## Java 构造:创建自己的对象

In the next few sections of this chapter, you will learn about the primary Java programming constructs (or code structures) that developers will create to be able to define their own custom Java objects. These custom objects will have their own characteristics (variables and constants), behaviors (methods), accessibility (access control modifiers), procreation (constructors), and even can have their own rules of engagement (interfaces). They can even have their own home offices (packages).This is in large part accomplished using the top-level structure in Java, which is called a Java class. For this reason, we will start learning about classes first, since all of the other structures in Java are either created (nested) inside of the class, or relate to its usage and implementation in some way. The exception to this is the Java package, which houses, collects, and contains these Java classes. Java 9 will introduce the concept of modules (collections of packages) when it is released in the fourth quarter of 2017.

### Java 类:Java 代码结构容器

In real life , there is seldom just one single type or kind of object. Usually, there is a large number of different object types and variations. For instance, for a car object, there are different manufacturers, sizes, shapes, colors, prices, seating capacities, engine types, fuel types, transmission types, drivetrain types, roof types, carrying capacities, luxury features, sound systems, and so on and so forth.In Java SE, you write something called a class that defines what your object can do (its methods), and what data fields it will possess. Once the class has been coded in Java, you can then create an instance of an object that you wish to use, by referencing a class definition. In architectural terms, the class is a kind of blueprint as to what the object will be structured like, including what states it will contain (its variables), its other attributes (constants), and the tasks it can perform (the methods that it has).NoteAn instance is a concrete object created from the blueprint of the class, with its own states or unique data attributes. For example, you might have a (second) baby blue car instance that is traveling south and is in third gear. (In the example, our first car instance is red, and is traveling north, and is in first gear.)To illustrate this further, let’s construct a basic class for our car object example. To create a car class, you use the Java keyword class , followed by a custom name for the new class you are writing, and then curly brackets, which will eventually contain Java code for a class definition. It looks like this:class Car {// Java code definition for the car class will go in here. We will do this next.}The first thing that you will usually put inside of the class (inside of the curly {} brackets) are the data fields (variables). These variables will hold the states, or characteristics, of your object that will be created by the class. In this case, you will have six data fields, which will define the car’s current gear, current speed, current direction, fuel type, color, and drivetrain (two-wheel drive or four-wheel drive), as was specified in the basic diagram which was shown earlier in Figure [5-1](#Fig1).To define a variable in Java, you must first declare its data type.

*   一个整数或整数数据类型声明一个变量能够保存一个整数(非小数)。
*   一个字符串数据类型声明变量保存一个文本值。
*   一个布尔数据类型声明变量保存一个真或假值(我认为这就像一个开关或切换，就像一个二进制开或关状态)。

The next portion of the variable definition or declaration after the data type has been specified is your custom variable name , which you will use to refer to that variable later on, within your Java programming logic. If you want to know technically what the Android OS is going to do with these variable declarations, it is essentially going to set aside, or allocate, an area in the system hardware (the system memory, to be more precise) to hold this value for your application to access while it is running.You can also (optionally) set a default or a starting data value for your variable. This is done by using the equal sign and a starting data value. The variable definition is ended once it reaches, or is terminated with, a semicolon character. This is how the Java compiler in Android Studio 2.3, which is reading or parsing your Java code, knows that each statement is finished being defined.NoteSemicolons are used in programming languages to separate each code construct, or definition, from the other code constructs within that same body of code (package, class, method, or interface), which I often refer to as a Java code structure, or Java logic structure.So, with the six variables from our Anatomy of a Car Object diagram, shown in Figure [5-1](#Fig1), in place, the core Car class definition would initially look something like the following:class Car {int speed = 15;int gear = 1;int drivetrain = 4;String direction = "N";String color = "Red";String fuel = "Gas";}Remember that since we specified a starting value using the equal sign for all of these variables, that these variables will all contain this default, or starting, data value. These initial data values will be set (in the system memory) as the Car class variable’s initial data values upon object creation in system memory.Notice how the example spaces out the curly braces ({ }) on their own lines, as well as indenting certain lines, similar to what you did with your XML markup. This is done as a Java programming convention, so that you can visualize the organization of the code constructs that are contained within your Java class structure, inside of those curly braces, more easily and clearly. This would be analogous to having a bird’s eye view of your Java code construct.

### Java 方法:Java 代码函数定义

The next part of your Java class definition file will contain your methods. A Java method will define how your Car object will function; that is, how it will operate on the variables that you defined at the top of the class, which hold the Car object’s current state of operation .Method calls can invoke a variable (state) change, and methods can also return data values to the entity that calls or invokes the method, such as data values that have been successfully changed, or even the result of an equation. For instance, there could be a method to calculate driving distance by multiplying speed by driving time, and this method would return this driving distance data value to the Java code that invoked this method.You will see a bit later on exactly how a Java method is invoked; this is usually accomplished by using something in the Java programming language called dot notation . Next, let’s take a closer look at how a Java method is declared and created inside of your Java class structure.To declare a Java method that does not return any data values to the calling entity, and that only invokes some sort of state change in the object, you would utilize the Java void keyword before the method’s name .NoteIn this chapter especially, but also throughout the book, you will be learning about a plethora of Java and Android keywords. Keywords are reserved words that cannot be used in your own custom code (because that would confuse the compiler, which needs to have everything that is defined be 100% unique, and thus not ambiguous), because each keyword does something specific in Java or Android. As an Android programmer you will need to learn all of the programming language keywords and what they mean (do) and how to implement them properly, which we will be doing throughout the rest of this book.The .shiftGears() method is a good example of using void in a method that triggers something. This type of method would be used to trigger (invoke) a change in the object, such as a shifting in gears, and thus would not need to send any specific data values back to its calling entity.void shiftGears (int newGear) { The Java code which defines the method's functionality }If your method or function returns a data value, then instead of using the void keyword , you would use the data type of the data value that needs to be returned, say int or String. As an example, a simple, whole number addition method might return a number data value after finishing its sum calculation, so you would declare a data type using the int keyword.int addTwoNumbers (int x, int y) { int z; x + y = z; return z; }After the data type keyword comes a name for the method (say, addTwoNumbers ). This is followed by the type of data (in this case, an int) and variable name or names (x and y) in parentheses, which is called the parameter list , and then finally the curly braces, which will contain the method’s Java code, which will add the two input x and y integers, returning a result held in a z variable to the calling Java code.The data variable’s data type and name, seen within the parameter list, contains the data parameter that will be passed into the method, so the method now has this passed-in data variable to work with inside of the Java code that is defined inside of the method programming logic (inside of its curly braces). This declares the variable for use, so you can use these parameter variables inside the method as you can see in the previous example, where I had only to declare the z variable for use.NoteThe normal method naming convention is to start a method name with a lowercase letter, and then to use uppercase letters to begin words embedded within the method name, called CamelCase like this methodNameExample(). Read more about Java naming conventions at: [http://www.oracle.com/technetwork/java/codeconventions-150003.pdf](http://www.oracle.com/technetwork/java/codeconventions-150003.pdf) .Some methods, such as those that trigger something, will be called without using any variables, as would be done in a .turnCarEngineOff() method, which would be called in your Java code as follows:carObject.turnCarEngineOff();To call the . shiftGears() method , you would want to pass the desired gear over using the parameter list as an integer data variable, so you would therefore utilize the following method call format:carObject.shiftGears(4);This passes over the integer value of 4 using the .shiftGears() method’s newGear data variable, which sets this data value as well as passing it into the method. This data value is then utilized in the interior of the .shiftGears() method logic (the part inside the curly braces), where it is finally used to set the object’s gear (internal) field to the new gear shift value of 4, or fourth gear. We will be looking at that code construct next. If you want to set up your .shiftGears() method so that it does not require any integer data values, that is, if you wanted to set it up to be a method with no calling parameter, you would need to create a .shiftGearUp() as well as a .shiftGearDown() method. The programming logic inside of these methods would add (or subtract) a value of one from the current gear setting, instead of setting the gear value to the passed-in (desired) gear value. In Java coding, there’s always more than one way to skin a car! Or is it, there’s always more than one way to shift a cat?A common reason to use a method without any parameters is to invoke a state change in an object that does not depend on any data being passed into the method. In the case of this particular gear shifting example, this would also fix a potential problem of skipped gears, as you would simply code a .shiftGearUp() method and a .shiftGearDown() method , which would upshift and downshift by one gear level each time they were called, rather than change to a gear selected by the driver. If you have ever shifted from first into fifth gear on your car, you know that it does not work very well, and could even cause a stall. This might be a smarter way to code this particular method, and then you would not need to pass a parameter in order to shift gears on your Car object; you would just simply call .shiftGearUp() or .shiftGearDown() whenever any gear shifting for the Car object was needed.After the method declaration, the method’s programming logic procedures are contained inside the curly braces. In this Car class and object definition example, we have four methods, as defined back in Figure [5-1](#Fig1):

*   。 shiftGears() 方法会将汽车对象的档位设置为传入的档位值。 shiftGears() 方法。您应该允许将一个整数传递给这个方法，以允许“用户错误”，就像您在现实世界中驾驶汽车一样。汽车对象的齿轮属性被设置为新齿轮数据值，该值被传递到使用方法参数列表区域的方法中。void shift gears(int new gear){gear = new gear；}
*   。 accelerateSpeed() 方法取你对象的速度状态变量，并在速度上加上你的加速因子，使你的对象加速。这是通过获取对象的当前速度设置或状态，并向其添加一个加速因子，然后将该加法操作的结果设置回原始的速度变量来完成的，因此对象的速度状态现在包含新的(加速的)速度值。【void accelerate speed(int acceleration){speed =速度+加速度；}
*   。 applyBrake() 方法取对象的速度状态变量，从当前速度中减去一个制动因子，使对象减速，或制动。这是通过获取对象的当前速度设置，并从中减去制动系数，然后将减法的结果设置回原始的速度变量来完成的，因此对象的速度状态现在包含更新的(减速的)制动值。void apply brake(int braking factor){speed = speed-braking factor；}
*   。 转轮()方法简单明了，很像。 shiftGears() 方法，只不过是用一个字符串的值 N 、 S 、 E 或 W 来控制汽车转向。什么时候。【W】使用时，汽车将向左转，此时。使用 turnWheel("E") ，汽车将向右转，当然，假定汽车对象当前正向北行驶，根据其默认方向设置，它是向北行驶的。void turn wheel(String new direction){direction = new direction；}

The methods that make the Car object function go inside of the Car class’s code body inside of the curly braces, and after the variable declarations. The updated Car class would look like the following:class Car {int speed = 15;int gear = 1;int drivetrain = 4;String direction = "N";String color = "Red";String fuel = "Gas";void shiftGears (int newGear) {gear = newGear;}void accelerateSpeed (int acceleration) {speed = speed + acceleration;}void applyBrake (int brakingFactor) {speed = speed - brakingFactor;}void turnWheel (String newDirection) {direction = newDirection;}}This Car class allows us to define a Car object, but only if we include a Car() constructor method, which we will be covering in the next section of this chapter.

### 构造函数方法:Java 对象蓝图

If you want to be able to make an object with preset values out of your class definition, then you need to include what is called a constructor method . If you don’t, Java will create one for you called a default constructor. This method will need to be named the same as the class name, in this case, it would be the Car() constructor method, and should be the first method that is defined inside of the class construct, after the variable (data field) definitions. The constructor method is used to construct an object, configure it, and load it into memory for use. The first thing we will want to do is to make our variable declarations undefined, by removing the equal sign and initial data values, so we can use the constructor to set the variables differently for each object created using the class. If all objects that are created using the class need to have the same starting variables, you can include these in the class instead of the constructor. This is shown in the following Java code:class Car {String name;int speed;int gear;int drivetrain;String direction;String color;String fuel;public Car (String carName) {name = carName;speed = 15;gear = 1;drivetrain = 4;direction = "N";color = "Red";fuel = "Gas";}}As you can see above, a Car() constructor method will set the data values as part of the construction and configuration of the Car object, and thus the Java code for the Car() constructor method contains your data field initialization values, not the Java class itself. As you may have inferred from this, some Java classes are built to create objects, others are built to process logic; the choice is yours regarding how to use the powerful Java programming language.NoteLater in this section I’ll show you how to change this constructor to set more of the variables.The Java constructor method differs from a regular Java method in a number of distinct ways. First of all, a constructor method does not use any of the data return types, such as void and int, because it is used to create a Java object, rather than to perform some function. It does not return nothing (the void keyword) or a number (the int, double, or float keywords), but rather, it returns an object! Indeed, that’s why it’s called a constructor in the first place – because its function is solely to construct or create the new Java object; in this particular case, that would be a basic or generic Car object.Note that every class that needs to create a Java object will feature a constructor with the same name as the class itself, so a constructor is the one method type whose name can (and will, always) start with a capital letter, which is essentially disobeying the standard Java method naming convention.Another difference between a constructor and a standard method is constructors must use the public access control modifier, and cannot use any non-access-control modifiers, so be sure not to declare your constructor as: static, final, abstract, or synchronized. We will be covering these modifiers a bit later on in this chapter, so stay tuned!In case you may be wondering how you would modify the previous Car() constructor method example if you wanted to not only name the new Car object using the constructor method, but also wanted to define its speed, direction, and color using that same Car() constructor method call, you would do this by simply creating a longer parameter list for the constructor method call. This revised Car(carName, carSpeed, carDirection, carColor) constructor method code structure would look something like this:class Car {String name;int speed;int gear;int drivetrain;String direction;String color;String fuel;public Car (String carName, int carSpeed, String carDirection, String carColor) {name = carName;speed = carSpeed;gear = 1;drivetrain = 4;direction = carDirection;color = carColor;fuel = "Gas";}}It is important to note that this Car() constructor method will not do anything at all until you use it to instantiate an instance of the Car object. An instance is just what it sounds like it is; the Android OS will allocate system memory space to hold each particular instance of any Java object created by its class’s constructor method .A constructor method must be called or invoked in conjunction with the Java new keyword, which we will cover next. The new keyword creates a new object in a new area of system memory, so it’s keyword appropriate!Next, let’s look at how you would create new Car objects in an Android onCreate() method structure.

### 实例化对象:Java“new”关键字

To create an instance of an object, you instantiate it. Here’s what it would look like if you added this code to the . onCreate() method of your current Android application. This shows the creation of two Car objects, as well as how you would use these Car objects along with the dot notation used to call the methods which would operate upon them. Refer to Figure [3-8](03.html#Fig8) in Chapter [3](03.html) to see this bootstrap .onCreate() method code for the Android Hello World (MyApplication) application.protected void onCreate(Bundle savedInstanceState) {super.onCreate(savedInstanceState);setContentView(R.layout.activity_main);// Two forward slashes will allow you to insert comments into your code// Create two new Car Objects by using the Car() constructor methodCar carOne = new Car("carWon", 20, "S", "Blue");Car carTwo = new Car("carTwoon", 10, "N", "Green");// Invoking three methods on CarOne Car Object through the use of dot notationcarOne.shiftGears(3);carOne.accelerateSpeed(15);carOne.turnWheel("E");// Invoking three methods on CarTwo Car Object through the use of dot notationcarTwo.shiftGears(2);carTwo.applyBrake(10);carTwo.turnWheel("W");}Upon creation of this Android application, which is what the .onCreate() method is used for, we now have instantiated and configured two Car objects. Note that this code will only work if you have created a Car class in your Android application, so this is for example purposes only. We have done this by using the Car() class constructor and the Car object name, along with the Java new keyword, which creates each new Car object for us, using the following Java code format:Car carOne = new Car("carName", carSpeed, "carDirection", "carColor");The syntax for doing this is very similar to what we used to declare our variables, which are declared with a variable type, variable name, and (optional) variable starting data value. Object instances will be declared similar to this, with an object constructor, object name, and configuration values, like this:

*   使用构造函数方法定义对象类型汽车
*   给我们的 Car 对象( carOne )命名，我们可以在我们的类和方法代码构造中引用它
*   使用四个状态参数(一个字符串 carName ，一个整数 carSpeed ，一个字符串 carDirection ，一个字符串 carColor )将 carOne 对象设置为一个新的 Car 对象定义

It is also important to notice that I have put comments in the Java code by using two forward slashes, which tells the Java compiler to “ignore everything else on this line after these, as it is a comment!”To invoke our methods using our new Car objects requires the use of dot notation . Once you have created and named a Java object, you can call methods on it, by using the following code construct:objectName.methodName(parameter list variables);So, to shift into third gear on the Car object named carOne, we would use this Java code statement:carOne.shiftGears(3);This calls or invokes the . shiftGears() method on the carOne Car object, and passes over the gear parameter, which contains an integer value of 3\. This value is then placed into the newGear variable, which is then utilized by the .shiftGears() method’s internal code.So, as you can see in the final six lines of code in the public void onCreate() method, we set the carOne Car object to third gear, using .shiftGears(3), accelerate it from 15 to 30 mph, by accelerating by a value of 15, using .accelerateSpeed(15), and then turn east by using the . turnWheel() method with a String value of "E" (the default direction is north, or "N").Car two (carTwo) we shift into second, using .shiftGears(2), then .applyBrake(10) to slow it down from 15 to 5 mph, and finally turn the car west, by using a .turnWheel("W") method call, all using dot notation . Dot notation connects the Java method call to the Java object, invoking that method on that Java object. Once you understand all of this, you will see it is actually really cool how Java works.

### 扩展对象的结构:Java 继承

There is also support in Java for developing different variations on custom objects , in this case, it is a Car object. This is done using a technique called inheritance . Inheritance is where more specialized Car classes (more uniquely defined Car objects) can be subclassed using the basic Car superclass. This allows Java developers to develop more organized, modular, inheritance-oriented approaches to designing their Java objects, making them into building blocks, and thus powerful for the construction of an infinite number of future object types. This inheritance process can be seen in Figure [5-2](#Fig2).![A324674_4_En_5_Fig2_HTML.jpg](A324674_4_En_5_Fig2_HTML.jpg)Figure 5-2.Inheritance of the Car Object superclass to create the SUV and the SPORT Car object subclassesOnce a class is used for inheritance by subclassing it, it becomes a superclass. Ultimately, there can be only one superclass at the very top of the chain, but there can be an unlimited number of subclasses. All of the subclasses inherit the methods and fields from the superclass. If you want to change a superclass’s method, you can use the Java keyword @Override before the subclass’s method, and your custom method implementation will then be used instead of the superclass method.The ultimate example of this in Java SE is the java.lang.Object superclass (I call it the masterclass), which is used to create all other classes in Java.The SUV subclass might have additional .onStarCall() and .turnTowLightOn() methods defined, in addition to inheriting the usual Car object operational (basic car function) methods allowing the Car object to shift gears, accelerate, apply the brakes, and turn the wheels.Similarly, we might also generate a second subclass, called the Sport class , which would create sport car objects. These might include an .activateOverdrive() method to provide faster gearing, and an .openTop() method to put down the convertible roof.To create a subclass using a superclass, you extend the subclass from the superclass, by using the Java extends keyword inside of the class declaration. The Java class construct would thus look just like this:class Suv extends Car { // Additional New Variable Data Fields, Constants, and Methods Go In Here. }This extends the Car class so that SUV objects have access to, essentially contain, all of the data fields and methods that the Car object features . This allows the developer to have to focus only on just the new or different data fields and methods that relate to the differentiation of the SUV object from the regular or master Car object definition.Since classes create objects, given that they have a constructor method, the same hierarchy should be applied at the spawned object level. So logically, the SUV object will be more complex (more data fields and more functionality) than the parent Car object.To refer to one of the superclass’s methods from within the subclass you are coding, you can use the Java super keyword . For example, in the new SUV class, you’ll probably want to use the master Car class .applyBrake() method, and then apply some additional functionality to the brakes that will be specific to SUVs. You can call a Car object’s .applyBrake() method by using super.applyBrake() in the Java code. The following Java code will add additional functionality to a Car object .applyBrake() method, inside of the SUV class’s .applyBrake() method, by using the super keyword to access the Car class’s . applyBrake() method , and then adding in additional logic:class SUV extends Car {void applyBrake (int brakingFactor) {super.applyBrake(brakingFactor);speed = speed - brakingFactor;}}This code makes the SUV object’s brakes twice as powerful as the generic Car object’s brakes, which is again something that would have to take place in real life for an SUV to be safe for use. The reason the Java code doubles the SUV braking power is because the SUV object’s .applyBrake() method first calls the Car object .applyBrake() method from the Car superclass from inside SUV using super.applyBrake(brakingFactor); line of Java code in the SUV subclass’s .applyBrake() method, and then the line of Java code that comes next (again) decreases the speed variable, by applying the brakingFactor a second time, making the brakes twice as powerful, or twice as effective!Be sure to use good programming practices and refer to documentation for your superclass’s fields and methods within each subclass that uses the super keyword to reference superclass programming infrastructures in one way or another. The Java class documentation should let users (developers) of your superclass know which of your superclass fields and methods are public and are available for use, since these do not explicitly appear in the Java code for the subclass, as only incremental code (new and different methods and variables) will appear in the subclass Java code.

### Java 接口:定义类使用模式

In many Java applications, as well as in the Android 7 APIs, Java classes must conform to a certain usage pattern. There is a specialized Java construct called an interface that you can implement, so that other application developers will know exactly how to utilize your Java classes implementing an interface, as well as which methods are required for proper implementation of your Java class. Implementing the Java interface will allow your class to become more conformant regarding those behaviors that your class offers for other programmers to utilize. To implement a Java interface you would use the Java implements keyword, as you will see later on during this section.Interfaces in essence form a programming contract between your class and the rest of the development world. For any class implementing a Java interface, the Java compiler can enforce this contract at build time. If a class claims to implement a public interface using the implements keyword, all of the methods that are defined by that Java interface definition must be implemented (be present) in the source code for the class that implements that interface before that class will successfully compile.Interfaces are especially useful when working within a complex Java programming framework such as Android 7.1.1, which is utilized by other developers who build applications based on the Java classes that the Google Android 7.x OS developer team members have written specifically for that purpose. A Java interface can be used like a road map, showing developers how to best implement and utilize the Java 8 code structure that is provided by that Java class within another larger Java program structure. Basically, a Java interface guarantees that all methods in a given class will get implemented together, as an inter-working, interdependent, used-as-a-collective, programming structure, guaranteeing that any individual function needed to implement this functional collective doesn’t get inadvertently left out.This public interface that a class presents to the other developers who are using the Java language and Android platform makes using that class more predictable, and allows developers to safely use that class in their own programming structures and objectives where a class of a particular end-usage pattern is suitable for their implementation.In other words, a public interface is an implementation road map that will tell your application what functions that class needs to be able to perform, and how to implement it without your application needing to test any of that class’s functional capabilities. In case you are wondering, Java 8 (Android) does not allow a private interface; however, the new Java 9 programming language will allow this later on in 2017\. When Android will adopt Java 9 is anyone’s guess, however.In Java terms, making a class conform to a usage pattern is done by implementing a Java interface. The following is an ICar interface , that forces all cars to implement all of the methods that you will be defining within this Java interface.These methods must each be implemented (exist) even if they are not utilized, that is, no additional or custom code exists inside their curly braces. This also guarantees that the rest of the Java application knows that each Car object can perform all of these actions, or behaviors, because implementing the ICar interface defines this public interface for all of the Car objects that implement the ICar interface.The way that you will implement the ICar public interface for the methods in your Car class would be as follows:public interface ICar {void shiftGears (int newGear);void accelerateSpeed (int acceleration);void applyBrake (int brakingFactor);void turnWheel (String newDirection);}So, the Car class that implements this ICar public interface must implement all of these declared methods.To implement an interface, you need to use the Java implements keyword , as follows, and then define all of the methods exactly as you did before, except that the methods must now be declared using a public access control modifier in addition to the void return data type. We’ll be covering Java modifiers in a future section of this chapter, after we cover the Java package and the concepts of an API.Here is how a Car class would implement this ICar interface, by using the Java implements keyword:class Car implements ICar {int speed = 15;int gear = 1;int drivetrain = 4;String direction = "N";String color = "Red";String fuel = "Gas ";public void shiftGears (int newGear) {gear = newGear;}public void accelerateSpeed (int acceleration) {speed = speed + acceleration;}public void applyBrake (int brakingFactor) {speed = speed - brakingFactor;}public void turnWheel (String newDirection) {direction = newDirection;}}Notice we added the public keyword before the void keyword, which allows any other Java class to be able to call or invoke these methods, even if those classes are in a different package (packages are discussed in the next section). After all, this is a public interface, and anyone (more accurately, any class) should be able to access it. The Java 8 interface cannot use any of the other Java access control modifier keywords, so it cannot be declared as private or protected. We’ll be learning about these access control modifiers in a future section of this chapter.It is important to note that only the methods declared in the interface absolutely need to be included. The data fields that I have at the top of the class definition are optional and are in this example to show its parallel to the Car class that we declared earlier without using an interface. There is not much difference other than using the implements keyword, except that implementing an interface tells the compiler to check and make sure that all of the necessary methods that make a Car class complete (work properly) have been included by the developer who is using the class and interface.

### 类的逻辑集合:使用包

As you know, each time you define a new project for Android 7.1.1 Android Studio will create a package to contain your own custom classes, which you will define as you implement your application’s custom functionality. In your MyApplication Android 7.1.1 application, which you created back in Chapter [3](03.html) using the New Android Project series of dialogs, you named your package com.example.user. myapplication . If you remember, that first dialog in the New Android Studio Project series of dialogs asked you to specify this package name (refer to Figure [3-2](03.html#Fig2) if you need to refresh your memory).The Java package declaration is the first line of code in any Android application class, or in any Java class in any application for that matter. The package declaration tells Java how to package your application. Recall the first line of code in our Hello World application MainActivity.java Activity class, as was shown in Figure [3-8](03.html#Fig8):package com.example.user.myapplication;After the package keyword and declaration come the import statements , which import existing Java classes and packages into your declared package. So, a package is not only for your own code that you write yourself, but rather for all code that your application uses, even if it is open source platform code; or even code that has been written by another programmer or company; or, in the case of Android applications, Android API code, which serves up Android 7 OS functionality that is only available within the Android 7.x OS and earlier OS versions.Basically, a Java package naming strategy is similar to the folder-naming hierarchy on your computer. A package is just a way of organizing (grouping) Java code according to functionality. As an example, Android organizes its classes into over 100 logical packages, which we will routinely import, and use, throughout this book. Each Android API Level contains a vast collection of functional packages that are utilized by developers to access the Android OS feature set. These were shown in Chapter [3](03.html) in Figure [3-10](03.html#Fig10) on the left-hand side. We will take a closer look at APIs in the next section of this chapter.In your Hello World bootstrap application we’ve been examining over the past couple of chapters, the Android environment needs us to have these following two import statements in the MainActivity.java file to be able to utilize the Android AppCompatActivity and the Bundle class:import android.support.v7.app.AppCompatActivity;import android.os.Bundle;This import keyword references that API address where Java code needed to complete each import statement is located. Here is a generalization of how an import statement follows a path to the class:import platform.functionality.version.classification.classname;The functionality and version portions are not always utilized, as you can see in the above two import statements.The Android AppCompatActivity class import statement tells the developer the following information about the Android AppCompatActivity Java class, as well as telling the compiler where to locate it:

*   android 表示这是 Android OS 软件开发平台 API
*   支持是指向后兼容支持功能
*   v7 指 Android OS 版本 7.0 和 7.1.1
*   app 指安卓组件分类的应用领域
*   【appcompactivity】指的是我们打算使用的类的专有名称

Thus, the AppCompatActivity class, which is the superclass for any Android Activity that you want to be backward compatible across previous Android versions, is found in the android.support.v7.app package . This .app part says that this package logically contains classes that are necessary for the creation of Android applications, and one of these is the AppCompat Activity class , which allows us to create Activity subclasses that work across all Android OS versions. The Bundle class, which allows us to bundle together application variables into custom Bundle objects, is kept in a different package for OS utilities, as Bundle objects can be used in any area of Android, not just in Activity.

### API

You might be wondering if a Java package is the highest level of organization in Java. The answer is actually no; there is one even higher level, which is, as you might well imagine, a collection of these packages themselves! This level is sometimes called the platform or the application programming interface (API) level . An API for any given programming platform, like Android or Java, is a collection of all of the packages that comprise the totality of that particular computer programming language.Thus, there is a separate API for Java SE, Java EE, and Java ME, containing all those packages for each specialized platform’s implementation, as well as an Android TV, Android Wear 2, and Android Auto API. You are using the core Android (phone and tablet) API in your Hello World application, as can be seen on the right side in Figure [3-2](03.html#Fig2) in Chapter [3](03.html).Android 4.4.4 KitKat API Level 19 was the 19th Android platform to be released, and Android 4.4 “W” API Level 20 was for Android Wear, Android API Level 21 is the first 64-bit version of Android 5, and Android API Level 23 was for Android 6.0\. The current Android API Level was 24 for the Android 7.0 API when I started writing this book in 2016, and is currently at API Level 25 for Android 7.1.1\. Android 7.1.1 is expected to be released at the same time as this book.For this reason, if you want to develop applications using any given programming language, you must download and obtain (and eventually learn) the API for that programming language in order to be able to develop any applications using its API, which is simply a collection of all of that language’s classes, methods, and interfaces, which have been logically grouped into categorized packages. We essentially will be learning about some of the core classes used in Android 7.x API during the course of this book.

## 修饰符:数据类型、访问、继承

Java uses strategic keywords prefacing, or in front of, its major constructs, called modifiers. Java constructs that can be classified using modifiers include variables, methods, interfaces, and classes. Since we have already looked at data type keyword modifiers in the chapter already, at least the void (signifying no data type used), String (text data type,) and int (integer or whole number data), I will go over the other data type keywords that are used in Java and Android here, and then we will cover the more advanced access and non-access modifiers that are used in the Java programming language.It is important to note, that even though using a data type keyword in front of your variable name will modify the type of data they are defined to contain, a more precise technical term in Java for this data type keyword is the data type specifier keyword. These two terms are often used interchangeably in Java. In the next section, the access control modifiers could be looked at as access control specifiers, as they’re specifying a level of access, by prefacing a Java keyword in front of a Java code construct.Other types of data type specifier keywords used in Java (and therefore, in Android 7) include float or floating-point numbers, which have a fractional component, represented using decimal notation, for instance, 1.375, as well as boolean, which hold Boolean math states“ such as true and false. There are other data types in Java for holding more complicated (longer) numeric representations, such as the long and double data types, which have 64-bit accuracy, and can accommodate extremely large or extremely small numeric representations. There is also a data type that can hold one single 16-bit Unicode character, called the char data type. The byte data type can hold one number from an 8-bit range (256, from -128 to +127) of numeric data values, and finally, the short data type can hold one number from a 16-bit range (65,536, from -32,768 to +32,767) of numeric data values. Data types are relatively easy to understand in comparison to access or non-access modifiers, which we cover next.

### Java 访问修饰符:四个访问级别

Java has a number of modifiers that you can place before Java constructs, to define what they are and who can see them. There are two types of Java modifiers: access control modifiers and non- access control modifiers . In case you are wondering what I mean by access control, I am talking about other Java programming constructs outside of a given Java class or package being able to see or reference (utilize) Java assets inside of that class, or even the package that class is contained in.You can apply access control modifiers to classes, methods, interfaces, constructors, constants, and variables, and include the public, private, and protected Java access modifier keywords. Not using any access control keyword at all also defines the package protected level of access control, so let’s cover all of these concepts here, in order from the most restrictive (closed) level of access control, to the least restrictive (open) level of access control. Table [5-1](#Tab1) shows four levels of Java access control modifiers in one place. Remember, the last one is no modifier (blank) but is called package protected.Table 5-1.Access Control Modifier keywords in the Java programming language and their functionality definition

<colgroup><col> <col></colgroup> 
| 访问控制修改关键字 | 功能定义 |
| --- | --- |
| 私人 | 仅允许在该特定类别内访问 |
| 被保护的 | 允许访问该类的子类，以及同一个包中的其他类 |
| 公共 | 允许访问所有的类，甚至那些位于你的包之外的类 |
| 受保护的包裹(未指定) | 允许访问该包中的其他类 |

As you might imagine, the private access modifier is the most restrictive, and, if declared, only allows access to private variables and private methods from inside of the containing class. It is important to note that classes themselves cannot be declared as private unless they are inside of another class, in which case they are a special case, and are called private inner classes. Java interfaces, which we learned earlier, are public interfaces, and therefore also cannot be declared as private, since they are inherently public in their access control. As I have mentioned, this will change in Java 9, as well as in Android when it adopts Java 9.The next most restrictive access modifier keyword is the protected access modifier keyword, which is utilized with Java classes that are intended to be used as superclasses and that need to allow access to their subclasses only, to protected variables, protected methods, as well as protected constructors. Protected access can be viewed as being protected from access by any class outside the inheritance chain, keeping it in the family, if you will. Like a private access modifier, the protected access modifier cannot be applied to any class itself, only to Java code elements inside of the class. Protected access cannot be applied to a Java 8 interface definition, as these are required to be declared using the public access modifier. It also follows that methods or data fields (variables) within a Java interface definition also cannot be declared using a protected access control modifier keyword, as they also must always be declared using a public or an abstract access control modifier. If an access modifier is not explicitly provided for a Java method that is inside a Java interface, it will default to being declared as public.The next most restrictive access modifier is actually using none of the access control modifiers at all, which is the norm in Java, as we saw when we created our original Car class, using the data type declarations of void, int, or String without any public, private, or protected modifier in front of them. Using no access control modifier allows visibility throughout your entire package, essentially, inside of your entire application, if you have your entire Android application in one package, as we will be doing in this book, and which Android Studio 2.3 does for you, as you saw during Chapter [3](03.html).The least restrictive access modifier, which removes all access restrictions, is the public access control modifier. This allows Java code in other packages to access your Java variables, methods, interfaces, and classes from outside of your package. It’s like you are opening the door to your code and saying, “come on in, folks, I’m giving you access to everything.” Use this modifier with caution!It is important not to confuse access control and non-access control modifiers with Java variable data type declarations that are used before variables to declare their data type, and which thus look a lot like a modifier. In fact, modifiers and data type declarations are often utilized right next to each other, like we did in the public void shiftGears() method.Java methods have their own rules regarding inheriting access control modifiers, as the classes that contain methods are later subclassed or enhanced to become more detailed and refined subclasses. For instance, any method that has been declared using a public access in a superclass must also be declared using public access in all subclasses. Similarly, any method that has been declared using protected access in a superclass must either be declared using the protected access, or using public access, in any subclass. It can never be declared using a private access control modifier.A method declared without using an access control modifier is the only scenario where a method can be declared using a private access control modifier in a subclass. It is important to note that a method that has been declared using a private access control modifier keyword is not inherited, because it is private relative to that class within which it is contained, and no others, including any subclasses.As you can see, although access control modifiers seem fairly simple and straightforward, you have to pay attention to what you are doing with them, especially where inheritance (superclasses and subclasses) is going to be utilized in your Java programming structure and Java package design .

### 非访问修饰符:静态、最终和抽象

There are also modifiers in Java that are not access control modifiers, and not data type declarations. These are called non-access modifiers and these are the most complicated ones to understand and to implement in practical usage. There are three modifiers that are frequently used in Java programming that we’ll be covering in this section of the chapter: a static modifier, a final modifier, and an abstract modifier . There are also some more advanced modifiers such as synchronized or volatile, which are used to manage the use of system memory using something called threads. Memory allocation using modifiers is a topic that is largely beyond the scope of an Absolute Beginners Android programming book, although we will cover what a Thread class in Android is in Chapter [13](13.html).

#### 静态关键字:在对象之间共享变量

A static modifier keyword when used in conjunction with a variable will create a variable that will exist independently of any object instances created using that class. Static variables will be initialized only one time, at the start of the execution of the application, sometimes called the app launch. The variables that use the static modifier keyword will be initialized first, before the initialization of any instance variables . Only one copy of a static variable will exist in system memory regardless of the number of instances of the class that contains that variable are created. Thus, static in Java code means that variable that belongs to the class, and not to the object instances created by that class.Objects created by that class can share that variable with the class and with each other, so use of static variables can optimize system memory. The opposite of static is dynamic, and thus, any variable not declared as static would therefore be dynamically created (created at the time it is instantiated, not ahead of time as when it is declared statically). System memory will be allocated for dynamic variables as each object instance is created by that class constructor method.To use a variable from the Car class example, if you wanted all Car objects to reference the fuel variable, which is set in the code to "Gas" at the class level, and wanted that fuel variable to belong only to the class, and not to any of the Car objects that will be created using that class, you would declare the fuel variable as follows:static String fuel = "Gas";The static modifier keyword works in much the same way for methods that are declared as static, thus a static modifier would be utilized to create methods that are intended to exist independently of any object instances created using the class. This again fixes the method in place, so it is the only copy of that method that will be used by your class and objects from that class.A static method can be referenced using the class name and dot notation even without an object instance of the class ever being created. For instance, if you declared the .applyBrake() method to be static, you could reference it using the code statement Car.applyBrake() even without having created a Car object using the new keyword.Static methods cannot use any instance variables of any object instances created using the class in which they are defined, until one of those object instances has been created. Static methods should take all their data values from the incoming parameter list, and then compute something from those parameters, with no reference to variables, which are inherently not static, because they’re variable!So, to re-code your .applyBrake(int brakingFactor) method as static, and reference the class speed variable, you would modify your method to look something like this:public static void applyBrake (int brakingFactor) {Car.speed = Car.speed - brakingFactor;}Notice that the access control modifier comes first, then the non-access modifier, and then finally the return data type declaration comes last in the list. This is the modifier and declaration ordering convention for the Java 8 programming language. Next, let’s look at the final modifier, which sometimes gets confused with the static modifier, as the final modifier also means that something cannot be changed, and is thus fixed as well! Java can be confusing in a number of areas, and this happens to be one of them!

#### 最后一个关键词:锁定您的 Java 代码

You can define a class using the final modifier keyword , and if a class is designated final, it cannot be subclassed. This is usually implemented for reasons of Java security, so tested, mission-critical Java code cannot be modified or changed. You will notice as we get deeper into the Android API and Java that many standard Android Java-based library classes are declared using the final modifier keyword. As an example, the java.lang.System and java.lang.String classes are declared to be final so that their functionality cannot be altered.All methods in a final class are implicitly final methods. Any method declared using the final modifier keyword cannot be overridden by subclasses. This is also for security reasons and is used to prevent unexpected behavior resulting from a subclass altering a method that might be crucial to the function or to the consistency of a class’s functionality.You can explicitly initialize a final variable only once. A reference variable that is declared as final can never be reassigned to refer to a different object, if the variable references an object, rather than a data value. If the final variable references an object, the data contained within that object can still be changed, only the reference to the object is fixed, and is said to be final.Thus, you can change the state of an object referenced by the final variable, but not the reference to the object, which is what is locked or final. With variables, the final modifier is often utilized in conjunction with the static modifier to make the class variable into what is considered a constant, or an immutable fixed variable, for the duration of the class. So this is how you would make your own constant values in your own code.As an example, the <string> constant named app_name that you defined using XML in the strings.xml file would have to be declared in your application’s Java code by using the following single line of Java syntax:public static final String app_name = "Hello Universe";This above constant definition contrasts how using XML to define constants is much simpler than using Java, because Android sets all of your modifiers and puts it all into proper Java syntax for you. Next, let’s take a look at the abstract modifier keyword, which allows you to create classes that can be subclassed (used for Java logic development), but which not instantiated (used as Java objects in memory).

#### 抽象关键字:将类指定为超类

A class declared using an abstract modifier keyword can never be instantiated, or placed into memory as an object and actually utilized in the functionality of an Android (or Java/JavaFX) application. Think of the literary use of the word abstract, which means a summary or a guide to a literary work, but not the literary work itself. Java code designated as abstract is used for a guide or template (superclass) for creating other code that may actually be used as an object, later on down the subclassing line .If your class is declared as abstract, then the sole purpose for that class is to be extended—that is, subclassed. If a class contains any methods that have been declared using the abstract modifier, then the class should also be declared using the abstract modifier. If your class contains any abstract methods, and is not declared as abstract, a compiler error will be thrown when you use the Run ➤ App work process, which invokes the Java compiler.An abstract class can, however, contain both abstract methods as well as standard (non-abstract) methods, so the rule is, if you want to put an abstract method inside of a class, make sure that class is declared as abstract as well, or you will get a compiler error. In summary, you cannot have abstract methods inside of a class that is not also declared to be abstract.A Java interface differs from an abstract class in a couple of key ways. Your abstract class can have instance methods that implement your default or baseline behaviors. A variable declared in a Java interface is final. An abstract class can contain non-final variables. A Java class can implement more than one interface, but may only extend a single abstract class.Let’s take a look at the Java code that Android Studio wrote for you in Chapter [3](03.html) and see what it does, and how we can upgrade it.

## 分析您的 MainActivity.java 类

Let’s use what we have learned to analyze the Java code for our Hello World application, which is shown in Chapter [3](03.html) (Figure [3-8](03.html#Fig8)), so I won’t waste space with that screenshot here. The Java code shown in the Android Studio MainActivity.java editing pane looks like the following:package com.example.user.myapplication;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;public class MainActivity extends AppCompatActivity {@Overrideprotected void onCreate(Bundle savedInstanceState) {super.onCreate(savedInstanceState);setContentView(R.layout.activity_main);}}The first line of code uses the Java package keyword to declare the com.example.user.myapplication package name, which is also declared in the AndroidManifest.xml as you saw in Chapter [4](04.html). The manifest file defines your application and also ties Google Play to the application, and defines what the application is allowed to do, what hardware device types and Android OS versions the application supports, and defines its included components (Activity, Service, Receiver, Provider, etc.).The next two lines of code import the AppCompatActivity and Bundle Android classes into the package, as they will be utilized in the MainActivity.java class.The fourth line of code is the MainActivity class declaration. The class extends the AppCompatActivity superclass, so we’ll take a look at that next, and is designated using the public access modifier. One of the superclass methods, .onCreate() has been overridden using an @Override annotation, so we can replace some of the standard AppCompatActivity class Java code with our own application logic, such as the .setContentView() method that will be used for inflating your UI layout XML definition, which as you know from Chapter [4](04.html) is contained in an activity_main.xml file in an app/res/layout folder. This Activity subclass is also referenced specifically, using the AndroidManifest.xml <activity> tag.The protected void onCreate() method allows access to other classes in your package, and returns no values (void), and simply starts up the Activity screen on the device display, as well as creating the application Main Activity in memory. This is done my calling the superclass onCreate() method using the super.onCreate(savedInstanceState); line of Java code. The savedInstanceState Bundle object contains all of the Activity state values, so that if you leave the Activity, to do something else on your device, and return to your app Activity later, it can restore where the Activity was (its states) correctly. This Bundle object passed into the MainActivity.onCreate(Bundle) method will be passed to Android’s AppCompatActivity.onCreate(Bundle) superclass method by using this super.onCreate(Bundle) call.The next line of code in onCreate() uses the setContentView(Resource) method to inflate your UI design by referencing the /app/res folder using an R, and the app/res/layout folder (R.layout), and finally the activity_main.xml file (file extension not required) using R.layout.activity_main path as the value passed into the method. This renders your design to the screen in the same way that the Visual Design Editor renders it to the Preview pane in Android Studio.Next, let’s learn more about Java by taking a look at one of the Android classes that are used in the Hello World (MyApplication) application. The AppCompatActivity class is the superclass that is used to define the MainActivity class that extends it (see above Java code), and therefore is used as the code template for the MainActivity class. This makes it important for us to review it to see what the MainActivity class is able to do, as it gets its functionality from Android’s AppCompatActivity class.

### AppCompatActivity 类:跨越 OS 版本

Let’s take a look at how you will look at the AppCompatActivity superclass on the Android developer website, to see what methods you can override, and what variables and functions you have available to you. You should familiarize yourself with every Android class you use in this way, so this is a good exercise. Google “Android AppCompatActivity class,” and you’ll get the following documentation URL:[https://developer.android.com/reference/android/support/v7/app/AppCompatActivity.html](https://developer.android.com/reference/android/support/v7/app/AppCompatActivity.html)At the top of the class documentation you will see the Java Object (master class) to superclass to subclass hierarchy. Half a dozen classes contain Java code which will affect the AppCompatActivity class, because it’s an object, needs to have Context information, is a type of Android Activity with application (backward) compatibility features added. The chain of Java class design is as follows:java.lang.Object↳ android.content.Context↳ android.content.ContextWrapper↳ android.view.ContextThemeWrapper↳ android.app.Activity↳ android.support.v4.app.FragmentActivity↳ android.support.v7.app.AppCompatActivityIt also tell you at the top of the class what the access is, and which interfaces which are implemented.In this case there are three interfaces, AppCompatCallback, TaskStackBuilder.SupportParentable, and ActionBarDrawerToggle.DelegateProvider, and the class is public. There is also one known direct subclass, ActionBarActivity, the base class for activities that use ActionBar features in the V7 support library. Under this information are the inherited constants from the Activity and Context superclasses, and the inherited data fields (variables) from the Activity superclass. There is also one constructor, AppCompatActivity() and then a few dozen methods that can be used (overridden) in your class. I don’t have the time to go into all of these methods in detail in this Java primer chapter, but you should review them if you plan to use this Activity type extensively or at an advanced level once you become more proficient in Android 7.x application design and programming .

## 摘要

In this fifth chapter, you learned all about the Java programming language, as well as how the Android platform utilizes Java 8 to facilitate the application development work process. You learned about Java versions used in enterprise, client, and mobile application development, and about OOP. You learned about java.lang.Object, which is the foundation of OOP, and about how Java objects define attributes, characteristics, states, and behaviors which allow Java programmers to mimic real-world objects in a virtual software development environment.You learned about various components of Java 8 programming structures, such as methods, constants, variables, classes, public interfaces, and constructor methods. You learned about the Java concept of inheritance, and how to use the new keyword to instantiate an instance of a Java object by using this constructor method call. You looked at the higher-level Java organization constructs called packages, and how the total collection of packages in a programming language forms the API for the language. We also covered some Java 9 features which are not yet in Android, but which will be in the future.Next, you looked at some of the data type specifiers and access control modifiers, as well as the more complex non-access modifiers, and after that you were ready to take a closer look at the MainActivity Java class, which you created in Chapter [3](03.html), to see how its Java code works and integrates with XML.In Chapter [6](06.html), you will start to learn more about Android user interface design using the Android View class, the ViewGroup class, and more about XML UI definition tags, parameters, and work processes.