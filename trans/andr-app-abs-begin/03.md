© Wallace Jackson 2017Wallace JacksonAndroid Apps for Absolute Beginners10.1007/978-1-4842-2268-3_3

# 3.Android Studio 集成开发环境简介

Wallace Jackson<sup>1</sup>(1)Lompoc, California, USADuring this chapter, we will take a look at how the Android Studio 2.3 development environment and Android platform works. Android OS has moved away from using the Eclipse Integrated Development Environment (IDE) with Android Development Tools (ADT) , and as of 64-bit Android 5.0 and later, has adopted the IntelliJ IDEA (Integrated Development Environment Application). We installed IntelliJ as part of Android Studio 2.3 in the previous chapter, and have already used some of its configuration tools and dialogs, such as the SDK Manager, to configure it for basic Android application development usage.To cover this overview of Android Studio 2.3 and IntelliJ IDEA properly, and still make steady progress toward actual hands-on Android application development at the same time, in this chapter I will show you the work process for creating an empty Android application “bootstrap.” This is the foundation that you will always use when you start creating your Android applications. This bootstrap application structure provides you with the basic foundation of an Android 7.1.1 application, which also makes it perfect for Absolute Beginners to learn the minimum code structure that Android applications are built on. This includes an Android Activity Java class, an Android Manifest application definition XML file, a PNG32 Android application icon, a basic menu system XML definition, and a basic user interface (UI) layout container XML definition.We will take a closer look at all of the basic Android application components during this chapter, by looking at the Android application resource folder structure in IntelliJ IDEA, which the Start a New Android Project series of dialogs will also automatically create for you. As you have seen already in Chapter [2](02.html), this is inside of the Android Studio start menu, which you saw in red as the first item in the middle section of the screenshot in Figure [2-5](02.html#Fig5).We will do a detailed examination of the bootstrap (empty) Android application file and folder structure in IntelliJ. This will tell you how Android Studio 2.3 (and Android 7 OS) wants to see your application components and assets structured and organized. We will also take a detailed look at some other resource folders that are not auto-created in the bootstrap Android application project folder structure, so that you know what you can optionally create yourself. You will be creating some of these specialized resource folders during the book, such as the /res/anim/ folder, which holds XML animation definitions. Custom resource folders usually hold new media assets such as animation, video, audio, user interface designs, and other assets that will enhance the Android application user experience.As you progress in your knowledge of Android, you will enhance the application foundation that you will put into place in this chapter into something that is truly impressive, and learn more about the Android 7.x OS as well as Android Studio 2.3 and IntelliJ IDEA in the process. After you get some high-level overview regarding how everything fits together inside Android Studio, we can then start “drilling down” into XML for asset definition and Java 8 for application logic programming during Chapters [4](04.html) and [5](05.html).

## Android 应用程序结构:Java、XML 和资产

Android 7 components are built on the solid foundation of the 64-bit Linux OS Kernel. Android 6 runs on Linux Kernel 3.18.10, and Android 7 runs on Linux Kernel 4.4.1 or later. Later Linux Kernels have more features and fewer bugs, as you might expect.On top of the are a massive number (thousands) of high-level Java functions, or Java methods, that are logically arranged by using Java classes. These classes are stored by what tasks they accomplish using around one hundred Java packages. These packages are further organized into Java libraries, or APIs, which simplify your task of communicating with Android and its Linux Kernel as well as with device hardware.This is inherently complex, as you might well imagine, so don’t expect to cover all of Android 7’s functionality in one book (or even a dozen, for that matter). I’ll cover Java 8 concepts of libraries and packages, as well as what Java objects, constants, classes, and methods are, during Chapter [5](05.html).On top of this complex Java code libraries layer, you can define app assets using a high-level (and less complex) layer of XML markup. XML markup allows you to more easily define your application’s Java object structures, as well as any data constants that will be used in your Java 8 programming logic. Additionally, XML markup can define your application UI design, style, theme, and new media assets. These design-oriented assets allow you to control how your Android application looks, sounds, and functions, and ultimately will define the user experience.Since XML is easier to create Android application content in, I will be using it in the middle five chapters of this book, to show you how to define various application components, assets, looks, and feels. I will be covering XML-based UI, graphics, and animation design in Chapters [6](06.html) through [10](10.html). Figure [3-1](#Fig1) shows the hierarchy of an Android application structure starting with the foundation of the Linux OS Kernel, hidden from the developer; and Java 8, XML, and new media assets that developers create, code, design, define, and construct, eventually marrying these layers together into an Android application. These layers tend to reduce in complexity from bottom to top, especially if your new media assets already exist.![A324674_4_En_3_Fig1_HTML.jpg](A324674_4_En_3_Fig1_HTML.jpg)Figure 3-1.The Android OS foundation: from Linux Kernel, to Java Libraries, to XML Definitions, to Application Media AssetsCreating new media assets from scratch can be as complex as Java programming can be, so if your assets do not already exist, these levels of decreasing complexity do not necessarily hold true. If you want to start on the road to mastering new media content production, I have a series of six books on mastering new media fundamentals (search for this author’s name, at: [http://www.Apress.com](http://www.Apress.com) ), as well as an Android Studio New Media Fundamentals (Apress, 2015) title, which contains information and work processes regarding 3D, digital audio, digital video, digital image compositing, and digital illustration (SVG) new media content creation.

### Android 7 平台结构:开放技术的集合

As you have learned, the foundation on which Android is built is the carefully coded, and painstakingly tested, Linux Kernel. Linux and its core services manage physical hardware for smartphones, tablets, e-book readers, smartwatches, and iTV sets, and give Android applications complete access to the features of each consumer electronics device, including GPS, touchscreen, memory, data storage, camera, flash, gyroscope, compass, accelerometer, barometric sensor, biometric (e-Health) sensors, Bluetooth, Wi-Fi, NFC, 4G LTE, USB, and much more.Linux doesn’t do it all alone, however. Android has a wide array of Java API libraries, that provide higher-level customized functions and services for things like SQLite database management, 2D image compositing, image blending, SVG rendering, 3D rendering, web page (HTML5, CSS3 and JS) rendering, digital audio playback, digital video streaming, frame-based and procedural animation, Bluetooth, and more. The majority of these are based on open technologies, such as SQL, GIF, SVG, WebKit, OpenGL, Vulkan, PNG, FLAC, Ogg Vorbis, Ogg Theora, VP8, and VP9\. Some “almost” open source (these patents expire in a few years) have been licensed for Android by Google, such as MPEG-4, MP3, WAVE, BMP, JPEG, Bluetooth, and similar new media technologies.The higher-level Java functional libraries are the ones that Android app developers use to create their applications. This is so that developers do not have to “talk” directly to the low-level operating system functions. This is done so that application development becomes an order of magnitude more easily! You will be learning about some of the core Java 8 functional libraries that are used to develop Android 7.1.1 applications during the course of this book, starting with this chapter when we look at the basic (empty) Android application bootstrap Java code.The Android OS on the user side of the equation (versus the developer side, which we will be focusing on during this book) also includes a large number of “end-user utility” applications, which Android device users have come to expect on their Android device. Examples of these include a phone call management utility, an e-mail client, various social media platform clients, a contact manager, a web browser, an alarm clock, a calendar, Google Maps, Google Search, a media player, and possibly some basic casual games, to name a few.Android OS supports all of the popular open source new media formats that developers will want to use in their applications, including the powerful ON2 VP9 video codec, added in Android 5\. ON2 was acquired by Google, and VP8 and VP9 were released in an open source video codec called WebM, which you can find in Android as well as in browsers such as Firefox, Opera, and Chrome. Both the WebM and the MPEG-4 H.264 AVC digital video codec’s “Quality to File Size Ratio,” and therefore their playback performance, are fairly impressive for open source video codecs. Also added in Android 5.0 was the ability to play back MPEG-H H.265 HEVC content.For more information regarding the two dozen new media formats that are supported in Android 7.1.1 you can visit:[http://developer.android.com/guide/appendix/ media-formats.html](http://developer.android.com/guide/appendix/media-formats.html)The next section of this chapter introduces Java’s Dalvik Virtual Machine (VM), which optimizes your Java code, so that it will execute effectively in low-power, embedded (portable and iTV set) consumer electronics devices.NoteIn this book you will build apps using a combination of XML and Java. These sit in layers on top of the operating system, as shown in Figure [3-1](#Fig1). However, you could, if you were advanced in Android development, access the operating system and its services directly, using the lower-level language C++, by utilizing the Android Native Development Kit (NDK), rather than using higher-level Software Development Kit (Android SDK), which we will be using for this book. You might consider this “under-the-hood” approach for an application that needs the utmost speed, such as a game, or real-time heart-monitoring workout program. This Android NDK is currently beyond the scope of this book.Now let’s take a look at the runtime, or compiled version, of your Android application, and how it uses Java bytecode with the Android Run-Time (ART) to optimize the runtime (end user) performance of an Android app.

### Android 7 可执行结构:编译运行时 Java 字节码

Everything in the Android Studio 2.3 development environment, as well as all of the included applications, is created by using a combination of Java code and XML markup. This is compiled by IntelliJ and Gradle into a Java “bytecode” version of your app that will be “executed” (run) using the Android Run-Time (ART) utility, which is a part of Android OS. IntelliJ creates this bytecode, and puts it into the .DEX file format (similar to an .EXE file).This .DEX file extension and data format essentially amounts to being a compact, low-level executable file format that the Android operating system, and therefore Android devices that run Android OS, will be able to understand and run. A DEX is not specifically encrypted, but if you look at the contents of one of these compiled files, it will not be readily decipherable. The flow of XML, to Java code, to bytecode, to executable data would be as follows:XML (.XML) → Java (.CLASS) → ByteCode (.DEX) → App (.APK) → Runtime (ART) → Device DisplayThe Android runtime environments before Android 4.4 used only Dalvik Virtual Machine (DVM); and in Android 4.4, you could choose between DVM and ART. Android 5.0 and later use only ART. These runtimes give your apps access to hardware device features, as well as the low-level Android and Linux Kernel functions, so that you don’t have to do all of that low-level programming yourself.The good news is that an an Android Absolute Beginner, you don’t need to understand much about ART, other than what this .DEX file is, the place it provides in the chain of code to runtime, and that it will do a good job optimizing your application for your users. To use the Java programming language, you’ll simply include the appropriate components from the Java libraries you need in your program, using something in Java called an import statement. After you do this, your app’s code can employ that built-in Java library’s capabilities. You will learn how to put a number of these powerful Java libraries to work later on in this chapter, and in all the chapters, for that matter, during the remainder of the book. We will also cover this in detail in the Java Primer in Chapter [5](05.html).Next, I show you how to create your first Android application, so that you can see how to organize your Android 7 application assets in a highly structured Android project hierarchy, which must be followed for Android apps to work properly. In this way we can get right to some hands-on use of the Android Studio application development environment, to see how you create a new, empty Android bootstrap application infrastructure; and start learning about Android Development, Android Studio, Java, XML, Gradle, application resources, and new media assets.

## 创建 Android 7 应用程序:Android Studio 的新项目

By now you are probably quite eager to fire up Android Studio and IntelliJ 2016 , and to create your first Android 7 application. We need to do this so that you can observe how Java code, XML markup, and new media assets, called “resources ” in Android, work together when it comes to creating your own custom Android 7.0 application.A time-honored tradition across every programming language is for new users to create a “Hello World” application. Let’s create our own Absolute Beginner Hello World Android application, right here and now. Just so that we do things as “out-of-the-box” as possible, we will eventually turn this application into a “Hello Universe” application during the book so that we can expand (no pun intended) on the bootstrap (empty) application that Android Studio creates for us as we learn more and more about Android graphics, user interface design, and so forth. We’ll add all sorts of impressive features that you’ll find around our universe.First, we will launch Android Studio, and create the new application. Then we will take a look at all of the files that Android Studio creates for us, as well as the Java and XML code that Android Studio generates to get your app up and running. We will then examine in detail the resource folder hierarchy for the project structure and see how Android Studio wants you to structure your Android 7.0 project assets (resources).Finally, we will take a look at how to upgrade to later versions of Android Studio when you already have Android Studio installed. A later version of Android Studio 2.3 was released when I was working on this chapter, so I took some screenshots that show what you will see when a new version of Android Studio is released and how to handle the download, upgrade, and installation process from inside of Android Studio itself.

### Android Studio 欢迎菜单:创建新的 Android 7 应用程序

The first step is to launch Android Studio 2.3\. From there, using the Welcome to Android Studio menu that you saw in Figure [2-5](#Fig5) in Chapter [2](02.html), you will create your new Android 7.1.1 application project. The application infrastructure we are about to create (or Android Studio is about to create for us) will contain your application’s Java programming logic, XML markup, new media assets, and your other application resources.

1.  1。要启动 Android Studio，找到并单击位于工作站任务栏上的 Android Studio 快速启动图标。如果你没有创建其中的一个，在你的硬盘上找到Studio64.exe(你可以在你的文件管理工具中使用搜索)，双击它。
2.  2。你会看到欢迎来到 Android Studio 启动对话框，你会点击第一个选项开始一个新的 Android Studio 项目。如果您想查看上述对话框的截图，请参见第 [2](02.html) 章中的图 [2-5](#Fig5) 。
3.  3。选择该选项后，将出现新建项目对话框，如图 [3-2](#Fig2) 所示。这是五个对话框中的第一个，您将使用它们来创建一个空白的 Android Studio 项目。这些对话框将引导您完成创建新的 Android 应用程序项目基础设施的过程。接受您的应用的默认名称我的应用和user.example.com 公司域名。由于这是绝对的初学者标题，您将不需要选择您的包含 C++支持选项复选框。点击下一步按钮，进入目标 Android 设备对话框，在这里您将接受默认的手机和平板电脑应用类型选项。![A324674_4_En_3_Fig2_HTML.jpg](A324674_4_En_3_Fig2_HTML.jpg)图 3-2。接受默认的我的应用名称、user.example.com 公司名称、手机和平板电脑，点击下一步
4.  4。在目标 Android 设备对话框中点击第二个下一个按钮后，Android Studio 可能会启动安装 Android SDK 资源库更新程序进度条，如图 [3-3](#Fig3) 所示。Android Studio 正在做的是检查您为核心 Android 操作系统(手机和平板电脑)以及 Android Wear 2、Android TV、Android Auto 或 Glass 的使用指定的 Android APIs。如果其中任何一个需要安装或更新，安装 Android SDK 更新功能将自动启动，并使 Android Studio 符合您希望开发的 Android 应用程序的应用程序类型。![A324674_4_En_3_Fig3_HTML.jpg](A324674_4_En_3_Fig3_HTML.jpg)图 3-3。Android Studio 将为您想要使用的目标 Android 设备安装所需的任何组件
5.  5。一旦 Android Studio 下载了开发您在目标 Android 设备对话框中指定的 Android 应用程序所需的所有新更新和 API，您将看到如图 [3-4](#Fig4) 所示的安装请求的组件对话框。这将向你展示你的 Android 工作室正在添加什么。在此对话框的左下方看到完成后，单击下一步按钮进入下一个对话框，继续创建一个新的空白 Android 应用引导软件基础架构。![A324674_4_En_3_Fig4_HTML.jpg](A324674_4_En_3_Fig4_HTML.jpg)图 3-4。安装请求的组件对话框会告诉你 Android Studio 已经为你安装了哪些 API
6.  6。你会遇到的下一个对话框是添加活动到移动对话框，如图 [3-5](#Fig5) 所示。默认选项是创建一个空活动(在该图的中上部显示为选中的蓝色)。对于绝对初学者来说，这是最好的选择，因为我们需要检查创建 Android 应用程序所需的最少 XML 标记和 Java 代码。然后，我们将在这些知识的基础上进行构建，并了解基本 Android 应用程序基础架构的组成。![A324674_4_En_3_Fig5_HTML.jpg](A324674_4_En_3_Fig5_HTML.jpg)图 3-5。在添加一个活动到移动对话框中，接受默认的空活动选项，以蓝色显示，并点击下一步
7.  7 .。看看向移动设备添加活动对话框中的其他选项，看看 Android Studio 能够为您创建什么。这是一个非常酷的功能，因为 Android Studio 将自动为您完成许多核心应用程序 Java 编码和 XML 标记，允许您进入应用程序开发阶段，在那里您可以投入新的媒体资产，并更快地定义您的软件功能。您可以为 iTV 电视机或平板电脑创建全屏活动；Google AdMob 和地图活动；导航抽屉活动；滚动活动；选项卡式活动；一个基本的 Android 活动；以及各种基于实用程序的活动，如登录屏幕、设置集合、主从数据显示实用程序等等。如果你想知道这个“活动”是什么，它是一个功能性的用户界面显示屏或 Android 中的功能集合。
8.  8。点击下一步按钮后，将进入自定义活动对话框，如图 [左侧 3-6](#Fig6) 所示。接受默认的 MainActivity Java 类名和 activity_main.xml 用户界面布局容器名，因为我们也将在本章中学习这些 Android 应用程序组件命名约定。保持选择生成布局文件(这样 Android Studio 会为您编写 XML 标记)，以及向后兼容性(AppCompat) 选项。AppCompat API 包含允许您为 Android 7.0 编写应用程序，这些应用程序也可以在 Android 4.0.3、5.0 和 6.0 上工作，正如您已经在目标 Android 设备对话框中指定的那样，显示在图 [3-2](#Fig2) 的右侧。![A324674_4_En_3_Fig6_HTML.jpg](A324674_4_En_3_Fig6_HTML.jpg)图 3-6。用 MainActivity 名称和 activity_main 用户界面布局名称定制活动，点击完成
9.  9。一旦你点击完成按钮，Android Studio 将开始为你的应用构建 Gradle 文件，如图 [3-6](#Fig6) 所示(编号为 2)。Gradle 是 Android 5.0 中采用的开源构建工具，它管理 Android 应用程序的编译(构建)。在 Android 5 之前，Eclipse 使用 Apache Ant 和 Apache Maven 构建工具。由于这是一个绝对的初学者标题，我们不会深入研究 Gradle 构建工具和配置的复杂性，而是利用它们来创建您的 Android 应用程序。
10.  10。如果某个时候你的 Windows 防火墙使用 Windows Alert 对话框拦截了 OpenJDK 平台二进制文件，如图 [中右所示 3-6](#Fig6) ，点击允许访问按钮(编号为 3)，允许 OpenJDK 平台二进制文件与你自己的私有网络通信。如果你确实知道公共网络是安全的，你也可以选择公共网络。在你这样做之后，Gradle build 工具将继续创建 Android 7 应用程序构建文件，一个进度条对话框将精确地告诉你哪些文件正在为你生成。我们稍后会看一下这些文件，这样你就知道它们在你的项目中的什么位置。
11.  11。一旦这个 Gradle 构建过程完成，Android Studio 就会启动。您将在标题栏中看到您的 MyApplication 项目名称，以及您的项目文件和 Android Studio 版本的位置，如图左上方的 [3-7](#Fig7) 所示。在我的例子中，项目文件位于 C:\Users 文件夹中，在C:\ Users \ user \ AndroidStudioProjects \ my application下。![A324674_4_En_3_Fig7_HTML.jpg](A324674_4_En_3_Fig7_HTML.jpg)图 3-7。关闭日积月累对话框，同意(或不同意)帮助改进 Android Studio，完成索引您的项目
12.  12。在屏幕中间出现的日积月累对话框中的(我移动它是为了向你展示它在处女启动中的背后是什么)，浏览一些或所有的提示，然后使用关闭按钮来关闭 Android Studio 2.3 的教育功能。如果你想在以后利用这个特性，你可以保持启动时显示提示选中，我会推荐你作为一个绝对的初学者，直到你熟悉 Android Studio。我在图 [3-7](#Fig7) 中将第一步编号为 1。
13.  13。关闭日积月累对话框后，Android Studio 会打开一个弹出对话框，如图 [3-7](#Fig7) 中编号为 2，询问您是否要与 Google 共享您的使用统计数据，以便他们可以对 Android Studio 2.3 进行用户界面和用户体验改进。如果您可以接受，请单击我同意链接，否则，请单击我不同意链接。
14.  14。Android Studio 和 Gradle build 系统将继续构建和索引项目，如图 [3-7](#Fig7) 右下角所示，使用进度条和文本更新来显示正在进行的操作。
15.  15。还要注意在 Android Studio 屏幕的中央有一些快捷键，你可以用它们来加速你的 Android 7 应用程序的开发(这就是为什么我把日积月累对话框移开了)。在列表的底部，请注意“将文件拖放到这里以打开”，这让您知道您可以将现有的 Android Studio 文件拖到 Android Studio 2.3 中以打开它们。您还可以使用双 Shift 到处搜索，使用 Alt+1 获得项目视图，使用 Ctrl+Shift+N 转到文件，使用 Ctrl+E 打开最近的文件，使用 Alt+Home 访问导航栏。

Once your new project build has finished building, indexing, generating Java code and XML markup, and all of the other steps needed to create your Android application, the blank screen in Android Studio will be replaced with the project navigation and development panes that we will use during the remainder of the book to develop (and learn) Android applications.These various panes let you navigate your project structure as well as edit your Java code and XML markup structure, as well as more complex files such as the Gradle build files that use the Groovy programming language. Let’s explore Android Studio 2.3 next, and see what we can learn about Android applications, and how they need to be put together, in order to compile (build) into a usable Android package (.APK) file that you can use in Google’s Play Store, to publish applications.

### 探索您的 Android Studio 项目:Android 应用程序结构

Once Android Studio opens, use the right-facing arrows to open the primary application folders, so you get what is seen on the left half of the screen in Figure [3-8](#Fig8). The right-facing arrows are called expand arrows, which turn into downward-facing arrows, called collapse arrows. These arrow heads toggle folder directories open or closed, as you’ll see, once you get familiar with them. As you can see, Android has a top-level app folder, which contains three primary subfolders: manifests, java, and res (resources). java and res subfolders have subfolders as well.![A324674_4_En_3_Fig8_HTML.jpg](A324674_4_En_3_Fig8_HTML.jpg)Figure 3-8.Open the Android Project pane folder hierarchy, and see what folders need to be used for Android DevelopmentYour application Java code is in an app\java\com.example.user.myapplication folder that takes its name from the Application Name and Company Domain fields, which you saw in Figure [3-2](#Fig2). Inside of that folder is the Java code file MainActivity.java, which when compiled into Java bytecode, will become MainActivity.class after a build.Your application resources (I like to call these your application’s “assets”) on the other hand are contained in the app\res\drawable (images and illustration), app\res\layout (user interface design), app\res\mipmap (app icons), and the app\res\values folder and its subfolders, which contain XML definitions and constant values for the app.We will be getting into what the Java code in the MainActivity.java tab in the Android Studio central editing pane does in Chapter [5](05.html), so in this chapter, let’s focus on the contents of the Android project management pane, and learn what all of the components are that make up an Android project structure. As we do this during this chapter, we will take a look at the various subfolders and what components of our Android application need to be stored in certain subfolders. One of the things you need to do to become an Android developer is to learn how Android projects need to be organized. It’s really too bad there is not “forced organization” in more areas of our lives, because as you will soon see, Android is organized in such a way that it forces your application development work process to be surgically precise!Let’s take a quick look at the activity_main.xml tab, which is shown selected in the center of Figure [3-9](#Fig9). You will be learning about XML in Chapter [4](04.html), but I wanted to make sure you knew how to click on tabs in the editing section of Android Studio, so you can go back and forth easily between editing your app’s XML markup and Java code.![A324674_4_En_3_Fig9_HTML.jpg](A324674_4_En_3_Fig9_HTML.jpg)Figure 3-9.Select the activity_main.xml editing tab (top) and Text tab (bottom), and use the Preview pane to see your appAs you can see, Java files go in the /app/java folder hierarchy, and the rest of the folders contain XML files and (or) new media assets. There are a large number of different types of resource folders, which start with specific names, such as drawable (image, animation, or shape assets), layout (UI Design XML definition assets), mipmap (app icon imagery), and values (value constants defining colors, dimensions, styles, and text strings).You can also add other types of Android application project asset folders to this project folder hierarchy, which we will be doing during the course of this book, when we add advanced assets like digital video and animation. Since these folders also require specific names, which indicate the type of assets, as well as their functionality, I will outline what Android asset folder types (indicated by their folder names) and naming conventions are. I will provide them in a tabular format in Table [3-1](#Tab1), just so you have an overview of Android’s project folder hierarchy.Table 3-1.Android Project Directory (Folder ) Hierarchy, showing key subfolders that you will be using during this book

<colgroup><col> <col></colgroup> 
| Android 项目子文件夹名称 | 该子文件夹必须包含的应用程序资产的类型 |
| --- | --- |
| /舱单 | Android 清单 XML 文件(您的应用程序权限和规范) |
| /JavaT5】 | Java 源代码文件(你的 Java 编程语言应用逻辑) |
| /res | 项目资源(您的新媒体资产、UI、菜单和 XML 标记定义) |
| /RES/drawable | 数字图像和数字插图资产(这些在 Android 中称为“可绘制物”) |
| /RES/layout | UI 设计布局 XML 定义(UI 元素是 Android 中的“视图”或“视图组”) |
| /res/mipmap | 应用图标(分辨率/密度特定[DPI] PNG32 数字图像图形资产) |
| /RES/menu | 应用程序菜单项 XML 定义(我们稍后将从头开始创建) |
| /RES/anim | 2D 图像/插图动画(程序、帧或补间动画 XML 定义) |
| /RES/animator | Android widget (UI 元素)属性动画(以及 XML 定义) |
| /res/xml | 自定义 XML 定义(除了 UI、菜单、样式、主题、动画、常量等。) |
| /res/raw | 数字视频或数字音频资产(已经过数据占用优化) |
| /RES/valuesT5】 | 在应用期间保持固定的数据值(称为常数) |
| /分辨率/数值/颜色 | 应用颜色值常数 |
| /分辨率/数值/尺寸 | 应用尺寸(宽度和高度)常数 |
| /RES/values/string | 应用文本串(标签、标题、消息、固定文本短语)常量 |
| /RES/values/styles | 应用风格和主题 |
| /RES/values/bool | 应用布尔(真或假数据值)常量 |
| /分辨率/数值/数组 | 应用数据数组(数据值的列表或集合)常量 |
| /分辨率/数值/整数 | 应用整数常量 |

Let’s spend the rest of the chapter taking a look at the types of resource folders and what they contain, as this will show you what an Android application can contain, where you will need to place assets in order for them to be utilized properly, and show you capabilities and design factors that you’ll need to be aware of to make Android apps work on different Android hardware device types with various sizes, shapes, orientations, and resolutions.

## Android 资源:资产的项目文件夹层次结构

If you want to add custom animation, custom menus, digital video, or digital audio to your Android project, you will have to create new folders under your project resource folder hierarchy. You will be learning how to do this during the course of this book, as you learn about how to add these types of assets to your Android application. I want to expand on Table [3-1](#Tab1) for you to give you a deeper understanding regarding the different folder types that are available for use in your Android applications. This is so that you have a high-level view of what is possible in Android development and the types of Android assets you are going to learn how to incorporate during this book.Your “external” new media assets, that is, those which are created outside of Android Studio using software like GIMP, Fusion, Lightscape, Blender, Audacity, and Inkscape are kept in the resources folder, shown in Figure [3-9](#Fig9) opened up to show all subfolders, and referenced as app/res/.Other “internal” resource assets, which are ultimately referenced by your Java code, or in other XML definitions, are created using XML markup in what I call “definition files,” because they define application assets using XML markup. XML definitions can include things such as number, text and Boolean constants, styles, themes, menus, animation, and user interface layouts, and these are also kept in the resources (app/res) folder hierarchy.There are many different resource types in Android, and they either have their own subfolders under the app/res/ project folder, or their own filenames, under the /res/values/ folder. We’ll go over the majority of these in detail in the next eight sections of this chapter.You can also provide alternate resources in this application project resource folder hierarchy. The alternate resource folders provide support for a wide array of device types or physical hardware specifications, by grouping new media assets, user interface designs, and style and theme definitions into specifically named alternate resource folders. The \res\values-sw600dp folder is an example of an alternate resource folder name that would hold assets that are specific to an application design for 600-pixel or larger screen dimensions. The sw signifies “smallest width” and thus anything larger than 600 DIP (Device Independent Pixels) would qualify.At runtime, Android 7 will use the appropriate resource based on the device hardware specification.NoteRuntime is the stage when your code runs as an application. This is after the compilation process when Android Studio turns your code into bytecode. The ART uses this bytecode to run the application at runtime.As an example, if you want to provide different UI design layouts that morph, or change, based on the physical screen size, shape, or orientation (portrait or landscape), you can define different UI layout designs using different layout folder names, such as app\res\layout-land for a landscape-specific UI layout design, or app\res\layout-port for a portrait-specific UI layout design.As another example, you could define different string (a collection or array of text characters) values, which would be evaluated at runtime based on the language setting on the end user’s Android device. As you can see, there is a reason for the way Android organizes resources, and one of the major reasons is so that developers can create alternate resources (alternate resource folders) that can be accessed at runtime based on Android device characteristics. As this book progresses, I will show you how to reference and access external resources from within your Java code and XML markup. We will look into how to set up alternate resource folders in the chapters covering user interface design, themes, and styles. Let’s look at Android drawable assets next, as most apps will use digital image (PNG) and digital illustration (SVG) assets.

### Android Drawables:在屏幕上绘制的图像或插图

A “drawable” in Android is aptly named, as it is anything that can be drawn onto the display screen. As you can see in Figure [3-9](#Fig9), Android Studio created five different application icon drawable-dpi versions for your PNG32 app icon. The app icon is named ic_launcher.png and is in the app/res/mipmap folder in the five most common pixel density drawable-mdpi, drawable-hdpi, drawable-xhdpi, drawable-xxhdpi, and xxxhdpi DPI resolutions. The latest XXXHDPI resolution density was added in Android 4.2 to accommodate Ultra-High Definition (UHD) displays, such as those found on 4K TVs, which have a 4096 by 2160 resolution; or the screen on the Samsung Galaxy S7, which has a 2560 by 1440 pixel resolution screen. From smartwatch (ldpi) to 4K TV (xxxhdpi), Android has a density constant to fit any consumer electronics hardware device.You will be learning all about pixels and resolutions during Chapter [9](09.html) when we cover graphic design, but to give you an overview here of what the different DPI levels are for Android screen resolution density constants, I have put all of the density constants and their specifics in Table [3-2](#Tab2), for those of you who are already “pixel savvy.”Table 3-2.Android Device DPI: Seven levels of Pixel Density constants specifically supported in Android 7 and previous APIs

<colgroup><col> <col> <col> <col> <col> <col> <col> <col></colgroup> 
| 安卓 DPI 常数(及其密度水平) | 常量名称 | 像素密度 | 像素乘法器 | 最小显示 | 图标大小(以像素为单位) | 动作栏图标尺寸 | 通知图标大小 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| LDPI(低密度) | 小 | 120 | 0.75 | 426x320 | 36x36 | 24x24 | 18x18 |
| MDPI(中等密度) | 正常 | 160 | 1.0 | 470x320 | 48x48 | 32x32 | 24x24 |
| TV dpi(1280 x 720 HDTV) | 电视 | 213 | 1.33 | 640x360 | 64x64 | 48x48 | 32x32 |
| HDPI(高密度) | 大 | 240 | 1.5 | 640x480 | 72x72 | 48x48 | 36x36 |
| XHDPI(超高密度) | xlarge | 320 | 2.0 | 960x720 | 96x96 | 64x64 | 48x48 |
| XXHDPI(超高密度) | xx 大 | 第 480 章 | 3.0 | 1280x960 | 144x144 | 96x96 | 72x72 |
| XXXHDPI(超高密度) | 大 | 640 | 4.0 | 1920x1080 | 192x192 | 128x128 | 96x96 |

As you can see in Figure [3-9](#Fig9), I opened the drawable folder for you to show the ic_launcher graphic file that Android Studio created for you in five different resolution density versions. If you are wondering what the pixel dimensions are for these ic_launcher files, take a look at the sixth column in Table [3-2](#Tab2).There are about a dozen different types of drawable objects in Android, each of which has their very own class. Some of the more important drawable types include BitmapDrawable, ShapeDrawable, NinePatchDrawable, AnimationDrawable, LayerDrawable, TransitionDrawable, and StateListDrawable, to name a few. I will try and implement as many different types of drawables as I can during this book, so you will be well rounded when it comes to using drawables in Android application development.There are several types of drawable assets that will need to be placed in the drawable folders for these assets to be visible to, and accessible to, the Android application. The primary one is bitmaps, which we will be covering in Chapter [9](09.html), as well as media assets that are based upon (created with) bitmaps, such as frame animation , which we will be covering in Chapter [10](10.html). Assets that reference Bitmaps or Frame Animation in an XML definition file format would also be kept in this folder, as would any XML definitions creating shapes (2D vector graphics).

### Android 用户界面设计布局:设计用户界面布局的资产

A “layout” in Android is also aptly named, as it is a definition of how your user interface elements and drawable assets are going to be “laid out” relative to each other on the Android device display screen. Once we get you up to speed on Java, in Chapter [5](05.html), you will be learning more about UI layout design throughout the rest of this book! Chances are, if you want your Android app to have a custom design for each type of device (iTV, smartphone, tablet, smartwatch, and iTV set), you’re going to have a number of custom /res/layout folders, not just /res/layout-land or /res/layout-port folders as I gave as an example earlier. You can have complex alternate resource folders as well, such as /res/layout-sw800dp-land for tablet, and /res/layout-sw480dp-port for phone or smartwatch.The /res/layout/ folder and any custom layout alternate resource folders that you create will generally contain UI layout definition XML files. As you will see during Chapters [6](06.html) and [8](08.html), and over the rest of the book, UI layouts in Android are defined using XML layout definitions. These are handcrafted using XML markup, and stored in filename.xml files in the /res/layout folder or one of the alternate layout resource folders that you create.Since we are going to look at the XML for the UI layout that Android Studio created for us in Chapter [4](04.html), and because we have a couple of chapters coming up specifically covering UI layout design, I am going to leave the /res/layout/ folder coverage at that, and move on to look at some of the other resource folder types next. Although Android applications tend to use Activity screens filled with UI widgets for navigation, Android does support menus as well, so let’s take a look at that next, as it is often integrated with the Activity user interface design layout.

### Android 菜单设计:定义菜单结构和选项的资产

A “menu” in Android is exactly what it says it is, and what you would expect it to be: a menu, or a list full of options, for your end users to select from in order to navigate around your Android application infrastructure. In previous versions of Android. menu use was not as much as a priority as it is going to be as iTV set devices and integration with Chrome OS (and Android laptops and PC sticks) become popular with billions of consumers.There are several types of menus in Android, including pop-up menus, context-sensitive menus, and options menus. We will get more into menu design as we progress through this book, adding menu items to your application’s menu. Technically, the Android menu that your application uses, via a hardware MENU button on the Android device or via those three vertical dots on the Action Bar at the top of an Android device if there is no hardware MENU button, is called the Options Menu. The Status Bar is always above the Action Bar, at the very top of every Android device, and holds the battery power indicator, network mode indicator (3G, 4G, 4G LTE, and so forth), signal strength indicator, wireless connection indicator, and other device operation indicators.In addition to the options menu, the Action Bar contains your application icon; application title; and if you code it correctly, either icons or text tabs that can access areas of your app, each of which is generally an Activity with its own UI design layout scheme.The app/res/menu/ folder will contain XML definitions outlining the menu structure that you want to create for your application. Notice in Figure [3-9](#Fig9) that Android Studio follows file naming conventions for Java and XML files, so you would want to follow those and name the file containing your menu definition menu_main.xml. Notice the file naming convention; a menu_main.xml menu XML definition, a MainActivity.java and an activity_main.xml layout XML definition file. These all logically match up (type+function), so you know they are all functionally related to each other. This is because each Activity will have a UI layout and a menu, so this keeps things organized so that you know what code works together as an Android application complexity increases over time.

### Android 数据值:定义固定应用程序常数的资产

A “value” in the Android project folder hierarchy is what is known in Java programming as a “constant.” Values in Java code are different than Java constants, as they are meant to change, whereas constants are meant to stay the same (that’s why they’re called constants). We will be getting into this distinction as far as Java goes soon, in Chapter [5](05.html), when we look at the Java programming language specifically. You will, of course, be required to understand exactly how Java works before we get much further into the book, as things will get more and more complicated with each successive chapter.Android values (constants) are a bit more flexible than Java constants, because once your Java code places these initial constant values into memory, the application code may change them if needed.Let’s examine the app/res/values/ folder from the current application bootstrap project in more detail. This is where you (or Android Studio, in the case of the New Android Application Project series of dialogs) will place any predefined application values. These exist in the form of XML files. These XML files contain constant definitions that define constant names and their data values.The value constants that are defined inside of these XML files will later be referenced inside of your Java code, or via your XML markup. For example, these values might be strings (a collection of text characters), styles (how you want a UI design to be formatted throughout your app), dimensions (numeric size specifications), or other constants that need to be “hard-coded” values that your Java code or XML markup uses in your program logic or UI design that you do not want to change.The logic behind having an app/res/values/ folder involves holding all of your constant values for your application in one place. This is a similar concept to the repository we used in Chapter [2](02.html) to update Android Studio, only the /res/values/ is a resource repository for value constants that are used in your Android application. The /res/values/ folder is therefore your application constants repository data (folder) structure, and its usage allows you to make your application constant changes in one single location. In this way, if you need to adjust your constant values during application development or testing, you can do this using XML files.Figure [3-9](#Fig9) shows four examples of the types of constant value XML files that Android Studio has already created for you and placed into the app/res/values/ folder in your bootstrap Android application IntelliJ project hierarchy:

*   colors.xml : 一个 xml 文件，它将定义要在您的应用程序中使用的颜色常数值。这些允许你标准化用户界面。例如，您可以将应用程序的背景颜色定义为常量。然后，如果您决定以后对它进行调整，您只需要在一个地方进行调整，更改就会在整个应用程序中实现。我们在第 [9](09.html) 章中详细介绍了色彩理论和十六进制色彩值，这将涵盖 Android 图形设计的概念和原理。
*   dimens.xml : 一个定义维度常量值的 xml 文件，比如标准的屏幕尺寸，或者你的 UI 的字体大小。然后，您可以在整个应用程序中使用这些值，以确保一致性。
*   strings.xml : 一个 xml 文件，定义了应用程序中使用的文本(Java 中称为“字符串】)值。例如，您可以将屏幕标题、菜单选项或应用程序名称放在这里，并在代码中引用这些文本常量。如果将来需要更改或细化这些项目，只需在这个中心位置完成，而不是在 Java 代码或 XML 标记中。
*   styles.xml : 一个定义了 UI 设计样式的 xml 文件，您将在整个应用程序中使用这些样式。这些样式常量将应用于 UI 元素，然后这些元素将引用这些样式常量定义，允许您将应用程序的外观与物理布局和 UI 功能分开。随着时间的推移，这使得你的应用程序更容易改进、改变和提高风格。

Some of the other types of value constant XML definition files that you could later create, and locate, in your Android project’s app/res/values/ folder would include the following data value constant types:

*   arrays.xml : 一个 xml 文件，它定义了任何系列的数据值常量，这些常量将在应用程序中一起使用(在 Java 中称为数组)。例如，这可以是向用户显示的图标文件列表、图形层列表、菜单项列表或选项列表。
*   integers . xml:一个 XML 文件，它定义了将在 Android 应用程序的 Java 编程逻辑中使用的数字整型常量值。我们将在第 [5](05.html) 章讨论这个话题。
*   bool.xml : 定义布尔常量值(真或假)的 xml 文件，这些值将用于应用程序中逻辑状态(如开关)的默认(初始)设置。这些示例可能包括诸如开或关、是或否、可见或隐藏、最小化或最大化等状态。

Notice that Android uses certain file name conventions for the different types of XML files in the app/res/values/ folder, adding another level of complexity. It is important to note that you can also create your own customized XML files and file names in this folder, so you are not limited to the constant types that are discussed here. Next, let’s cover the folder names that Android Studio (IntelliJ) did not automatically create for you, and that you can optionally utilize to contain other asset types, such as animation, digital video, digital audio, or custom XML data.

### Android 动画文件夹:定义矢量或补间动画的资源

Besides frame animation, also known as bitmap animation, or raster animation, Android 7 also supports vector animation, which it terms tween animation. This type of animation is also known in the industry as procedural animation, and is created using Java code or XML markup parameter definitions, rather than by “flipbooking” through a series or collection of bitmap images (like frames of video) to create the illusion of motion.Whereas bitmap animation in Android uses the BitmapAnimation class, tween animation in Android uses just the Animation class, and thus the proper folder to contain resources or assets related to procedural animation is not the app/res/drawable/ folder, but instead the app/res/anim/ folder, which you will have to create in order to utilize this type of animation in Android. Fortunately, we will be covering this during Chapter [10](10.html), so you will create this Android animation resource folder at that time.

### Android Animator:用户界面属性动画的资产

There is a third type of animation in Android, called property animation, used to animate “properties” also known as “attributes” or “parameters,” for any of your UI widgets, called “Views” in Android, and this can even be done across your entire UI design. You can use this to obtain impressive special effects, especially transitional effects, which will entice your end users and increase your app professionalism. Property animation XML definition files are held in the app/res/animator/ folder, and reference the UI elements that you want to animate, as well as To and From data values that are interpolated between to create a smooth property animation. The reason the folder is called the animator folder is because the Android Java class is called ViewPropertyAnimator.

### Android 原始文件夹:预优化的视频和音频资产文件

The app/res/raw/ folder in Android OS holds your application’s “raw data.” Raw data in Android is not optimized (touched) in any way by the Android OS, it is simply played back (usually streamed) from this folder “as-is.” This is the folder that you want to contain your new media assets for which you have taken the time to optimize the data footprint (file size) to quality ratio. This would be done outside of Android Studio, using new media software packages like Audacity, GIMP, Inkscape, or Lightworks, all of which you downloaded and installed in Chapter [2](02.html).We’ll be looking at how to create and leverage the app/res/raw/ folder a bit later on in this book during Chapters [11](11.html) and [12](12.html), where I will cover the Android MediaPlayer and MediaController classes, as well as how to play back digital audio and digital video new media asset resources using this particular raw asset resource folder.

### Android XML:任意 XML 和配置

The last resource folder that you should know about is the app/res/xml/ folder, which is used to contain non-Android XML files that specify data structures or configuration parameters that are for use in your application but which are external to (outside of) the scope of Android-specified XML structures. As you will see during Chapter [4](04.html) and the rest of the book, Android defines a great many application components and characteristics using XML, and this (the XML markup) must be done (written or structured) in exactly the correct way or format. This folder usually contains XML files that have nothing to do with the Android app creation process, but that are “parsed” (read) by an Android application using a Resources.getXML() method. We cover Java method calls in Chapter [5](05.html).

## 更新 Android Studio:随着时间的推移升级 SDK

When I fired up Android Studio to create the figures for this chapter, there was an update available link on the startup screen. I clicked it and got a Default Settings dialog, seen in Figure [3-10](#Fig10), showing an Android 7 update.![A324674_4_En_3_Fig10_HTML.jpg](A324674_4_En_3_Fig10_HTML.jpg)Figure 3-10.If you see an update link on the Android Studio startup screen, click it and see what new SDK has been released

1.  1。选择更新可用的 SDK 版本(在右上角，以蓝色突出显示，在图 [3-10](#Fig10) )，在这种情况下这是 24.0.1 ，或者 Android 7.0.1，如果你喜欢，然后点击确定按钮。
2.  2。点击 SDK Tools 选项卡，选择显示包详情，确保 24.0.1 被选中，如图 [3-11](#Fig11) 中的步骤 1；点击 OK 按钮，如图 [3-11](#Fig11) 中的步骤 2。![A324674_4_En_3_Fig11_HTML.jpg](A324674_4_En_3_Fig11_HTML.jpg)图 3-11。新建图层对话框
3.  3。点击确认更改对话框中的 OK ，如图 [3-11](#Fig11) 中的步骤 3，等待安装完成，如图 4。安装好更新后点击完成，如图 [3-11](#Fig11) 中的步骤 5。
4.  4。取消选择显示软件包详细信息选项，并确保 24.0.1 更新或您可能正在查看的任何更新显示为正在安装。对于我的安装，这是 24.0.1，如图 [3-12](#Fig12) 所示。一旦一切都更新了，点击 OK 按钮退出，当 Android Studio 启动时，它将是最新的版本。请注意，未来这可能是 API 25 或 26，因为 API 修订版每季度发布一次。![A324674_4_En_3_Fig12_HTML.jpg](A324674_4_En_3_Fig12_HTML.jpg)图 3-12。使用一个选择➤反转菜单序列来反转选区，这样它选择的是徽标而不是白色区域

Make sure to update Android Studio whenever it informs you that an update is available, as it is connected in real time to the Android Studio server. Now we’re ready for XML markup!

## 摘要

In this third chapter, you learned about how the Android platform is structured, and about how it deals with the application at runtime, when one of your end users launches it on one of their many Android hardware devices. You learned about Dalvik Virtual Machine (DVM) and Android RunTime (ART) virtual machines (VM). You learned how to create an Android Studio 2.3 application bootstrap and Android project folder foundation, by using the New Android Application Project series of dialogs in Android Studio. You took a closer look at the folders that comprise an Android 7 application, most of which (besides the Java source app/java/ folder) are application resource folders. We looked at the various types of resource folders that you can have in an Android application.In the next chapter, you will learn all about the XML markup language by taking an in-depth look at the Android application that you created during this chapter, including the XML files in the app/res/values/ folder as well as the app/res/layout/ folder and the AndroidManifest.xml file from your app/manifests/ project folder.