© Wallace Jackson 2017Wallace JacksonAndroid Apps for Absolute Beginners10.1007/978-1-4842-2268-3_10

# 10.Android 动画:图像和程序动画

Wallace Jackson<sup>1</sup>(1)Lompoc, California, USAIn the previous chapter on graphic design, I covered two-dimensional (2D) concepts, such as pixels, resolution, and aspect ratios, as well as three-dimensional (3D) concepts, such as layers, color channels, and their z-order. In this chapter, we are going to take all of that knowledge into the fourth dimension (4D), which is time, and discover how to implement animation concepts, including motion and frame rates. We are again going to build upon all of these fundamental graphics design concepts you learned about in the previous chapter, because you can also apply all of these foundational digital imaging concepts to animation. Thus we will be taking static (motionless) graphics concepts from the previous chapter, and turning them into motion graphics, which can look even more realistic because it looks like the subject matter is moving (animated), and therefore achieves even more realism.You can use image animation to create an illusion of motion, using cels or frames. You will be learning about all of these concepts, terminology, and techniques during this chapter, which you will use to create animation. During this chapter, we will take a look at exactly how to set up frame-based image animation for your Android app using an XML animation definition containing a parent <animation-list> tag as an image animation frames container. An <animation-list> parent tag allows you to add individual frames of an animation as child <item> elements. This allows you to create XML-based frame animation definitions you can use as multimedia assets.I will be covering more of the core Android classes that are used to implement graphic design elements, such as ImageView, and Android classes that are used to implement motion graphics, by using frame animation as well as procedural animation, AnimationDrawable (frame animation), and Animation (procedural animation). During this chapter we’ll utilize these Android animation and drawable classes to animate the SlidingDrawer UI layout container content. We will install an ImageView UI widget underneath your content_layout to hold an animation. We will also take a look at how to add procedural animation to your frame animation so that you can scale, rotate, and move your frame-based animation, creating powerful hybrid animation using only XML markup. We’ll also look at how you can animate (interpolate, actually) Android OS and UI settings to achieve cool effects.

## 帧动画:概念和技术

The first thing that we will always need to do is to get our knowledge foundation regarding frame animation concepts, formats, and terminology, since we’re going to use these during the rest of this chapter, in conjunction with working with Android animation. This new media is commonly called image animation, bitmap animation, or 2D animation, and I’m going to cover 2D vector animation, also known as procedural animation or tween animation, later on during this chapter, as it can be used in conjunction with 2D bitmap image frame animation.

### 帧动画:单元、帧和术语

Frame-based animation could be termed cel-based animation, because of the original 2D animation created by Walt Disney. Disney animators drew on what at the time were called cels, in order to represent each individual movement in their cartoon animation. Interestingly, original cels from these 2D animation projects are now framed, and sold to collectors for thousands of dollars. Thus there are both physical and conceptual connections between these two animation industry terms, frame animation and cel animation . Later on, with the advent of feature films, the term “frame” replaced the term “cel.” This was because the analog film projectors that were used to display 24 frames per second used frames of film. These frames of film were displayed using one or more reels containing film frames, which would create the illusion of motion when light was projected through the moving frames using film projectors in a theater projection room behind an audience.The technical term for frame-based image animation is raster animation , as the frames, or cels, are made up of collections of pixels. Pixel-based imagery is commonly known in the industry as raster imagery. Raster images are also commonly called bitmaps because they are a map (array) of bits (pixels). In fact, there is the bitmap (.BMP) file format that was originally used in Microsoft Windows, and is now supported for use under Android OS. Raster animation is also frequently called bitmap animation within the multimedia production industry. We’ll utilize these various animation industry terms interchangeably throughout this chapter, so that you will get used to using all of these different, but accurate, terms to refer to your frame-based 2D animation, which can also be called raster animation, bitmap animation, frame animation, cel animation, 2D animation, and image animation.

### Android 图像格式:PNG、GIF、JPG、web、BMP

Android supports the same open source digital image file formats that you use for 2D imagery in the Android application for use within the frame-based animation assets. If you think about it, this is logical as 2D animation is defined using individual 2D digital image frames as the foundation for 4D motion. The significance of this is that you can use indexed color images if you want to create 8-bit frame animation, using PNG8 or GIF formats. You can use truecolor image formats to create your 24-bit, or 32-bit, frame animation. You will do this by using PNG24, PNG32, WebP or JPEG digital image file format. Just as with image file formats Android prefers PNG over GIF, WebP, or JPEG when used in frame-based animation. This is due to a superior lossless image quality.Android OS support for several mainstream digital image file formats gives us an impressive amount of latitude to be able to optimize the frame animation’s data footprint. Because of Android’s support for the PNG32 format, you will also be able to implement an image compositing work process in your frame animation endeavors. You can do this using 8-bit alpha channel transparency capabilities in the PNG32 format on a frame-by-frame basis.

### 优化帧:颜色深度和帧数

In frame animation, there are three primary ways to optimize your animation data in order to achieve a smaller data footprint. You can reduce the resolution of each frame, you can reduce the color depth used to define each frame, and you can reduce the number of frames utilized to create an illusion of motion in the animation. Since we should provide at least three different resolution density targets to support Android, we will focus on optimizing color depth and total number of frames as much as possible first, for practical purposes. You’re going to want to provide frame resolution spanning from at least 120 pixels for MDPI through 240 pixels for HDPI to 480 pixels for XHDPI. As you will see during this chapter, you do have the option to provide fewer resolution density targets and have Android down sample the others. The hope is that Android will scale your assets down (term: down sample) rather than scaling assets up (term: up sample) as the quality results are better.Since we have a choice between using a lossless PNG32 (which as you now know is a truecolor PNG with a full 8-bit alpha channel) and an indexed color PNG8, which is many times smaller (per each frame), we will use this lossless PNG8 for animated elements that do not need to be composited (compositing requires a PNG32 8-bit alpha channel). We use ImageView elements layers to implement a compositing pipeline by using a background plate for static graphics and a source (foreground plate) for the animation.It is interesting to note that there is an advanced way around this compositing challenge, which is to use a white or a black background color for a PNG8 animation using no alpha channel and then composite with the Android PorterDuff class. This is because using certain PorterDuff blending modes, you can make white or black values become transparent, using blending algorithms rather than alpha channels. Alpha channels are more efficient (but have a heavy data footprint, especially when used across multiple frames in an animation) because they are static (that is, predefined), whereas using a dynamic algorithm at runtime will use valuable CPU processor cycles (system hardware resources). This PorterDuff image blending algorithm class is covered in great detail in the Pro Android Graphics (Apress, 2013) title, which I wrote before writing this Absolute Beginners title.If you are not going to have to composite your animation over other graphics or UI elements, or are compositing using blending algorithms with Android’s PorterDuff class, you can also consider a JPEG format, to get a much smaller per-frame data footprint. As you know, a JPEG codec does this by throwing away some image data, and thus throws away some of the original image quality. It’s important to note that using JPEG for animation could increase image artifacts in each frame of an animation. If you apply too much image compression on each frame, this will cause motion artifacts. When you animate JPEG artifacts, it causes the effect commonly termed in the industry as “dot crawl” or “pixel crawl.” With JPEG animation, not only do you have artifacts, but because the medium is animated, and the artifacts are on different pixels on each frame, it’s like they are waving their hands in the air and saying: “Here I am, I’m an important artifact!” This does not lend itself to a great user experience if the JPEG frames are poorly optimized, and this is contrary to the Pure Android design principles we covered.Just as you can optimize a 2D animation by using the indexed (8-bit) color depth, you can also optimize the 2D animation by using fewer frames to create the illusion of motion. As you will see in the next chapter on digital video, the same concepts hold true for bitmap animation as with digital video: fewer frames to store will yield a smaller data footprint, which ultimately should translate into a smaller Android application (or .APK) file size.Also, the smaller the number of frames that will be used to achieve realistic motion, the fewer frames will have to be defined in your frame animation XML definition markup. It’s also important to note that at runtime, fewer frames will require less processing power in order to play your frame animation, and less memory resources to hold the frames in, before they are displayed on the device display screen. In fact, we get professional results in this chapter by using only a few frames of animation for your ImageView UI’s 3D animation new media assets.Data footprint optimization becomes more important as the number of frame animations that are included in the application increases. New media applications such as games and e-books tend to have several frame animations running at any given time inside of the application Activity screen. Thus you need to consider processing power and system memory as valuable resources! Animation assets require careful optimization, so that the application does not use up your user’s Android hardware device memory and CPU resources while your app is being used.

### 动画分辨率:像素增加文件大小！

The number of pixels in each animation frame (the frame resolution for your image animation) is of tantamount importance for optimization of an image animation asset data footprint. Review the raw image data mathematics that we covered back in Chapter [9](09.html), and apply this to each frame in your animation, so that you can calculate the exact raw data system memory footprint you will need to hold all of the frames in your image animation.Just like you did with your static digital image button assets, you will need to provide several resolution density-specific raster animation image target resolutions so you can span every popular Android device screen density. For this reason, if you can make an animation a few dozen pixels smaller for each dimension, without affecting its visual quality, this adds up to memory savings across the different power-of-2 down sample density versions.It is important to make sure to trim any unutilized pixels within your animation, so that the animated elements come as close (one pixel away) to touching the edges of your image container as possible. You will see that I’ve done this in all the animation frame assets we will be using in this chapter, so you’ll be able to see what I mean.Similar to what you learned about digital imagery in Chapter [9](09.html), Android will automatically handle the decisions regarding which of the 2D frame animation pixel densities to implement for each device screen that the OS is running on. Our largest 480 by 480 pixel resolution frame animation asset is for the XHDPI resolution density, and I will create a 240 by 240 pixel version for HDPI, as well as a 120 by 120 pixel version to use for MDPI.The reason that I’m not creating an XXHDPI resolution version on the high end (4K iTV) is because the XHDPI animation frames can be scaled up if needed for those devices, which represent 5% of the device market, and on the low end (240 pixel flip-phone or smartwatch), the MDPI animation frames can be scaled down if needed for those devices, which also represent about a 5% market share among all the current Android hardware devices.

## 帧动画:使用 AnimationDrawable

Android’s AnimationDrawable class is used to create frame animation drawable objects, using digital image assets. This object holds a list of drawable assets that define the frames of the animation. The object also has data fields that hold playback parameters such as frame rate (speed) and looping parameters.Android’s AnimationDrawable class is part of the android.graphics package, as you might imagine, and is kept with all of the other types of drawable objects in Android, using the android.graphics.drawable sub-package.The class hierarchy starts with the java.lang.Object class. This is subclassed to create a Drawable class, which is subclassed to create the DrawableContainer class, which is subclassed to create this AnimationDrawable class. The Java class hierarchy for the AnimationDrawable class would therefore look like the following:java.lang.Object> android.graphics.drawable.Drawable> android.graphics.drawable.DrawableContainer> android.graphics.drawable.AnimationDrawableThe reason that this DrawableContainer class is between Drawable and AnimationDrawable is because it was logical to create the DrawableContainer class for what you might consider “multi-drawables,” or drawables with more than one state, level, layer, frame, or other such drawable asset element. Examples of these ContainerDrawable subclasses include a StateListDrawable, used to create your multi-state ImageButton, a LevelListDrawable, used for level indicators, such as the signal level meter for your smartphone, and this AnimationDrawable.The simplest way to create one of these frame animation drawable assets is to define the animation frames using an XML file, which will be stored in your NavDrawerPattern project’s res/drawable folder. We will be creating three image animations during this chapter, using AnimationDrawable and Animation classes, after we discuss how the AnimationDrawable and Animation classes function. After we create the AnimationDrawable object(s), we will set them up with images, using the ImageView object. Later on in the chapter, when we write your Java code for the SlidingDrawer, we’ll call the . [start](http://developer.android.com/reference/android/graphics/drawable/AnimationDrawable.html#start()) () method to start an AnimationDrawable object playback cycle.The XML animation definition construct that you are going to be specifying later in the chapter gets inflated by your Java code, and becomes the AnimationDrawable object. This object contains all information regarding your frame animation asset, including each actual animation frame’s image asset reference, as well as playback (duration) and looping (direction) settings.After an AnimationDrawable object has been instantiated and inflated, you can trigger it using a .start() method from within your application’s Java code. This is usually done from the inside of your event handler, such as the one that we will be adding to the ImageButton UI elements later in the chapter. You would use an event handler if you wanted the frame animation to be triggered (started) interactively.You can also call the .start() method from the inside of your AppCompatActivity subclass onCreate() method, if the animation is intended to simply run on your Activity startup screen somewhere, once the Activity is created. This can be done for content decoration where looping animation adds realism to elements such as barber poles.If you want to research more detailed information regarding the Android AnimationDrawable class, you should investigate the more technical details for this class on the Android Developer website using the following URL:[https://developer.android.com/reference/android/graphics/drawable/AnimationDrawable.html](https://developer.android.com/reference/android/graphics/drawable/AnimationDrawable.html)Now that we have gone over the AnimationDrawable class basics, let’s take a look at how to use XML markup to create the frame animation definition file, which will live in the Android Studio project res/drawable folder.

### 创建帧动画:XML 帧定义

The way that frame animation is defined in Android is by using an XML definition file containing markup that defines an animation list filled with frame items. This XML file should be stored in your /app/res/drawable/ folder, which you created in Chapter [9](09.html), and which holds your Android drawable asset XML definitions, such as multi-state (StateListDrawable) ImageButton elements, NinePatchDrawable asymmetrically-scalable digital image assets, and soon your AnimationDrawable digital image frame animation assets.In case you are wondering why this XML file is kept in your /res/drawable folder, and not in a /res/anim folder, this is because there are two types of animation in Android.

*   帧动画使用 /drawable 资源文件夹层次来保存 AnimationDrawable XML 定义，以及 /drawable-dpi 子文件夹中的备用图像资源。
*   程序动画，我们将在本章稍后介绍，使用 /res/anim 项目文件夹以及 Android Animation 类来创建(程序)动画对象。

The frame animation XML file will specify the individual frames in your AnimationDrawable object definition. Essentially the XML definition file is an AnimationDrawable object constructor using a <animation-list> parent tag and <item> child tags. A frame animation XML construct essentially creates the AnimationDrawable object, which contains references to numbered frames (image files). The image file references represent your individual frames for a raster animation. A procedural (also known as vector) animation XML file on the other hand, won’t specify any frames, but will instead specify algorithmic, or procedural, transformations, that when interpolated, will create the illusion of motion. We will be covering this type of animation a little bit later on in this chapter.

#### 标签:你的图像框架容器

Your frame-based animation assets will be created by using an <animation-list> XML parent tag along with its playback and visibility configuration parameters. The primary configuration parameter that you will be using is an android:oneshot parameter. A oneshot parameter controls whether animation playback loops continuously (using the oneshot="false" setting), or if it will be configured to play just one single time (using the oneshot="true" setting). One-single-time playback is usually used with an event handling setup, because you want the animation to play one time whenever it is clicked. The continuous playback method, on the other hand, is usually set up with a .start() method call inside of an onCreate() method, so that your animated design element continues playing (all the time, forever), somewhere on that Activity’s display screen.Later on you’ll reference the XML file that contains this <animation-list> parent tag, and its child tags, by using its first name (that is, the first part of the filename) without the extension, just like you did with your multi-state ImageButton definition, in the previous chapter. We will create a frame animation XML definition file that uses an anim_logo.xml file name, but which references this file in XML markup and Java code as: anim_logo. Once this <animation-list> is defined using XML, you’ll be able to reference the frame-based animation that you have defined from any of your UI design or content containers across your entire application.Finally, there is the android:visibility parameter, which you can utilize if you are going to control the visibility of your AnimationDrawable object within your Java code. You can use this parameter to set the initial visibility setting, which is usually going to be “true” or visible, until a user clicks it, or some other code function hides it.As you will see later, there is also a way to auto-start your animation using XML, so that you do not have to use any ID parameter, which is generally used to provide a way for Java 8 code to reference your XML tag construct. This approach allows you to avoid declaring, instantiating, and referencing the Java AnimationDrawable object!

#### <item>标签:如何添加图像动画帧</item>

The <animation-list> tag will always be the parent tag, because it is designed to contain <item> tags, which will always be the child tags. The item tag is used to define the frames in your <animation-list> tag, with one <item> tag for each animation frame. There are two parameters utilized inside of an <item> tag: the android:drawable file name referencing parameter; and the android:duration parameter, which specifies a frame display duration integer value, using milliseconds. A millisecond is one-thousandth of a second, so one second of frame duration would use the 1000 integer value. All these <item> tags exist inside of the parent <animation-list> container, in the order in which they are to be displayed. Essentially you are loading the animation frames into a data array in system memory, using an AnimationDrawable object that will control and play these frames to create motion.The math for calculating this duration value, which is ultimately going to represent the animation’s frame rate, which is usually specified in frames per second, or FPS, is the number of seconds you want the animation to last times 1000, divided by the number of frames that you have in your animation. So if you want the logo to rotate once every second, and you have 9 frames to create the smooth illusion of motion (40 degrees of rotation per frame), then 1 times 1000 divided by 9 gives you 111.111, so you would use an android:duration="111" parameter for each <item> tag. If you want a slower 2-second rotation, you would use a 222 value, a 3-second rotation would be 3000 divided by 9 or a value of 333, and so forth. Using XML markup will make it easier to experiment with these data values, until you get the exact animation motion you are looking for.Next, you will create the XML animation definition file with Android Studio, using a very similar work process to what you did in the previous chapter, in order to create the XML for the multi-state ImageButton UI element. After we create the logo_anim.xml file we will create the XML markup; transfer nine frames for the seamlessly looping 3D animated logo; add an ImageView widget to the content_main.xml definition to hold the animation; reference the logo_anim.xml in the content_main.xml definition; write the Java code to declare, instantiate, and wire up the ImageView and AnimationDrawable objects needed in memory to play back the animation; and test the animation in the Nexus 5 AVD emulator. We have a lot of XML and Java work to do, so let’s get started!

## 用 XML 和 Java 创建帧动画

Let’s go through the process of creating your AnimationDrawable XML definition file, coding image animation frames using XML, installing the image frames, coding the Java objects, and testing the image animation itself.

### 创建 XML 帧动画定义文件

In Android Studio, right-click the /app/res/drawable folder in your NavDrawerPattern app, and select the New ➤ XML ➤ Layout XML File menu sequence. Once Android Studio adds a New ➤ XML ➤ Drawable XML File option, you will use that, but for now, Android Studio is only auto-creating files for /res/layout and /res/value subfolders, so we will have to use what we have available to us. Figure [10-1](#Fig1) shows you the above-described work process. Frankly, Android Studio should also have a New ➤ XML ➤ Anim XML File for the /res/anim folder, as you’ll soon see when we create vector animation in the next section of this chapter on procedural (vector) animation.![A324674_4_En_10_Fig1_HTML.jpg](A324674_4_En_10_Fig1_HTML.jpg)Figure 10-1.Right-click your app/res/drawable folder, and select: New ➤ XML ➤ Layout XML File menu sequenceIn your New Android Component dialog, shown in Figure [10-2](#Fig2), configure your file name as logo_anim, and enter your animation-list parent tag (Root Tag), and then click the Finish button, and create this new XML file.![A324674_4_En_10_Fig2_HTML.jpg](A324674_4_En_10_Fig2_HTML.jpg)Figure 10-2.Use the New Android Component dialog to name file logo_anim, and set parent tag to animation-listSince there is no New ➤ XML ➤ Drawable XML File option (yet), we’ll have to remove the two android:layout parameters, shown encircled in red in the middle of Figure [10-3](#Fig3). Also shown on the left encircled in red is your /app/res/layout folder, which contains the logo_anim.xml file which needs to be moved to the app/res/drawable folder by using a cut and paste operation inside Android Studio. The first step in this operation is to right-click on the logo_anim.xml file and select the “Cut” menu option, which will remove (gray out) the file from layout.![A324674_4_En_10_Fig3_HTML.jpg](A324674_4_En_10_Fig3_HTML.jpg)Figure 10-3.To change XML to an animation list, remove the layout parameters, and cut and paste into drawableThe second step, seen in Figure [10-4](#Fig4), is to right-click on the /app/res/drawable folder, and select Paste from the context-sensitive menu options. This will bring up the Move dialog, where you specify the drawable folder.![A324674_4_En_10_Fig4_HTML.jpg](A324674_4_En_10_Fig4_HTML.jpg)Figure 10-4.Right-click on the drawable folder and select Paste and enter the drawable folder in the Move dialogNotice that where you locate the logo_anim.xml file doesn’t change anything regarding the open logo_anim.xml editing tab, which can be seen in Figures [10-3](#Fig3) and [10-4](#Fig4), as well as in [10-5](#Fig5) with the animation-list XML markup. Your frame animation XML definition markup will look like the following, once you remove the android:layout parameters, add an android:oneshot parameter, and add the nine child <item> tags specifying the image frames:![A324674_4_En_10_Fig5_HTML.jpg](A324674_4_En_10_Fig5_HTML.jpg)Figure 10-5.Create a logo_anim.xml frame animation definition using numbered files<?xml version="1.0" encoding="utf-8"?><animation-listxmlns:android="http://schemas.android.com/apk/res/android"android:oneshot="false" ><item android:drawable="@drawable/logoanim_0" android:duration="111" /><item android:drawable="@drawable/logoanim_1" android:duration="111" /><item android:drawable="@drawable/logoanim_2" android:duration="111" /><item android:drawable="@drawable/logoanim_3" android:duration="111" /><item android:drawable="@drawable/logoanim_4" android:duration="111" /><item android:drawable="@drawable/logoanim_5" android:duration="111" /><item android:drawable="@drawable/logoanim_6" android:duration="111" /><item android:drawable="@drawable/logoanim_7" android:duration="111" /><item android:drawable="@drawable/logoanim_8" android:duration="111" /></animation-list>Notice that the screenshot in Figure [10-5](#Fig5) shows the slower two-second spin rate, using the duration value of 222 milliseconds, while the XML markup above shows the faster one-second spin rate, using a duration value of 111 milliseconds.You can play around with this frame duration (frame rate) value to achieve the spin rate that gives you the most realism for the 3D logo animation. I like to get it to spin as slowly as I can, without detecting any jerkiness in the rotation motion.Also notice in Figure [10-5](#Fig5) that the @drawable/logoanim_n references to the PNG8 image animation frames are highlighted in red in Android Studio. This tells us that there is something that will cause an error, and we know what that is, since we have not installed the 240 by 160 pixel XHDPI resolution density assets in the appropriate /app/res/drawable-xhdpi folder, which we’ll be doing next, to get rid of these red error highlights in the markup.Copy the nine PNG8 animation frames (logoanim_0 through logoanim_8) from the book assets repository to the AndroidStudioProjects/NavDrawerPattern/app/src/main/res/drawable-xhdpi folder with an operating system file management utility. In my case, this was the Windows Explorer utility, as is shown in Figure [10-6](#Fig6).![A324674_4_En_10_Fig6_HTML.jpg](A324674_4_En_10_Fig6_HTML.jpg)Figure 10-6.Use the operating system’s file management utility to copy the image frames to /res/drawable-xhdpiIf you want to get some practice with that GIMP resolution density work process you learned in Chapter [9](09.html), you can down sample this XHDPI into HDPI 120 by 80 and MDPI 60 by 40 assets. The reason I am not doing this is because these are 8-bit (indexed) images, and it would be better to have Android 7.1.1 try and use these XHDPI 240 pixel images, if possible, and use the Android 7.1.1 OS down sampling algorithms to reduce the image pixels only if necessary. The 64-bit Android OS has improved the sampling algorithms considerably over the ones in 32-bit versions.Figure [10-7](#Fig7) shows the logoanim_n.png (xhdpi) files in the /app/res/drawable folder in the Project pane on the far left, and the error-free image animation frame definition markup on the right.![A324674_4_En_10_Fig7_HTML.jpg](A324674_4_En_10_Fig7_HTML.jpg)Figure 10-7.Once PNG files are in res/drawable-xhdpi, they will show up in the IDE and markup will be error freeThe next thing that you need to do is reference this animation definition file inside of the content_main.xml file. To do this you need to add an ImageView to hold the image animation, so click on the content_main.xml tab in the Android Studio IDE and click the Design (Editor) tab at the bottom left and drag an ImageView element out of the Images & Media subpalette into the center of the UI design as shown in Figure [10-8](#Fig8). Enter a background (plate) reference to @drawable/logo_anim to wire the ImageView to the AnimationDrawable definition, and add a contentDescription parameter data value of Logo Animation to provide aural feedback for the impaired, and leave the default imageView2 ID, as can be seen in the Properties panel on the far-right side of Figure [10-8](#Fig8).![A324674_4_En_10_Fig8_HTML.jpg](A324674_4_En_10_Fig8_HTML.jpg)Figure 10-8.Test UI design in Galaxy Nexus AVD (left), and add a 38 DIP left margin parameter to center (right)Let’s also click on the TextView in the Design Editor and enter “3D Logo Animation” to replace Hello World and add “Logo Animation” to the contentDescription data field for the disabled (impaired). The final XML, as shown in Figure [10-9](#Fig9), for your new ImageView UI widget child tag markup should look like the following:![A324674_4_En_10_Fig9_HTML.jpg](A324674_4_En_10_Fig9_HTML.jpg)Figure 10-9.Click the XML Text tab and view the XML tags and parameters generated by the XML Design Editor<ImageViewandroid:layout_width="wrap_content"android:layout_height="wrap_content"android:background="@drawable/logo_anim"android:id="@+id/imageView2"android:layout_centerVertical="true"android:layout_centerHorizontal="true"android:adjustViewBounds="true"android:contentDescription="Logo Animation" />Notice in Figure [10-9](#Fig9) that Android Studio highlights your new parameters that it added using the Visual Design Editor (seen in Figure [10-8](#Fig8)), as well as key parameters which reference assets or assist the impaired or disabled users. We will be tweaking these parameters as we continue to create our animated content_main UI definition, over the course of this chapter covering the different types of animation available to Android 7 developers.I also drew a red arc showing the connection between /src/drawable/logo_anim.xml and the android:background parameter. This parameter references a logo_anim.xml AnimationDrawable image frame asset XML definition.Now that you have created an XML definition for an AnimationDrawable object and updated content_main.xml to reference this image animation’s frame sequence in the background plate of an ImageView, let’s go into your Java code using the MainActivity.java tab, so that you can declare, construct, instantiate, and inflate the objects that will be needed to hold these object definitions in system memory so they can be processed. In this case, processing involves blitting (animating) image frames at your specified millisecond intervals, to create motion.

### 创建 ImageView 和 AnimationDrawable 对象

Now we have to use Java to create (instantiate) objects in memory to hold your ImageView receptacle, and your AnimationDrawable frame animation engine. As you’ve seen before, an object can be declared, instantiated, and inflated using a single Java statement. For an ImageView object, this looks like the following Java statement:ImageView imageView2 = (ImageView) findViewById( R.id.imageView2 );Type in ImageView, which will display in red, as there is no import statement yet. Mouse-over this error, until the android.widget.ImageView? (import) pop-up appears and then use Alt+Enter to have Android Studio write an import statement for you. Name the ImageView imageView2 and use an equal operator to use an ImageView findViewById(R.id.imageView2) method to inflate the ImageView using the parameters defined in the XML. Note that if you type R.id. in the findViewById() method parameter area, Android Studio will provide you with a list of all of the android:id parameters you have defined across all of your XML object definition files, as you can see in the bottom-middle portion of Figure [10-10](#Fig10). Select, and double-click on, imageView2 to insert it.![A324674_4_En_10_Fig10_HTML.jpg](A324674_4_En_10_Fig10_HTML.jpg)Figure 10-10.Declare and instantiate an ImageView object named imageView2, and inflate it using findViewByIdThe next thing we have to do is to create (instantiate) an AnimationDrawable object in system memory that will hold your image animation frames, as well as the AnimationDrawable frame animation engine. As we did with the ImageView object, we will declare, instantiate and inflate the AnimationDrawable object using a single Java statement. For the AnimationDrawable object, this should look like the following Java programming statement:AnimationDrawable imageAnimation = (AnimationDrawable) imageView2.getBackground();To inflate your AnimationDrawable object, as well as wiring it up to your ImageView object, you call the .getBackground() method off the imageView2 ImageView object, which loads the logo_anim.xml image frames definition that’s referenced by using android:background="@drawable/logo_anim"" in the content_main.xml.This AnimationDrawable object preparation can be seen highlighted in pale yellow in Figure [10-11](#Fig11), along with a second Java statement, which starts the image animation frames sequence displaying at around 5 FPS (222ms) using a .start() method call off the imageAnimation AnimationDrawable object, or: imageAnimation.start().![A324674_4_En_10_Fig11_HTML.jpg](A324674_4_En_10_Fig11_HTML.jpg)Figure 10-11.Add the AnimationDrawable object instantiation, and start image animation using a .start( ) methodUse the Run feature (or Clean and Run) to test the image animation in the AVD. As you’ll see in Figure [10-12](#Fig12) the animation is running, due to the android:oneshot="false" parameter, and the UI elements still work well.![A324674_4_En_10_Fig12_HTML.jpg](A324674_4_En_10_Fig12_HTML.jpg)Figure 10-12.Test your image animation, multistate button, and menu systemNext, let’s take a look at how to set up the other type of animation, vector or procedural animation, in Android.

## Android 补间动画:矢量概念

The patron saint of 2D animation, Walt Disney, is also responsible for the animation term tween since cels were “tweened,” which is short for “in-betweened,” by his apprentice animators. Senior animators would create the primary key movement frames called key frames and the junior animators would then create the tweens.Tweening is now done algorithmically for you by the Android OS, using something that’s called interpolation. Interpolation algorithms are provided by the Android Animation class, which we will be learning all about after we get up-to-speed on all of our tween animation (or vector or procedural animation) concepts and terminology. One of the cool things that was added in 64-bit Android (5.0 and later) were additional interpolation algorithms.The procedural animation attributes are types of vector attributes that can be interpolated, or more accurately, which can be transformed by using mathematical interpolation, which you learned about in high school. They include alpha (transparency), which you’ve already learned about to some extent; as well as translation, which is the 2D industry term for movement, scale, which is the industry term for size; and finally, rotation, which is the industry term describing which direction something is facing.Each of these concepts (rotate, scale, translate, and alpha) has an XML tag and class in Android, so let’s cover these new vector animation concepts next. In case you might be wondering, a vector is a ray that is traced out in two or three dimensions, starting at one point and shooting out through another point (a line, basically). Vector graphics allow us to define shapes algorithmically, rather than using arrays of pixels (bitmaps). If you want to dive into SVG and vector graphics in depth, see the popular Digital Illustration Fundamentals (Apress, 2015) title.

### 程序概念:旋转、缩放、平移

Let’s start out by learning about some of the concepts involved in vector imaging and vector animation. First of all, there are two primary types of vector platforms: 2D (two-dimensional, flat) vector graphics, like we find in Illustrator or Inkscape; and 3D (three-dimensional, volumetric) vector graphics, like we find in 3D modeling software such as NewTek Lightwave, open source Blender, or Autodesk 3D Studio MAX. Concepts that we cover in this section of the chapter apply to both 2D and 3D imagery and animation; however, we will be only covering the basic 2D vector animation implementations for this Absolute Beginners title.The 2D vector that uses x and y coordinates is used in 2D, and 3D vectors, which use x, y, and z coordinates, are used in 3D. Both 2D and 3D animation involve core concepts of translation (movement), rotation (direction), and scale (size). There is a z concept in 2D animation, but it is not a z-axis, but rather a z-order. Z-order in 2D is akin to layers in digital imaging as we’ve already discussed earlier during the book. Z-order involves what layer order each 2D (flat) layer is in, and whether it is front of, or behind, other 2D layers, making z-order the number that orders the layers in a 2D composite. This z-order number defines what is in front of, and what is behind, any given 2D layer. Changing this z-order numeric value in real time using your Java programming logic can create flip-book types of special effects, and is a technique often utilized in 2D game programming.Translation in 2D involves movement along an x or y axis and is the most basic of the three transformations you can achieve in 2D animation. Translation is defined by a starting point for a movement; an amount or distance for that movement in pixels or percentages; and a direction of movement, along either an x or y axis (horizontal or vertical movement), or along some relative combination of both x and y axis values (diagonal movement).Rotation in 2D involves rotation around any given x,y pivot point coordinate. The amount of rotation is defined using degrees, direction (positive/clockwise, or negative/counter-clockwise) of the rotation, and the pivot point (center) location of the rotation. Since there are 360 degrees in a full circle, rotational mathematics involves this 360 number specifically, like FPS calculations involve the number 1000 (number of milliseconds in a second).Scale in 2D involves a size for a given shape, and is defined by a decimal number relative to the current size of the shape. For instance, a 0.5 scale would be half of the current size, or 50%, and a 2.0 scale, or 200%, would be twice the current size of that shape. Like translation, scaling has an x and a y component. If the values are the same, this scaling can be said to be uniform scaling; if they’re not the same, the scaling would be said to be non-uniform scaling.To draw a parallel to something that you have learned about previously, uniform scaling maintains aspect ratio, and non-uniform scaling skews or distorts (that is, changes) the aspect ratio. Therefore, non-uniform scaling is most often used for animation special effects, such as making a ball squash when it bounces off the ground.Interestingly, you can also define a pivot point for your scaling operation, which allows skewed scaling, where the placement of the pivot point can influence your scaling operation. For irregular shapes, this can give a more precise level of scaling control over a resulting shape-warping special effect for a scaling operation. Given that sometimes the 2D shapes being scaled contain bitmap images (patterns and textures), you can obtain some very interesting results using a pivot point placement that is not at the exact center point of the vector shape being scaled. The industry term for putting digital imagery in a 2D shape or on a 3D object is called texture mapping.

### 程序数据值:范围和轴心点

In order to be able to interpolate, we need to specify more than one single numeric value, because interpolation (tweening) involves creating new interim values between starting and ending values. So, information learned in the previous sections (interpolation) will be applied to information found in this section (ranges), and then in the next section we’ll cover alpha blending and more complex procedural animation parameters that are available to control animation start time offsets, loop type characteristics, and how many times your animation will loop.To have any procedural animation, you will always need to specify a range using a starting value, called a From value, and an ending value called a To value.Like a value range, a pivot point will also require two values to establish. However, unlike a value range, which utilizes a From and To value, a pivot point uses a two- dimensional location on your display screen, and uses the x and y coordinates, just like pixels do, to define where the pivot point is to be placed within that 2D plane” A plane in 2D is like a sheet of paper, or like a layer in compositing, and is an “infinitely flat” with only 2D (x and y dimensions) surface (no volume). By infinitely flat, I mean that there is no z dimension (depth) to a 2D plane.Pivot points are also used extensively in 3D animation, where setting the pivot point requires three (x, y, and z) data coordinates in order to be properly specified in 3D space. In this book, we are only covering 2D, as that is the best starting point to use for Absolute Beginners. As you get more advanced you can add 3D to your repertoire. Let’s take a look at a fourth type of procedural transform, alpha blending; then we will look at advanced parameters.

### 程序动画合成:Alpha 值

There is one other attribute that can be animated procedurally in Android, but it is not a transformation. Alpha blending is much more akin to a compositing feature; in fact, it is a crucial part of compositing. If you transform an object, the object changes physically in some way, moving it to a different location (translation), changing its size (scaling), or what direction it is facing or how it is oriented (rotated).Alpha blending an object with its background to create procedural animation is done by specifying a change in the object alpha (transparency) value, with zero being transparent and one being opaque. This is usually termed as a fade-in or a fade- out in the content production industry, and technically is image compositing. In Android, alpha blending is included with a procedural animation toolset, because alpha values are logical attributes to animate, especially if you are creating an animated children’s ghost story, or a sci-fi transporter beam special effect, or something similar.You can finely control the Alpha attribute of an object you are animating procedurally by using alpha parameter with floating-point values, and you can use an AnimationSet class to seamlessly combine alpha (transparency) blending with movement, scale, or rotation transformations.Like most of the other procedural animation attributes, alpha blending amounts are specified using real (floating-point, or float) numbers, between 0.0 (transparent) and 1.0 (visible). The exception to this is pivot points, which you specify using a percentage, such as 50%; and degrees, which you specify using degrees in decimal numbers (also called real, floating point, or float) using values between 0.0 and 360 degrees.It is important to note that using more than one decimal place (precision position) is allowed when using real or float values. Thus if you wanted your object to be precisely one-third visible, you would use 0.3333 or, for three-quarters visible, you could simply specify 0.75 as the starting or ending value for your object’s alpha value.You’ll set alpha starting and ending values by using the fromAlpha and the toAlpha parameters. So, to fade-out any object, you would set fromAlpha to 1.0, and toAlpha to 0.0, in order to achieve that fade-out special effect.To combine multiple different types of procedural animation parameters together, you should create a set for the animation transformation parameters. Using a procedural animation set will allow you to group transforms and compositing together in a logical and organized fashion. This enables us to create very complex procedural animation.We’ll be covering how to create procedural animation sets using the Android AnimationSet class (and object) in detail a bit later on during the chapter. First, let’s take a look at procedural animation timing and looping values.

### 程序计时:使用持续时间和偏移

You might be wondering how you set the timing that is used between all of these different range data values. You actually have done this already for your frame animation using the android:duration parameter, which sets the duration for displaying one single frame. In procedural animation, duration sets the timing value for the entire range, and will also to some extent define how many interpolated data values are created by the Android OS during that range duration, as well as the duration of each of the segments between each interpolated value.It is important to remember that the Android Animation classes decide this value based on the device processing power, and what those algorithms (the procedural animation “engine”) calculates will provide the most optimal, that is, the smoothest, visual results, given the current processing power to applications in use ratio, or trade-off.The duration for any given procedural animation range is set using the duration parameter, which, like it does in frame animation, also takes an integer value in milliseconds. It’s interesting to note that programming languages such as Java, JavaFX, and JavaScript will utilize these millisecond values for all of their timing functions and operations.It is also important to point out here that 64-bit Android OSes (5, 6, and 7) can provide even finer timing granularity, by using nanoseconds, or “nanos,” which allow a billion time slices per second, instead of a thousand! That being said, you can still also use milliseconds, which are more reasonable to use for both image and vector animation. This capability was primarily added to support high frame rate (60 FPS) i3D game development, so that things could be synchronized with seamless perceptual precision to the game player.If you wanted the fade-out we discussed in the previous section to take four seconds, the XML parameter would be android:duration="4000" since 4000 milliseconds equals 4 seconds. If you wanted alpha fade-outs to take (or “span”) 4.352 seconds, you would use a millisecond value of 4352, and thus you have a one-thousandth of a second “granularity,” which is the level of precision, available for your procedural animation timing accuracy.Each transformation (or alpha blend) range that you define has its own separate duration settings, allowing for a great deal of precision in the XML markup definition of the composite procedural animation special effect that you are trying to achieve.There is one other important timing-related parameter, which allows you to delay when the specified range will start playback. This is called an animation offset, and it is controlled using the startOffset parameter data value.Say that you wanted to delay the start of your four second fade-out by four seconds. All that you would have to do is to add the android:startOffset="4000" to your <alpha> parent tag, which we will be using for real, a bit later on during this chapter, and this four-second timing delay control would then be implemented.The startOffset parameter is especially useful when utilized in conjunction with animation loops, which we are going to be covering next. The reason for this is that when used with looping animation scenarios, a startOffset parameter will allow you to define a pause during animated element loop cycles.Let’s take a look at loops next along with different parameters, which are also called attributes or characteristics, for controlling looping procedural animation. As you’ll soon see, the definitions for these procedural animation composites can become quite complex, using AnimationSet objects and deeply nested XML constructs.

### 过程循环:RepeatCount 和 RepeatMode

Like frame animation, procedural animation can play once, and then stop, or can play continuously in a loop, either forever (an infinite loop, which is acceptable for animation) or for a specified (integer) number of times.There are two parameters that control looping, one which controls whether the animation will loop or not, and another which controls the direction in which the animation will loop back and forth. The procedural animation parameter that controls the number of times an animation, or component part of an animation set, will loop is called the repeatCount parameter. This parameter will require a whole number (integer) data value.If you leave this repeatCount parameter out of (that is, unspecified in) the procedural animation definition, then an animation will play once and then stop. This means the default setting is android:repeatCount="1" for this parameter. The exception to using an integer value for this parameter is an infinite constant. If you want to have an animation loop forever, you would want to use an android:repeatCount="infinite" parameter setting.In case you’re wondering, the value that the constant infinite defines is -1, so an android:repeatCount="-1" parameter definition works just as well. The parameter that defines what style of looping is used is the repeatMode parameter, which you can set to one of two predefined constants. The most common of these two is restart, which will cause an animation to loop seamlessly, unless you’ve defined the startOffset parameter. In case you’re wondering, the value that a restart constant defines is 1, so android:repeatMode="1" works too.The other repeatMode of animation looping is the reverse mode, which is also called pong animation, as it causes the animation to reverse at the end of its range, and run backward, until it reaches the beginning again, at which time it will run forward. Back and forth, ad infinitum, like the video game Pong! In case you’re wondering, the value that a reverse constant defines is 2, so android:repeatMode="2" will also work.These parameters may seem simple on their own, but when combined in structures using an AnimationSet class, which we’ll take a look at later, or by nesting parent and child tags, these parameters can quickly become quite complicated in combination with each other. Don’t underestimate the power of these parameters when they are put together by a savvy developer, in the right XML structure. Next, let’s take a look at the Android Animation class and its subclasses that implement tween animation, and then implement procedural animation using XML.

## Android 动画类:补间动画

The Animation class is used to create tween animations of View objects in Android. This is via the interpolation of data values, within constructs of predefined transform types. This will create frames of procedural animation, with Android deciding how many frames are needed to create a smooth animation result. The Animation class is part of the android.view package, and is kept with the other Animation classes, subclasses, and methods, using the android.view.animation package. This is quite different from the image (bitmap or raster) frame animation type, which uses the ImageView and AnimationDrawable objects, and the frame animation engine is kept in the android.graphics.drawable package. This is centered around graphic design and drawables rather than View UI.The Animation class hierarchy starts with the java.lang.Object master object, which is then subclassed, to create the Animation class. The Java class hierarchy for the Animation class would therefore look like the following:java.lang.Object> android.view.animation.AnimationIt is interesting to note that any class that is subclassed from java.lang.Object is essentially “scratch coded” in the sense that the class is created from nothing, other than the Object infrastructure, so, in this case, the Android Animation engine was created using only the procedural animation objectives of Android’s development team.The Animation class was then used to create the subclasses, which are actually used via the XML tags, which we will learn how to implement a bit later on during this chapter. There is one subclass for each of the four types of tween animation you learned about in the previous section, including the AlphaAnimation, RotateAnimation, ScaleAnimation, and TranslateAnimation classes. There is also the AnimationSet class, which can be used to create groupings of more complicated tween animation transforms, called, you guessed it: animation sets.Since we have already covered all of the XML parameters that can be used with the Android Animation class, and therefore with any of its subclasses, in previous sections of this chapter, let’s jump right into some hands-on XML markup, and create your /res/anim folder, and procedural animation assets to put inside of that folder that takes a View widget, and applies some procedural animation transforms to it to vector animate it, so that you’ll start to learn about how to create tween animation in Android.After you create the tween animation we’ll create a hybrid animation using both the frame (AnimationDrawable class) and tween (Animation class) animation engines together, for the ultimate in Android animation power!

## 使用 XML 标记创建补间动画

The simplest way to create one of these tween animation assets is to define your procedural animation using an XML file. This will be stored in the NavDrawerPattern project /res/anim folder. We’ll create this folder before we create an Animation object XML definition that will live inside of that folder. The work process is similar to what you did previously to create a /res/drawable folder and your AnimationDrawable XML asset definition.Since we’re creating three different types of animation during this chapter (raster, vector, and hybrid) using both an AnimationDrawable object and an Animation object, we will create our second logo animation by scaling the AnimationDrawable object to give that animation the appearance that it is coming in out of the distance.This will show you how to combine vector and raster animation in Android to create more advanced animation effects, which will show you how to create what I call “hybrid” animation in Android. After that, I’ll show you how to use tween animation to create more advanced vector animation effects that can be used on UI widgets.After you create a /res/anim folder and XML file containing procedural animation parameters, we will get back into Java coding and wire up the ImageView UI element to the vector animation so I can show you how to set up and trigger both frame animation and tween animation at the same time. After that we’ll look at how to combine rotate and translate transforms along with the scale transform using the AnimationSet parent container. By the end of this chapter, you will have a nice overview of the Android bitmap and vector animation engine classes.

### 创建/anim 文件夹:补间动画资源

Right-click on the NavDrawerPattern project app/res folder, and select the New ➤ Directory menu sequence, as shown in Figure [10-13](#Fig13). In the New Directory dialog name the folder anim and click the OK button to create the new folder. This adds a sixth type of Android asset (procedural, vector, or tween animation), a motion graphics asset, to your hierarchy, which already includes static graphic assets (/res/drawable), UI design assets (/res/layout), menu design assets (/res/menu), application icons (/res/mipmap), and constant values (/res/values).![A324674_4_En_10_Fig13_HTML.jpg](A324674_4_En_10_Fig13_HTML.jpg)Figure 10-13.Right-click on the project app/res folder, and create an app/res/anim folder under the app/res folderOnce you have a /res/anim folder in place, seen in Figure [10-14](#Fig14) on the left, right-click on that folder and select the New ➤ Animation resource file menu sequence, to open the New Resource File dialog shown on the right side of Figure [10-14](#Fig14). Since you right-clicked on the /res/anim folder, Android Studio will automatically set the Directory Name field to anim. All you need to do is to name this file tween_anim , and leave the other default settings as they are. Once you click OK, Android Studio will open your empty bootstrap tween_anim.xml file.![A324674_4_En_10_Fig14_HTML.jpg](A324674_4_En_10_Fig14_HTML.jpg)Figure 10-14.Right-click on anim folder and use New ➤ Animation resource file to name the XML file tween_animSince we talked about the primary parameters earlier in the chapter, we will get down to business, and configure the scale transform so we can bring our rotating logo in out of distance to increase the animation realism.

### Android ScaleAnimation 类:动画缩放

The Android public class named ScaleAnimation extends the Animation primary procedural animation engine class and focuses on scaling animation, which changes the size of the object that you want to animate. The class hierarchy for the Android ScaleAnimation class looks like the following:java.lang.Object> android.view.animation.Animation> android.view.animation.ScaleAnimationThe ScaleAnimation object constructed using this class, and generally specified using a <scale> tag, in an XML definition file, creates animation that will animate, or more accurately, interpolate, the scale of an object. You can specify the point to use for the center of this scaling operation using a pivotX and pivotY parameters, along with a percentage, in our case this will be the exact center of the object, or pivotX=50% and pivotY=50%. Let’s get right into creating the XML markup for this scale operation, inside of the tween_anim.xml you just created.

### 比例变换:配置参数

Let’s go through the process of having Android Studio help us code a child <scale> animation construct, inside of the AnimationSet <set> parent tag. Inside of the parent <set> tag type a < left-facing chevron and select and double-click on the scale vector animation child tag, as shown in Figure [10-15](#Fig15). Notice that when you resize the IDEA window that there is a control on the right to access the open tabs, four in this case, that you cannot see, using a drop-down (arrow) menu with the number of “overflow” tabs that are contained within the drop-down.![A324674_4_En_10_Fig15_HTML.jpg](A324674_4_En_10_Fig15_HTML.jpg)Figure 10-15.Type a left-facing chevron inside of your parent <set> tag, and double-click on the scale animationTo add parameters, type a space after the <scale tag and select one of the six available parameters for this tag, in our case, this would be android:pivotX, and then double-click on it, and insert it, as can be seen in Figure [10-16](#Fig16).![A324674_4_En_10_Fig16_HTML.jpg](A324674_4_En_10_Fig16_HTML.jpg)Figure 10-16.After the <scale opening tag, type a space and select and double-click on android:pivotX to insert itNow that you have defined your perfectly centered pivot point by using the android:pivotX and android:pivotY configuration parameters using a 50% value, you’ll need to reference the starting scale range in both the X and Y dimension using the fromXScale and fromYScaled configuration parameters. Add a line of markup after the pivot parameters, and then type an “a” to bring up a helper drop-down, and select and double-click on the fromXScale parameter, as can be seen selected in yellow and blue in Figure [10-17](#Fig17). Set your fromScale data values for both the X and Y dimensions to zero using the “0.0” floating-point number. Now all you have to set is the toScale X and Y range.![A324674_4_En_10_Fig17_HTML.jpg](A324674_4_En_10_Fig17_HTML.jpg)Figure 10-17.After the pivot parameter, type an “a” and select and double-click on android:fromXScale to insert itAdd another line of markup, after your fromScale parameters, and then type an “a” to bring up the helper drop-down. Select and double-click on the toXScale parameter, and specify a 100% full scale, using a “1.0” floating-point number. Notice that for this parameter, the 0.0 equates to 0% and the 1.0 equates to 100%.Then hit a space (spacebar) character, and select and double-click on the toYScale parameter, as can be seen selected in yellow and blue in Figure [10-18](#Fig18). Also notice in Figures [10-17](#Fig17) and [10-18](#Fig18) that Android Studio has put a yellow warning header on the top of the XML markup editing pane that advises you that the markup is indented with 7 spaces, instead of using the standard 4 spaces. This is because I wanted to show all of the code and the pop-up helper drop-downs unhindered by one another, and so I had to space the markup out a bit more!![A324674_4_En_10_Fig18_HTML.jpg](A324674_4_En_10_Fig18_HTML.jpg)Figure 10-18.After the fromScale parameters type an “a,” select and double-click on android:toYScale to insert itAfter I was done with the screenshots, I selected the “Indent with 4 spaces” link (option). The number of spaces you use to indent your code for readability purposes will not affect the efficacy or execution of that code, either in Java or in XML editing for your Android applications, so do whatever you feel the most comfortable with!The XML markup for the six initial transform definition parameters are shown in Figure [10-18](#Fig18), and should look like the following child <scale> tag (and its scaling parameters, attributes, or characteristics) XML markup:<scale xmlns:android="http://schemas.android.com/apk/res/android"android:pivotX="50%" android:pivotY="50%"android:fromXScale="0.0" android:fromYScale="0.0"android:toXScale="1.0" android:toYScale="1.0" />Next, let’s learn a bit more about the parent <set> AnimationSet class, and then add more parameters to the AnimationSet, so that we can specify and control the vector animation duration, loop type, offset, and more.

### Android AnimationSet 类:转换分组

The Android public class named AnimationSet extends the Animation primary procedural animation engine class and focuses on grouping animation, which allows you to apply group hierarchies to procedural animation to allow more complex animation by combining the four types of procedural animation (scale, rotate, move, alpha). The class hierarchy for the Android AnimationSet class looks like the following:java.lang.Object> android.view.animation.Animation> android.view.animation.AnimationSetThe AnimationSet object is constructed using this class, and generally specified using a <set> tag, in an XML definition file, creates animation hierarchies that will contain constructs of the four vector animation types as well as other AnimationSet constructs, allowing you to deeply nest the different types of procedural animation relative to each other to create any desired animation result imaginable. Let’s get right into creating the XML markup for this AnimationSet operation, which forms the foundation of the tween_anim.xml you have created.To the Animation class the AnimationSet is used to construct a group of Animation subclasses that are designed to be played together, either serially, or in parallel, or in more complex animation constructs, both. Visually, the transformation of each individual animation will be composed together into one single more complex transformation.If an AnimationSet parent grouping specifies any properties (parameters) that its children also specify, for example, duration, the values of the parent AnimationSet will override the same values set in the children (tags). The way AnimationSet inherits behavior from the Animation engine is different based upon each parameter. Some of the Animation parameters applied to AnimationSet affect the AnimationSet as a whole, while others will be “pushed down” into its children, while others will be completely ignored.The duration, repeatMode, fillBefore or fillAfter properties, when specified for an AnimationSet object, will be pushed down to all of its children animation transformation types. The fillBefore and fillAfter parameters control whether the initial value of the animation is applied before its start time (fillBefore) and whether the animation’s ending values persists after it has transformed (fillAfter). These are for more advanced applications, and therefore will not be delved into in this book, but you are welcome to dive into them on the developer site.The repeatCount and fillEnabled, which switches on or off the fillBefore and fillAfter parameters, will be completely ignored if specified for the parent AnimationSet, as they are inherently used at the transform level. The startOffset or shareInterpolator parameters on the other hand only apply to an AnimationSet as a whole. The shareInterpolator tells children of an AnimationSet whether to share (if set to “true’) the AnimationSet Interpolator parameter, or if AnimationSet defines shareInterpolator="false", to put different Interpolator values into each of the child transforms, to achieve a far more advanced vector animation effect. Let’s get right into it!

### 动画集容器:组和子组

Let’s go into the tween_anim.xml tab and add some of the commonly used parameters into the parent <set> tag. If you add a space before the end (right-facing) chevron of the AnimationSet parent <set> tag, you will get the drop-down helper selector where you can select and double-click on the android:duration parameter to add it, as is shown in Figure [10-19](#Fig19). Set duration to 5000 milliseconds to make the animating logo come into view slowly.![A324674_4_En_10_Fig19_HTML.jpg](A324674_4_En_10_Fig19_HTML.jpg)Figure 10-19.Add a space before the closing ➤ chevron of the parent <set> tag, and select a duration parameterNext, add the repeatMode parameter set to "reverse" and the sharedInterpolator parameter set to "true" so that all of the transforms we will be adding later use the default LinearInterpolator. Add a small 100 millisecond startOffset so that the animation takes a little while to appear in the distance to add more realism. These parameters are shown inside of the parent <set> tag in the middle of Figure [10-20](#Fig20), and configure the animation.![A324674_4_En_10_Fig20_HTML.jpg](A324674_4_En_10_Fig20_HTML.jpg)Figure 10-20.Add repeatMode, startOffset and ShareInterpolator parameters to your parent AnimationSet <set>Since your <ImageView> UI element already has an ID value in your XML markup and has been instantiated in the Java code, all you have to add is the Java code in your MainActivity.java file that will wire the tween animation to the ImageView in order to scale it into view (out of the distance), to create this hybrid animation, which is frame animating the background image assets, and vector animating your ImageView container itself!

### Java 代码:将两种动画类型结合在一起

Since you are going to use the ImageView object inside of your event handler for the FloatingActionButton, to trigger the logo animation to emerge from the distance (scale), let’s declare your ImageView object at the top of your MainActivity class, as is seen highlighted in yellow in Figure [10-21](#Fig21). Also declare an Animation object and name it tweenAnimation, as we will be instantiating that next, underneath your AnimationDrawable Java code.![A324674_4_En_10_Fig21_HTML.jpg](A324674_4_En_10_Fig21_HTML.jpg)Figure 10-21.Declare an ImageView object named imageView2, and Animation object named tweenAnimationMake sure to remove the ImageView from the beginning of your ImageView findViewById object instantiation statement (after the two NavigationView statements), or you’ll get a red wavy error highlight in Android Studio.Next, instantiate the tweenAnimation Animation object after the imageAnimation.start() method call, as seen in Figure [10-22](#Fig22), so that Android will instantiate this object when your application’s MainActivity starts. Reference your tween_anim.xml XML definition using a .loadAnimation() method called on the AnimationUtils class, as shown highlighted in yellow in Figure [10-22](#Fig22). The AnimationUtils class defines common utilities for working with vector (procedural) animation, such as loading Animation objects, loading Interpolator objects, and polling these objects so you can ascertain their current time (progress into the animation’s duration) using milliseconds.![A324674_4_En_10_Fig22_HTML.jpg](A324674_4_En_10_Fig22_HTML.jpg)Figure 10-22.Instantiate the animImageView inside of the onCreate() method using the findViewById( ) methodThe next thing that you will need to do is to wire the Animation object to the ImageView object. This is done by calling the .startAnimation() method off of the imageView2 object and passing the tweenAnimation object over in the parameter area of the method call, like this:imageView2.startAnimation(tweenAnimation);We will do this inside of the OnClickListener() event handling code for your FloatingActionButton, instead of posting a text message about inserting your own code. As you can see, highlighted in Figure [10-23](#Fig23), this makes your event handling routine simpler, and gives you control over triggering the vector animation, so you can test your code.![A324674_4_En_10_Fig23_HTML.jpg](A324674_4_En_10_Fig23_HTML.jpg)Figure 10-23.Declare an Animation object and name it tweenAnimation at the top of your MainActivity.java fileSpeaking of testing the Animation code, let’s do that now using the Run ➤ Run ‘app’ or Run ➤ Clean and Rerun ‘app’ menu sequences. When you click the FloatingActionButton, which we have “borrowed” here to control the test of our vector animation, and to keep it separate from our raster (AnimationDrawable) animation, the animating logo comes in from the distance, as can be as seen in the left-hand AVD emulator preview seen in Figure [10-24](#Fig24).![A324674_4_En_10_Fig24_HTML.jpg](A324674_4_En_10_Fig24_HTML.jpg)Figure 10-24.Test the vector animation by clicking on the the FloatingActionButtonFinally, we need to look at Animation interpolator constants, so that you can create complex motion curves for your image (raster) or tween (vector) animation constructs. In this case, we are building a hybrid animation that uses both the Animation (engine) classes and the AnimationDrawable (engine) class together for special effects.

## 复杂动画:Android 插值器

Let’s get more complex and add some motion curves, called Interpolator constants in Android, to enhance the realism of the way that the animated objects (we will be animating the TextView as well) fade-in and scale up. This will allow me to show you how shareInterpolator works and teach you about Android’s Interpolator engine and how to incorporate two different types of motion curves in the complex Animation transform subgroupings.

### 使用 XML 标记创建复杂的动画

Let’s add a second <alpha> (transparency) transform child tag to the parent <set> tag, since the primary purpose of an AnimationSet is to group transforms together, to make them run as one seamless transform. It is important to note that you can use one transform inside of a <set> without any issues or errors, as you have just seen in the previous section. Add a carriage return (a new line of markup or newline character) and type in <alpha to open an <alpha> tag and hit the spacebar to bring up the pop-up helper and select and double-click on the fromAlpha parameter to insert it in your code, which is shown in Figure [10-25](#Fig25) highlighted in blue.![A324674_4_En_10_Fig25_HTML.jpg](A324674_4_En_10_Fig25_HTML.jpg)Figure 10-25.Add an <alpha opening tag, and hit the spacebar to bring up the parameter pop-up helper selectorSet fromAlpha to a data value of 0.0, or 0% opacity. Repeat this work process and add your toAlpha parameter, and set it to a data value of 1.0 or 100% opacity, as shown in Figure [10-26](#Fig26). The resulting <alpha> tag and parameters should look like this:![A324674_4_En_10_Fig26_HTML.jpg](A324674_4_En_10_Fig26_HTML.jpg)Figure 10-26.Add a toAlpha parameter set to a data value of 1.0, and add a closing tag to the alpha child object<set android:parameters are in here ><scale android:parameters are in here /><alpha android:fromAlpha="0.0" android:toAlpha="1.0" /></set>Next, let’s add another level of complexity to a compound (multiple transforms) vector animation definition, by adding motion control curves. A motion control curve is a mathematical or algorithmic definition regarding how the animation frame rate should be transformed in real time, changing how the vector transform will be applied over time. This is done by using an Android Interpolator interface, which is part of the view.animation package.

### Android 插值器接口:运动曲线

The Android public Interpolator interface implements the Android public TimeInterpolator interface, which defines the rate of change over time for an animation. This allows animations to have nonlinear motion, such as acceleration and deceleration, for instance. The Interpolator interface therefore also defines your rate of change for Android procedural animation. This will allow the four basic animation effects (alpha, scale, translate or move, and rotate) to be accelerated, decelerated, cycled, bounced, anticipated, overshot, or made to follow a predefined vector path.The Interpolator interface is kept in the android.view.animation package, and has fourteen known indirect subclasses, including: AccelerateDecelerateInterpolator, AccelerateInterpolator, AnticipateInterpolator, AnticipateOvershootInterpolator, BaseInterpolator, BounceInterpolator, CycleInterpolator, PathInterpolator, DecelerateInterpolator, FastOutLinearInInterpolator, FastOutSlowInInterpolator, LinearInterpolator, LinearOutSlowInInterpolator and OvershootInterpolator.Next, inside your parent <set> tag, type a space after your <scale> child tag’s android:toYScale parameter, and type android:interpolator="@android:anim" This will bring up a pop-up helper containing the Interpolator constants, which is seen in Figure [10-27](#Fig27). The XML markup for the <scale> tag should look like the following:![A324674_4_En_10_Fig27_HTML.jpg](A324674_4_En_10_Fig27_HTML.jpg)Figure 10-27.Add an android:interpolator parameter, set it to @android:anim, and select /overshoot_interpolator<set android:parameters are in here ><scale android:pivotX="50%" android:pivotX="50%" android:fromXScale="0.0" android:toXScale="1.0"android:fromYScale="0.0" android:toYScale="1.0"android:interpolator="@android:anim/overshoot_interpolator" /><alpha android:fromAlpha="0.0" android:toAlpha="1.0" /></set>Let’s follow the same work process, and add a different motion curve interpolator to your <alpha> child tag, to create a more complex animation. Since we are using more than one Interpolator constant, the first thing that we will need to do is to set android:shareInterpolator="false" in the parent <set> AnimationSet tag as shown in red in Figure [10-28](#Fig28). Next, add a space after the android:toAlpha parameter in the <alpha> child tag, and then, add an android:interpolator="@android:anim/accelerate_decelerate_interpolator" parameter, seen in Figure [10-28](#Fig28). The XML markup after the second Interpolator has been added should look like the following:![A324674_4_En_10_Fig28_HTML.jpg](A324674_4_En_10_Fig28_HTML.jpg)Figure 10-28.Change shareInterpolator to false; add the accelerate_decelerate_interpolator to your <alpha> tag<set android:parameters are in here ><scale android:pivotX="50%" android:pivotX="50%" android:fromXScale="0.0" android:toXScale="1.0"android:fromYScale="0.0" android:toYScale="1.0"android:interpolator="@android:anim/overshoot_interpolator" /><alpha android:interpolator="@android:anim/accelerate_decelerate_interpolator"android:fromAlpha="0.0" android:toAlpha="1.0" /></set>Now we are ready to instantiate the TextView object in the MainActivity.java code (tab) so that I can show you that your procedural animation assets can be attached to more than one widget, including text or button widgets, as well as widgets that use graphics, images, video, and SVG (scalable vector graphic) assets. This will also give you more practice in how to set up procedural animation assets to work with UI widgets and event handlers.

### Java 代码:两个小部件使用补间动画

To implement this new more complex animation set on the TextView at the top of the main content UI design in content_main.xml, and the first thing you need to do is add an android:id="@+id/textView" parameter in the <TextView> child tag so that this TextView object can be declared at the top of the MainActivity.java class, and instantiated at the bottom of the onCreate() method, and animated within your OnClickListener() event handling structure. Declare a TextView object named textView at the top of the class under the ImageView and Animation objects, then instantiate the TextView in onCreate() using:textView = (TextView)findViewById(R.id.textView);In the OnClickListener add the following statement, seen in Figure [10-29](#Fig29):![A324674_4_En_10_Fig29_HTML.jpg](A324674_4_En_10_Fig29_HTML.jpg)Figure 10-29.Declare, Instantiate, and call Animation off the TextView object to wire a TextView to the AnimationtextView.startAnimation(tweenAnimation);To see the TextView and ImageView with the new Fade+Scale vector animation applied, use your Run ➤ Run ‘app’ or Run ➤ Clean and Rerun ‘app’ menu sequence. When you click the FloatingActionButton that we “borrowed” to control the test of our vector animations, to keep it separate from our raster (AnimationDrawable) animation, the animating logo comes in from the distance, and fades into view, and the TextView also scales and fades into view, using a different timing (motion through time curve) than the scaling timing. Try different parameters on your own time, and see how they affect the animation result, to get some experience with procedural animation.

## 程序动画还是帧动画？

Finally, I wanted to discuss some of those higher-level theories, principles, concepts, and trade-offs, which will serve to differentiate the image-based frame animation AnimationDrawable approach from the mathematics-based procedural animation (vector or tween) Animation approach.Image (frame or raster) animation will tend to be more memory-intensive than it is processor-intensive. This is because each frame that is going to be placed on the display screen would need to be loaded into memory, so that these frames can later be used in your application. Displaying these images from system memory in a View is fairly straightforward, and does not require any complex calculations, so the processing overhead is low, as it only involves moving each frame’s image asset from system memory over to the Android device display screen.Frame animation would give you more creative control outside of Android OS, because you can use production software, including 3D, digital imaging, digital video, digital illustration, special effects, particle systems, fluid dynamics, morphing, digital painting and the like, to manipulate all your pixels into exactly the animation effect that you are looking to achieve. I have a half-dozen new media fundamentals titles from Apress, including the Android Studio New Media Fundamentals (2016) title, which covers how to produce these multimedia assets.Since Android does not yet include all of these advanced multimedia production tools, using a frame animation will allow you to leverage powerful production tools, some of which we will be using within this book, during the digital imaging, digital video, and digital audio chapters, outside of the Android development environment. You can then bring the results into your Android application using the image, video, audio, SVG, and 3D assets. For image animation this would include image bitmaps defined as frames within an AnimationDrawable object.Procedural animation tends to be more processing intensive because it involves numeric value interpolation, as well as the application of interpolator “motion curves” to the resulting interim data values. Additionally, if sets and subsets are utilized to create a complex animation structure, there can be a great deal more data processing involved, as well as the memory space that would be required to hold the plethora of settings, ranges, pivots, interpolation values, and similar animation processing data that will be needed by the Animation engine classes.Procedural animation gives you more control inside of Android 7.1.1\. This is because you are doing everything that controls your animation by using Java code and XML markup, and your animation data can be made to interact within the Java programming logic. This is because Java code and data, and even your UI element widgets, can be crafted to interface with the procedural animation in real time, allowing animation to be made interactive, whereas frame animation at least by itself, is not interactive. Frame animation by itself is a more linear medium, like digital video, where frames are played sequentially in order to achieve the motion graphics end result.Since you can apply procedural animation to just about any View object in Android, including your text, UI widgets, images, video, and frame animation, if you set things up correctly, such as using image compositing techniques to their best end result, you can achieve some impressive interactivity by using frame animation, audio, and digital video in conjunction with procedural animation, as you have already seen during this chapter.If you are combining image animation with procedural animation, as we did during this chapter, you will have a load on both processor and memory resources, so you must try and optimize what you are doing, so that you don’t use up too much of the system resources needed to run the rest of your application code and UI. This is why we touched upon the topic of data footprint optimization in Chapter [9](09.html), and why we’re learning about the same type of optimization principles here. We will also touch upon data footprint optimization in the digital video chapter (11) and the digital audio chapter (12) for exactly the same reason; if you run out of memory, your application stops working, and may even take down the rest of the Android user’s phone, tablet, or iTV set.

## Animator 类:参数动画

There is one other animation engine class (besides Animation and AnimationDrawable) in Android which I did not cover in this chapter, as it is not vector or raster animation of a new media asset, but rather a way to animate attribute changes for any Android class, which can also be done using Java programming loops.Developers can use this Android Animator class as a predefined (pre-coded) shortcut to animating object properties inside of Android that would usually be animated (interpolated or changed over time) by using Java programming structures to accomplish smooth iteration of object attributes using the same mathematics that is already defined for you using this Animator class.If you wanted to research this on your own, you can visit the following Android Developer website URL, if this area is of interest for your application development requirements:[http://developer.android.com/reference/android/animation/ Animator .html](http://developer.android.com/reference/android/animation/Animator.html)Since Chapters [10](10.html) through [12](12.html) cover advanced new media assets (animation, digital video and digital audio) in detail, I have opted to focus on image (animation), vector animation, digital audio, and digital video specifically.

## 摘要

In this chapter, you learned all about 2D animation concepts and principles, expanding on the 2D graphics concepts and principles that you learned about in the Chapter [9](09.html), into the fourth dimension of time. Changing images over time is the foundation for both 2D animation as well as digital video media. We will be covering digital video in the next chapter, as a logical follow-on to subject material you learned in this chapter.You learned about Android’s AnimationDrawable object and frame-based animation and the supported digital image formats (PNG) utilized for animation frames. You learned about how to define frame animation, as well as how to implement it inside of your DrawerLayout UI design from Chapter [8](08.html), using the Android ImageView class, which is used to hold Android Drawable objects, such as images and frame animation XML definitions.Next, you learned about the Android Animation class, used to implement the other major type of animation in Android, known as tween animation, procedural animation, or vector animation. Tween animation uses XML tags and parameters to create animation, using alpha blending, scaling, rotation, and translation (movement).You learned how to define procedural animation, as well as how to implement it in your DrawerLayout design from Chapter [8](08.html), using the ImageView class and Animation class. You declared and instantiated these objects in your MainActivity.java AppCompatActivity subclass in order to be able to “wire up" your procedural animation settings data to the AnimationDrawable 3D logo image animation created during the first section of the chapter.You also added an event listener to your multistate FloatingActionButton, which you enhanced in the previous chapter. You created hybrid animation, which used both frame animation and procedural animation, to achieve the ultimate 2D animation special effects. You learned how to build even more complex animation, by using the AnimationSet class and Interpolator interface and constants, and how to attach these to both text and image UI elements, so that you can achieve the same special effects you can in DVE, SFX, or Titling animation software.Finally, we discussed trade-offs between frame animation’s use of system memory and procedural animation’s use of CPU processing cycles. I also pointed out a third Animator class that animates Android class attributes (or parameters, as I like to call them), which we did not cover, as that class is not technically new media 2D or 3D animation at all, and is not in the AnimationDrawable (raster) or Animation engine (vector) animation classes.In Chapter [11](11.html), you will learn all about digital video in Android including foundational digital video theory and concepts, what digital video file formats are best to use in Android, how to create digital video assets for use with Android’s FrameLayout container class, and how to use the Android VideoView class and widget. You’ll also learn how that class works with the Android MediaPlayer class, the Android Uri class, and the Android MediaController class. Chapter [11](11.html) will be just as advanced as this chapter, if not more so, as video is complex.