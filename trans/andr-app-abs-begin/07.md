© Wallace Jackson 2017Wallace JacksonAndroid Apps for Absolute Beginners10.1007/978-1-4842-2268-3_7

# 7.让应用程序具有交互性:事件和意图

Wallace Jackson<sup>1</sup>(1)Lompoc, California, USAUser interface designs are built upon the foundation of the Activity superclass as well as the View and ViewGroup superclass, as you learned in Chapter [6](06.html). However, without interactivity in a UI design, the usefulness of what users can accomplish with your Android 7.1.1 applications will be somewhat limited. For this reason, I’m going to cover some more advanced programming concepts, for the absolute beginner at least, including events and intents.We will look at how Events and Event Listening work in Android, as well as how Intent objects will be utilized to switch between your Activity subclasses. You can use Intent objects to switch between functional UI screens in your Android applications, each of which is defined using one of the Android Activity subclasses, which references a ViewGroup UI layout container XML definition containing View UI widgets that generate the events that your event listeners will handle (process).Besides covering Android Intent objects and event handling capabilities , we will also cover broader concepts, such as Implicit Intents , Explicit Intents , and Intent Filters and how they relate to the Android Manifest and other Android applications. You encountered Intent Filters in Chapter [4](04.html), in Figure [4](04.html#Fig10), near the bottom of the screenshot, when we looked over the bootstrap AndroidManifest.xml file in detail.In this chapter, we’ll switch between Hello World and Hello Universe Activities using Intent objects. This will allow users to update the application, using Button and CheckBox widgets along with event handling (i.e., processing) and Intent objects.Adding interactivity to user interface elements, or widgets, would require that you learn what Event Listeners are, and how to implement them. Event Listeners will be used to make UI elements (widgets) interactive. Now that your Constraint Layout UI design is completed, and referenced using your .onCreate() and .setContentView() methods, we will instantiate Button and CheckBox objects, and then attach .onClick() event listener Java structures to them, so that your user can use them interactively to upgrade the status of your Hello World application, and downgrade it, as well.

## 关于意图对象:Android 意图类

An [Intent](http://developer.android.com/reference/android/content/Intent.html) object is used within the Android 7.x framework as a messaging construct that you dispatch to request some sort of action from one of your other [components](http://developer.android.com/guide/components/fundamentals.html#Components) within your Android application. Intents can also be used to request actions within someone else’s Android application, that is, one which is external to your Android application. There are three primary uses for Intent objects in Android:

*   发起活动子类
*   开始服务子类
*   在你的应用程序中发送信息

As I mentioned, these uses can also be accomplished even using external Android applications. This is done with broadcast receiver classes and methods. We’ll cover advanced Intent usage during advanced chapters at the end of the book.Here’s a basic workflow that shows how your Activity uses this Intent object:Activity > Intent object containing the Start Activity Action > New Activity (will be launched)--or--Activity > Intent object containing the Start Service Action > New Service (will be launched)As you have learned, [Activity](http://developer.android.com/reference/android/app/Activity.html) subclasses each represent one single user interface design within your application’s functionality. You will start each new instance of an [Activity](http://developer.android.com/reference/android/app/Activity.html) subclass by passing an [Intent](http://developer.android.com/reference/android/content/Intent.html) object over to its [startActivity](http://developer.android.com/reference/android/content/Context.html#startActivity(android.content.Intent)) () method .An [Intent](http://developer.android.com/reference/android/content/Intent.html) object passed into the startActivity() method will contain action data that will dictate which one of your application’s Activity subclasses you wish to start. The Intent object also includes a Context object that describes the current context for your application. We’ll cover the concept of Context within the chapter as well, as it is used often in Android programming.You will also use the Intent object to start Service subclasses. We’re covering services in Chapter [13](13.html). A [service](http://developer.android.com/reference/android/app/Service.html) is an Android component that can perform operations in the background. These operations usually do not require user interfaces, and can be performed “asynchronously,” or out of sync, with the user’s normal flow of use of your application and its purpose and objective. An example of a service would be playing a background music track. You can also start a Service subclass using an Intent object in order to perform a one-time operation, like a file download. This is done by passing the [Intent](http://developer.android.com/reference/android/content/Intent.html) object over to your . [startService](http://developer.android.com/reference/android/content/Context.html#startService(android.content.Intent)) () method call. This [Intent](http://developer.android.com/reference/android/content/Intent.html) should describe the Service subclass to start, as well as any necessary data that is needed for the Service to process.You can also use an Intent object to deliver a message broadcast across the Android OS, including anything running on the user’s Android device. A broadcast in Android is a term for any message that any apps running on the same Android device as your app can potentially receive. Your Android operating system will schedule broadcasts for system events, such as when the system boots up, or when your device is plugged in, or when it is finished charging.Developers can deliver a broadcast message to other apps by passing [Intent](http://developer.android.com/reference/android/content/Intent.html) objects via the . [sendBroadcast](http://developer.android.com/reference/android/content/Context.html#sendBroadcast(android.content.Intent)) (), the . [sendOrderedBroadcast](http://developer.android.com/reference/android/content/Context.html#sendOrderedBroadcast(android.content.Intent,%20java.lang.String)) (), or the [.sendStickyBroadcast](http://developer.android.com/reference/android/content/Context.html#sendStickyBroadcast(android.content.Intent)) () method call.

### 意图类型:显性意图与隐性意图

There are two types of Intent objects you can create and utilize within Android OS: explicit Intent objects and implicit Intent objects. The explicit Intent object will specifically reference the Android application component to start, by using an application component (Activity or Service, for instance) name and component type.An implicit Intent object provides a description of the component you want to launch but does not specify which one (name) to utilize. Implicit Intent infrastructures are more complicated to set up correctly than explicit Intents are, because you have to set up an Intent filter object to specify exactly what Android OS should look for, as an exact component (class) name is not specified for launch (loaded into memory and processing). If you think of an Intent as something that you wish to do (your intent), there are two types. For example, go out to see the new Star Wars film (an explicit intent), or, go out and see any of the newly released films (similar to an Android implicit intent).

#### 显式意图:对要启动的组件的直接引用

When you create an explicit Intent object to start your Activity subclass or to start a Service subclass, the Android operating system will start (place in memory) the component specified in that [Intent](http://developer.android.com/reference/android/content/Intent.html) object and schedule it for processing.In the next section, you will start the HelloUniverse.class by using this fully qualified .class (compiled) class name. HelloUniverse.java is your uncompiled (code) file name. A fully qualified compiled class name should be referenced in your Android Manifest XML definition as HelloUniverse.class.In other words, your Android Intent is launching your .class compiled version of your Activity subclass from within your compiled package, designated as .APK, or Android PacKage.You would typically need to use the explicit Intent object to start a component within your own application. This is because you inherently know the class name for your Activity subclass or Service subclass that you want to launch, and so you can utilize, or hard code, that component name in the Android Manifest and Java code.

#### 隐含意图:对您想要启动的组件的描述

Implicit Intent objects do not specify their target application component, but instead declare a general action to perform. This implicit Intent approach allows an application component, even from another Android application outside of your own Android app, to handle that Intent. The reason that Android also has Intent filters and the IntentFilter class is to aid with the processing, action determination, and successful handling of these implicit Intent objects.For example, if you wanted to show your app user a location on a map, you could use an implicit Intent object to ask, or request, that another map-capable Android application show your application user that specific location on the map that your application is referencing. Implicit Intents allow Android apps to work together seamlessly!When you create an implicit Intent object the Android operating system finds an appropriate application component (Activity, Service, broadcast receiver) to start up, by comparing the contents of your implicit Intent object to the <intent-filter> definitions declared in the Android [Manifest XML file](http://developer.android.com/guide/topics/manifest/manifest-intro.html) for other apps on the same Android device.If the implicit Intent matches up with one of the IntentFilter definitions, the Android operating system will start that component if it’s not already running, and delivers your implicit [Intent](http://developer.android.com/reference/android/content/Intent.html) object to it for processing. If multiple IntentFilter definitions are found to be compatible on the Android device, the Android operating system will display a pop-up dialog, so the user can select which app to use.It’s important to note that every Android user will install different apps, and therefore, different Android devices will invariably exhibit different combinations of installed Android applications. This results in different pop-up dialog selection choices. A good example of this is when you click a URL and an implicit Intent goes out to find apps which have WebKit (browser API) capability. A dialog comes up with an internal browser; Chrome, Firefox, Opera, or whatever browsers you have installed on that particular device. This is what implicit Intent objects should be used for: to allow users to control which applications are used with your applications. Let’s take a look at IntentFilter objects next, to better understand how implicit Intent objects work as they need good IntentFilter definitions in order to work optimally.

### IntentFilter:构造隐式意图定义

Each IntentFilter object is an Intent processing definition construct, which is defined using the application’s Android Manifest XML definition. An <intent-filter> construct defines a structure for each type of implicit Intent object your Android application’s components would like to be able to receive and process. This can be quite powerful, and can also get quite complex as well, as it allows developers to create Android applications that do things (perform tasks) for other Android apps. This effectively opens up an entirely new genre of Android application that Android developers can create so other Android developers can incorporate that service in their applications as well. The leading example of this type of app is Google Maps.By declaring an IntentFilter object for an Activity subclass, as Android Studio did for your MainActivity class, in your AndroidManifest.xml (see Figure [4](04.html#Fig10)), you make it possible for other applications to directly start your MainActivity Activity subclass by using an Intent object that evaluates to the MAIN action and the LAUNCHER category. In this case, the application that will start your Activity would be the Android OS application launch screen.If you do not create <intent-filter> XML definitions, constructing IntentFilter objects for any of your Activity subclasses, then these Activity subclasses will be invisible to outside Android applications. This means that they will only be able to be started using an explicit Intent object. A good example of this is what we’re doing in this chapter with your HelloUniverse Activity subclass, since we only want your MainActivity class Button object to be able to start this private component of your MyApplication Android 7.1.1 application.Finally, remember one important rule regarding the use of Intent objects in your Android programming. To ensure that your Android applications are completely secure you will generally want to use an explicit Intent object when starting your [Service](http://developer.android.com/reference/android/app/Service.html) components (any of your Service subclasses). This also means that you wouldn’t want to declare <intent-filter> XML constructs that create IntentFilter objects for your application’s Service subclasses, since IntentFilter objects are only utilized with implicit Intent object processing, and aren’t needed when utilizing explicit Intent objects. You will need one <intent-filter> definition for Android OS to use for the application launch sequence, as you’ve seen already in Chapter [4](04.html) (see Figure [4-10](04.html#Fig10)).The reason for this security rule is because by using an implicit Intent object to start a background processing Service class, you risk creating a security hazard within the Android OS on your end user’s device. This is because a developer cannot always ascertain what Service subclass will respond to their implicit Intent object and the end user cannot see which Service is starting on their Android device. This opens up the ability for destructive Services to be created. Do not launch Services using the implicit Intent object approach unless it is absolutely necessary.

### 实例化意图对象:传递应用程序上下文

Let’s look at the way you’ll instantiate, name, and configure an explicit Intent object , named upgradeIntent, which we will use to start the HelloUniverse Activity subclass, which we are going to create as the next step in this work process. This Activity will be similar to your MainActivity, and will use a user interface design created using the Visual Design Editor. You will declare the Intent object for use, provide a name, and “load” the Intent object using an equal sign, while at the same time, within the same Java statement, create your Intent object by using a Java new keyword, configuring the new Intent with the class name that you will be starting.All of these programming tasks would be accomplished by utilizing the following single line of Java programming logic in Android Studio :Intent upgradeIntent = new Intent( this, HelloUniverse.class );The Intent declares the object type; the upgradeIntent gives the object a name; the equals sign signifies that we are about to instantiate it; the Java new keyword creates an instance of the Intent object in memory; and finally, the parameter list passes over a Context object for our MainActivity Activity subclass, using the Java this keyword, as well as the HelloUniverse.class Activity subclass that we want to start, or launch, using an explicit Intent object created with this Java statement.Next, we will go over what the Java this keyword and a Context object do for your Android application, and then we will continue our work process in the section after that, and allow Android Studio to create our MainActivity.java class.

### 解释上下文:Android 上下文类

The concept of context in Java programming is simple in its definition, and yet is often complex in its implementation. It is something that you would need to know about, regarding what this application context is doing, and why it is needed, to be able to accomplish certain things in Android. This isn’t something you will need to manipulate directly, at least not until you become an advanced Android developer.Android provides a Context class, which by the very nature of a Java class, can construct a Context object, which is used to hold the context for each application component. The context defines how the component fits into the overall application, which is inherently what the word context actually means, so this class and object are aptly named. If you want to take a look at the Context class in greater detail, visit the following Android developer website URL:[https:// developer.android.com /reference/android/content/ Context .html](https://developer.android.com/reference/android/content/Context.html)This Context object, which is represented by the Java this keyword, essentially passes over a Context object for the MainActivity.class Activity component for your Android application containing detailed contextual information, referencing how your MainActivity application component will integrate with other application components to accomplish a cohesive working application , which is properly wired together.If someone asks you to do something for them you will usually ask them what the context for the task is, so that you know what, why, and how to accomplish the task! The reason for giving a receiving application component this context (clever Java keyword pun intended) is that these Context objects will allow a called application component to see or ascertain what the calling application component is doing, so that it can do the job (task) that it is being asked to do efficiently, effectively, and with proper referencing to the other components that comprise the application.When the Context object is filled or populated with information regarding the calling application component, this data is combined with the (inherent) knowledge of what the called application component is doing. The result is total application context, which, as we all know from real life, can be defined as the clear, overall view of the entire work process that we are currently involved with.A Context object is similar to a Bundle object, in that it contains a collection of related application information all bundled together into one complex object and sub-object hierarchy. Bundles tend to contain the states of the application, whereas the Context objects tend to clarify how the application components reference each other, and how they should work together.NoteYou’ve already used a Bundle object to save the current "state bundle" for your MainActivity Activity subclass, with your Bundle object named savedInstanceState in your onCreate() method call. The Bundle class allows you to put together bundles or collections of variables and data, so it is not complex enough to merit its very own section in the book. That said, if you are really into bundling data, you can take a detailed look at the Android Bundle class if you like. It is located at the following Android developer website URL:[https:// developer.android.com /reference/android/os/ Bundle .html](https://developer.android.com/reference/android/os/Bundle.html)Where Android Manifest XML definition files are used to provide some of the global information to the Android OS when it goes to launch the application, the Context object provides all of the local technical-, systems-, component-, and resource-level information for each of your application’s components, in real time (these attributes change) while an application is running.As I mentioned previously, you only need to know how to pass application component Context objects (often using a Java this keyword) properly in order to be successful in the majority of your Android 7.x application programming, design, and development endeavors, so I am not going to spend too much time delving into Android’s public abstract Context class during this Absolute Beginners book. I just thought you might want to understand why this Context object was used so frequently in Java and Android .Now we can continue on in our work process for creating a second Activity that will be launched using a Button UI element from your MainActivity class. The second HelloUniverse Activity subclass will use the second UI design created in Chapter [6](06.html), making it functional with event processing, using UI events and event listeners.

## 事件处理:通过事件侦听器使用事件

Android uses something called an event to allow the users of your application to interact with your UI design. There are different events for button (or mouse) click, touchscreen usage, and keyboard usage, and your Java code must handle these events, by implementing event listener code structures that trap these events as they move from your UI elements through your event handling code structures.When a user interfaces with their Android device hardware, the user interface elements will generate events, and the Android OS will deliver these events to your Java code for processing. This is done by using event listener Java constructs that take the form of an event listener method construct. The most common event listener methods include onClickListener() for MouseClick (supports touchscreen tap as well), onTouchListener() (touchscreen support only), or onKeyListener() (keyboard support). These listener methods listen for (wait for) and then process different kinds of events relating to user interface elements that are accessed by different hardware features on different kinds of Android devices. These include touchscreen devices, like phones and tablets; and keyboard devices, like iTV sets, tablets, and laptops.

### 事件:将设备用户交互转换为事件

There are a handful of important events that relate to things like keypresses and mouse clicks, which we need to go over here so you have a comprehensive overview of what is available to you for your user interface design and its interactivity.The primary events are for keyboard keystrokes (onKey), mouse clicks (onClick), which user interface element is being used (called “focus” or onFocus), touchscreen usage (onTouch) and menu usage (onCreateContextMenu). There is also an onLongClick event, which is the equivalent of a right-mouse button click for touchscreens, where you touch the screen for a longer period of time (called a “Long Click”) to pop up (create) the ContextMenu.Text (onKey) events are used for the text editing field UI element; mouse click events are used for UI elements such as buttons, radio buttons or checkboxes; touch events are used with touchscreen hardware; and focus events are used when moving to the next (or previous) UI element on the user interface design screen (Activity).

### 事件监听器:Java 方法处理 UI 小部件事件

An event listener is a Java interface for the View superclass, which as you now know, is used to construct your user interface widgets in Android. These event listeners are termed “callback methods,” because they listen for the event, and then execute your application code when they encounter that event. These methods will be called by the Android framework when each View widget to which the listener has been registered (attached) is triggered by your user’s interaction with the UI element. This interaction will generate an event (and often, more than one event).There are a half dozen event listener Java interfaces that are included in the View superclass, and therefore are available to all of the widget subclasses that are created using the View superclass. Since the ViewGroup superclass used to create layout containers is also a subclass of View, these are also available to UI layout container classes as well, since these UI layout contains extend ViewGroup.The most common of the events, because it works with touchscreen as well as the mouse, trackball, and similar pointer hardware, is the onClick() event. This is used inside of the View.OnClickListener interface. An onClick() event handler is called by the Android OS when a user touches any UI element when using touchscreen, or focuses upon an item with a navigation key, trackball or mouse, by pressing a mouse button, or any device navigation hardware’s enter key or by pressing down on the trackball itself.The next most common event, also because it works with touchscreen and with the mouse, trackball, and similar pointer hardware, is the onLongClick() event. This is inside of the View.OnLongClickListener interface. An onLongClick() handler is called by the Android OS when a user long-touches a UI element when using touchscreen, or right-clicks a trackball or mouse, by pressing the right-mouse button, or the right trackball button .Another very common event is the onKey() event, which is used with text-related content and user interface elements. It is used with hardware keyboards. This is inside of the View.OnKeyListener interface. This is called when the user is focused on the text element and presses or releases a hardware key on the device or uses a keyboard peripheral with a tablet, laptop, or iTV set hardware device.There is also an onTouch() event specifically for use with touchscreen devices, and this is in the View.OnTouchListener interface. An onTouch() handler is called when the user performs an action that Android terms a “touch event.” This includes a touch, a release, or movements (called gestures) on a touchscreen within the UI element.If you want to pop up a context-sensitive menu that contains options for the UI element, there is also an onCreateContextMenu() event construct that is used inside of View.OnCreateContextMenuListener. This is called when a context menu is being opened as the result of a long-click, and therefore this event will be fired at the same time as a LongClick event, since a LongClick event would be needed to open the ContextMenu.Another event that will often get fired at the same time as other events is the onFocusChange() event, which is inside of the View.OnFocusChangeListener interface. An onFocusChange() handler is called when the user navigates into (or exit from) the UI element, using the navigation keys hardware, keyboard tab key, mouse clicks, or the trackball. It is common that other events (key, click, touch, or long-click) should usually accompany an onFocus event for this reason, so there may be scenarios where a number of separate but related events are fired during user interface activity.These are the six primary (core) events that you will use in Android. There are also six more specialized types of events that I will cover for you here so you will be exposed to all twelve event types in Android. For mouse (or trackball) use, there’s an onHover() event handler that has a View.OnHoverListener for when a pointer is over a View (subclass) but not clicked. There is also an onDrag() event handler that uses the View.OnDragListener for when a View (subclass) is being dragged around the screen.There is a GenericMotion event that uses a View.OnGenericMotionListener used to handle MotionEvents and three events that detect changes in UI layout configuration, including onLayoutChange, onAttachStateChange, and onSystemUiVisibilityChange, each of which have their own associated event listener interfaces. These would contain code for what you want to happen when your UI layout (arrangement) changes, when you attach or detach UI elements , or when the system UI (status bar and action bar) becomes visible (or invisible) or on an orientation change of the hardware device.

### 事件处理程序:Java 方法处理全局事件类型

The term event handler is oftentimes used interchangeably with the term event listener, but there is a difference. The event listener is part of each widget View subclass, and implements the View.OnEventTypeListener interface for each of the UI element (widget) subclasses. This means that the implemented method construct processes a specific type of event, and is doing so for a specific user interface element (widget) type. This means that this event processing code is much more localized to that user interface element’s instance, and the type of event that you want to execute your Java code statements for. This approach leaves little room for confusion, from the code design standpoint.An event handler, on the other hand, forces you to define your event processing code for each event type, irrespective of the widget or layout container that may generate that particular event. For this reason, creating code that handles all occurrences of that particular event is therefore global in nature, as the processing is not part of the widget class definition. Event handlers are thus more complex, and not used as frequently as event listeners, which attach each event type you want to process to a specific UI element. Since this is an Absolute Beginner title, we will focus on mastering event listeners, as these are what you will use most of the time to make your user interface interactive. The way I look at it is the outer method structure “listens” for the event and the inner method structure “handles” the event. So .onClickListener() listens, and onClick() handles.

## 创建第二个活动:UniverseActivity 类

Now that you know what the Java this keyword is, which we will use here to pass over the Context object for your MainActivity.class to your UniverseActivity.class, we can go ahead and pick up where we left off in Chapter [6](06.html), and finish programming the application Java logic to process events and leverage explicit Intent objects.Let’s add code that switches from the MainActivity to another Activity when the user clicks on a Button user interface element. This will demonstrate how Intent objects and events work together.The first thing that we’ll need to do in Android Studio 2.3 is to create a new Activity class. Click on the app/java/com.example.user.myapplication/ folder, and select the New ➤ Activity ➤ Empty Activity menu sequence, as shown selected in blue in Figure [7-1](#Fig1).![A324674_4_En_7_Fig1_HTML.jpg](A324674_4_En_7_Fig1_HTML.jpg)Figure 7-1.Right-click Java app folder, and select New ➤ Activity ➤ Empty ActivityIn the Configure New Android Activity dialog use an Activity Name field to name your new Activity UniverseActivity. Next, deselect the Generate Layout File, shown as number 1, on the right side of Figure [7-2](#Fig2). Notice on the left side of Figure [7-2](#Fig2) that if you leave this selected, Android Studio will create your activity_universe2 XML UI definition file, since you already create the activity_universe.xml Universe Activity UI back in Chapter [6](06.html).![A324674_4_En_7_Fig2_HTML.jpg](A324674_4_En_7_Fig2_HTML.jpg)Figure 7-2.Name your Activity UniverseActivity, and deselect Generate Layout FileMake sure that you check the Backwards Compatibility (AppCompat) option so that Android Studio extends the AppCompatActivity superclass, just like Android Studio did when you created your application. This assures that your application will be compatible across all of the earlier versions of Android that are still in use.Finally, leave the default package name setting in your drop-down selector, as it is set to your current package name already, so there is no need to change this.Once you are finished setting all of these options, click on the Finish button, shown as number 2 in Figure [7-2](#Fig2), and have Android Studio write your Activity Java code for you. Next, you will open up the UniverseActivity.java tab in your editing area, so you can click on it, and continue adding to the bootstrap Java code.In the Project navigation pane, right-click your UniverseActivity Java file found in the app/java/com.example.user.myapplication/ folder, and select the Jump to Source option from the context-sensitive menu which appears, seen on the left side in Figure [7-3](#Fig3).![A324674_4_En_7_Fig3_HTML.jpg](A324674_4_En_7_Fig3_HTML.jpg)Figure 7-3.Right-click UniverseActivity and select the Jump to Source menu optionThis will open a UniverseActivity.java editing tab, which can be seen in Figure [7-4](#Fig4). Notice that since you’ve changed the project, the Gradle files will eventually need to be put in sync.![A324674_4_En_7_Fig4_HTML.jpg](A324674_4_En_7_Fig4_HTML.jpg)Figure 7-4.Android Studio created the bootstrap empty Activity code infrastructureAs you can see, Android Studio created the AppCompatActivity subclass, named it UniverseActivity, and created an onCreate() method. Next, add your setContentView() method call referencing the /app/res/layout/activity_universe XML as seen in Figure [7-5](#Fig5).![A324674_4_En_7_Fig5_HTML.jpg](A324674_4_En_7_Fig5_HTML.jpg)Figure 7-5.Add setContentView( ) method referencing activity_universe, and Sync NowAlso seen in Figure [7-5](#Fig5) is a warning drop-down telling you that you need the sync operation to be performed on your project Gradle files. Select the Sync Now option, to have Android Studio do this for you as well. Android Studio 2.3 can do a lot for Absolute Beginners; they just have to follow the proper work process (steps), which I am going to be showing you how to do over the course of this book. As you can see in Figure [7-6](#Fig6), Android Studio even added your <activity> tag for UniverseActivity.![A324674_4_En_7_Fig6_HTML.jpg](A324674_4_En_7_Fig6_HTML.jpg)Figure 7-6.Android Studio added a second <activity> declaration in AndroidManifestLet’s click on your MainActivity.java editing tab, and add the Button object so that we can wire in your UI button, and then add onClick() event processing to it. At the top of your class, type the word Button, and then double-click on the Button android.widget option in the pop-up dialog to have Android code an import statement.![A324674_4_En_7_Fig7_HTML.jpg](A324674_4_En_7_Fig7_HTML.jpg)Figure 7-7.Declare Button object top of class; double-click adds import statementAs you can see at the top of Figure [7-8](#Fig8) you now have an import android.widget.Button statement that allows you to use the Android Button class. Inside of the onCreate() method, add an instance of the Button object, named universeButton. This is done by using the findViewById() method . Reference the button element ID value that was used in your user interface design XML definition, which, following the Android naming conventions we are following, was button_universe.![A324674_4_En_7_Fig8_HTML.jpg](A324674_4_En_7_Fig8_HTML.jpg)Figure 7-8.In onCreate( ), instantiate universeButton, using findViewById( ) methodAfter you double-click the button_universe ID (notice it is an integer, or int) in the drop-down, Android Studio will complete the method call. Android Studio will cast the findViewById() method as being from the Button class by adding (Button) before the method call. Add a semicolon, as is seen in Figure [7-9](#Fig9), at the end of the Button instantiation statement to complete it. I clicked on universeButton in Android Studio to color its declaration and use.![A324674_4_En_7_Fig9_HTML.jpg](A324674_4_En_7_Fig9_HTML.jpg)Figure 7-9.The universeButton object is now declared and instantiated (error free)Notice when you click on an object or variable in Android Studio, it allows you to visually trace where it is being used in your code. Now do the same Button code in your UniverseActivity.java editing tab with the worldButton Button object, as is shown highlighted in Figure [7-10](#Fig10) using Button worldButton = (Button)findViewById(R.id.button);. Your UI button elements are now wired from XML to Java and are error free, so we can now move on to add our event listener Java code.![A324674_4_En_7_Fig10_HTML.jpg](A324674_4_En_7_Fig10_HTML.jpg)Figure 7-10.Add your worldButton declaration and instantiation to UniverseActivity

### 向活动按钮对象添加事件侦听器

Now that your Button objects have been declared, and instantiated, they will be used to call methods such as the .setOnClickListener() method that sets the event listener to an implementation of View.OnClickListener that in turn contains your onClick() event processing infrastructure.Add a line of code under the worldButton instantiation in the onCreate() method in your UniverseActivity.java tab. Hit the period to invoke dot notation, then type setOn, as is shown in Figure [7-11](#Fig11). Select the setOnClickListener(OnClickListener l) option from the drop-down, which will highlight it in blue, and double-click on it, which will then tell Android Studio to insert the method into your code structure.![A324674_4_En_7_Fig11_HTML.jpg](A324674_4_En_7_Fig11_HTML.jpg)Figure 7-11.Call a .setOnClickListener( ) method off the worldButton Button objectSince we have not declared and instantiated an OnClickListener required for the method, we will be using the Java new keyword inside of the .setOnClickListener()’s parameter area, as a short-hand format for creating this event listening construct. The long form way to do this would be to create a public listener class, like this:public class WorldButtonListener implements View.OnClickListener {@Overridepublic void onClick (View view) {// Your Intent processing code to start the Universe Activity would go in here}}This would create a plethora of classes for handling all your UI events, so the shorter, denser, code construct has become the convention for setting up listeners.Inside of your .setOnClickListener() parameter area, you will instantiate a new View.OnClickListener that will contain your onClick() event handling construct.Inside of the method parens, as is shown in Figure [7-12](#Fig12), type new View.On and double-click on the View.OnClickListener (android.view.View) (android.view) option. This will tell Android Studio 2.3 to insert an empty View.OnClickListener(){} Java code construct, inside of which you will soon be writing the Java code for the public void onClick(){} event handling infrastructure.![A324674_4_En_7_Fig12_HTML.jpg](A324674_4_En_7_Fig12_HTML.jpg)Figure 7-12.Call .setOnClickListener( ) off worldButton and use new keyword in callWhat this is doing in a short-hand or “dense” Java code construct, which is providing you with an instance of the View superclass OnClickListener interface, which will be used to contain your onClick() event handling Java programming logic, which is really where your primary event processing programming logic is going to end up.Once you double-click the Android Studio Java code writing helper (drop-down), you will have the empty construct {} for your code, which will override the onClick() method, which is the next step in our event listening and handling work process.The rest of the code for this construct will be entered inside of the empty {…} View.OnClickListener, just as you would have done if you had coded an event listener using a WorldButtonListener class, as I showed you earlier in this section.This can be seen in Figure [7-13](#Fig13), if you want to look ahead, and once this Java code structure is completed, you will then have one of your two Button click event processing code structures, and you can get some practice duplicating the process again for the MainActivity.java class.![A324674_4_En_7_Fig13_HTML.jpg](A324674_4_En_7_Fig13_HTML.jpg)Figure 7-13.Inside OnClickListener() use Java @Override keyword to override methodType @ and select Override ( java.lang) from the drop-down shown in Figure [7-13](#Fig13).Next, enter the onClick() method declaration as public void onClick(View view){ } after the @Override, and create another empty method . Notice that I am creating Java code constructs that are initially empty and that are error free as I go along, so that any errors that may arise are isolated, and easier to diagnose and fix. I show this empty onClick() code structure, which thus far is error free, in Figure [7-14](#Fig14).![A324674_4_En_7_Fig14_HTML.jpg](A324674_4_En_7_Fig14_HTML.jpg)Figure 7-14.Create public void onClick empty method structure for event processingOnce you finish typing in your empty onClick() event handling method structure, Android Studio might pop up a dialog, advising that your empty Java method structure needs an import statement. If it does, click OK, as seen in Figure [7-15](#Fig15), and one will be added for you! If Android Studio sees something missing, it will alert you and even add it for you!![A324674_4_En_7_Fig15_HTML.jpg](A324674_4_En_7_Fig15_HTML.jpg)Figure 7-15.Select android.view.View package for Android Studio to import for you

### 将意图处理添加到事件处理中

The first step in adding an Intent object is very similar to declaring a Button object, in as much as you declare the Intent at the top of the class, double-click the pop-up helper to have Android Studio import your android.content.Intent class, and then name the Intent object, finishing your declaration statement using a semicolon. This process is shown in Figure [7-16](#Fig16); I am naming this Intent worldIntent.![A324674_4_En_7_Fig16_HTML.jpg](A324674_4_En_7_Fig16_HTML.jpg)Figure 7-16.Declare an Intent at top of class; double-click adds import statementNow that you have declared and named your Intent object, you will instantiate it inside of your onClick() structure using the Java new keyword along with the Intent class constructor, which takes a Context object using the Java this keyword and the class that you want to launch, which in the case is your UniverseActivity class.Inside of your onClick() construct, type in the worldIntent object and then the equals sign. On the right side of your equals sign, utilize the Java new keyword to instantiate the Intent object using the Intent(Context, Target) constructor method.Once you type in worldIntent = new Intent(this, Ma) Android Studio will show you your MainActivity (com.example.user.myapplication), which you can select and double-click to add it into the Java programming statement (Figure [7-17](#Fig17)).![A324674_4_En_7_Fig17_HTML.jpg](A324674_4_En_7_Fig17_HTML.jpg)Figure 7-17.Instantiate Intent inside onClick( ) method, and reference MainActivityAs you can see in Figure [7-18](#Fig18), Android Studio puts its wavy red error underline under the parameter area, indicating there may be a problem. Mouse-over this so you can see what Android Studio thinks that the problem may be related to (Android could not resolve the Context object passed into the constructor method because it was not for the calling class).![A324674_4_En_7_Fig18_HTML.jpg](A324674_4_En_7_Fig18_HTML.jpg)Figure 7-18.Mouse-over red underline error, to see what the issue is with the codeAndroid cannot resolve the Context of android.view.View.OnClickListener because it needs the Context for the UniverseActivity class , so you can fix this error with dot notation. Append a UniverseActivity class name before your Context this keyword so that the this (Context) becomes the UniverseActivity.this (your UniverseActivity class’s Context object, rather than your OnClickListener method’s context). As you see, in Figure [7-19](#Fig19), this gives you an error-free statement.![A324674_4_En_7_Fig19_HTML.jpg](A324674_4_En_7_Fig19_HTML.jpg)Figure 7-19.Add path for Context object to the UniverseActivity using dot notationThe final step is to add the startActivity() method call. Type startActivity(), as is shown in Figure [7-20](#Fig20), and inside of the parens type “wo” and double-click the worldIntent Intent object from the drop-down helper menu to insert it in your code .![A324674_4_En_7_Fig20_HTML.jpg](A324674_4_En_7_Fig20_HTML.jpg)Figure 7-20.Use the startActivity( ) method with your worldIntent to start ActivityThis startActivity() method is contained in every Activity subclass. It takes as a parameter the Intent object that you defined using the UniverseActivity Context and the MainActivity.class (which you would like to start). Make sure to also complete this same Java code structure for the MainActivity class (where you want to start the UniverseActivity instead of the MainActivity), which I show on the right side of Figure [7-21](#Fig21), and references UniverseActivity from MainActivity.![A324674_4_En_7_Fig21_HTML.jpg](A324674_4_En_7_Fig21_HTML.jpg)Figure 7-21.Replicate code in MainActivity; then use Tools ➤ Android ➤ AVD Manager

## 模拟硬件:创建 AVD 来测试你的应用

Before we “Run” and test this application, we need to create an Android Virtual Device (AVD) , which is called an emulator , as it emulates real-world hardware devices like smartphones, tablets, iTV sets or smartwatches. Use the Tools ➤ Android ➤ AVD Manager menu sequence, seen in Figure [7-21](#Fig21), and let’s open the AVD Manager dialogs.Click the Create Virtual Device button in the AVD dialog, shown in Figure [7-22](#Fig22).![A324674_4_En_7_Fig22_HTML.jpg](A324674_4_En_7_Fig22_HTML.jpg)Figure 7-22.Click on Create Virtual Device, and enter Virtual Device ConfigurationThis will bring you to a Select Hardware dialog , where you will select the type of hardware device that you would like to emulate for your application testing. We are developing a Phone application, so, leave the default Phone Category selected, and select the popular Nexus 5 , as shown in Figure [7-23](#Fig23). The Nexus 5 has a True HD display, and at about five inches diagonal, is a competitor for the Samsung Note 5.![A324674_4_En_7_Fig23_HTML.jpg](A324674_4_En_7_Fig23_HTML.jpg)Figure 7-23.Select the default Nexus 5 device definition and click the Next buttonIf you are using the AMD CPU, you will want to install the ARM System Image, because in the next dialog, you will be selecting either an Intel (x86) or an AMD (ARM) ABI for use as your AVD emulator. An Application Binary Interface (ABI) defines how the machine code for your app will run on your CPU as it executes your AVD emulator. If you want to look ahead and see the System Image dialog, take a look at Figure [7-25](#Fig25).To install ARM v7a System Image files, you’ll use the same Tools ➤ Android menu sequence, and select the SDK Manager option, which you are quite familiar with, and which can be seen in Figure [7-21](#Fig21) immediately under the AVD Manager in the submenu.Once the SDK Manager opens, select the SDK Platforms tab and select the Android 7.1.1 Nougat API. Select the Show Package Details checkbox at the bottom-right corner of the dialog to show what is underneath the API and select all the ARM v7a related entries, as is shown in Figure [7-24](#Fig24).![A324674_4_En_7_Fig24_HTML.jpg](A324674_4_En_7_Fig24_HTML.jpg)Figure 7-24.If using AMD CPU, install the ARM v7a System Image in your SDK ManagerNext, click on the Apply button, and select OK in the Confirm Change dialog, as is shown on the right side in Figure [7-24](#Fig24). Once you click on the main OK button, at the bottom of the SDK Manager Default Settings dialog, you will get an SDK Quickfix Installation dialog, which will then show you what packages are being downloaded or installed, along with a progress bar for each operation, as it is occurring.If you have an AMD CPU, and have installed these ARM v7a system image files for Android (and for Google Play Services if the app needs them), you will then have both Intel (x86) and AMD (ARM v7a) system image options available in AVD Android Virtual Device Configuration dialog’s System Image panel, which follows the System Hardware panel shown in Figure [7-23](#Fig23).If you are using Intel you can skip the step seen in Figure [7-24](#Fig24). I had to make sure all readers could install and use an AVD emulator for application testing, so I had to include that important SDK Manager step for our AMD users so that the next step will work, regardless of what CPU you have decided to develop applications on.If you’re using an Intel system click the x86 tab, if you’re using an AMD click on the Other Images tab. I selected the latest Nougat Android 7.0 API Level 24 ABI, which as you can see in Figure [7-25](#Fig25), I have now downloaded in the step shown in the previous Figure [7-24](#Fig24). This is why there’s no Download link next to the Release Name in the far-left column.![A324674_4_En_7_Fig25_HTML.jpg](A324674_4_En_7_Fig25_HTML.jpg)Figure 7-25.Select the Android 7 Nougat API Level 24 System Image for AMD or IntelAMD users can now safely ignore the red warning on the right and click the Next button to advance to the Verify AVD Configuration dialog, where we will confirm all of the default settings.After we complete this last step, Android Studio will create your AVD and use it when you run your application, so that we can make sure all of the code is working that we have created (and Android Studio has created for us using the Visual Design Editor and New Android Application series of dialogs).To see all of the default settings, which are obviously the ones Android Studio recommends for use with that particular AVD emulator, click Show Advanced Settings , a button on the bottom left of the AVD Verify Configuration (fourth) dialog in the series. Once you do this, you can define how everything about an AVD is configured.As you can see, I have the AVD launch in Portrait (vertical) mode, although the AVD has a toolbar that allows you to change this orientation as you are testing the application. We will be using this feature in future chapters of the book.I leave the Cameras as emulated, although if you have webcams installed on your workstation, you can pipe these through the emulator using these drop-down menus.Leave your Network Speed at maximum with no Latency, which is best for testing, because there is enough latency on the busy (often overloaded) Google Play Server to make your testing process slow down as it is, no need to add to your wait times .Leave Graphics (GPU) performance optimization set to automatic and leave Multi-Core CPU capability enabled (selected), which are the default settings. The settings here will allow Android Studio to optimize the most speed out of your AVD emulator.If you have a high-capacity (memory, hard disk drive, etc.) workstation you can increase the values in the Memory and Storage section of the dialog to make the AVD emulator work faster. I used the defaults to simulate what the AVD would work like for most readers. Finally, I left the Device Frame enabled to simulate the Nexus 5\. See Figure [7-26](#Fig26).![A324674_4_En_7_Fig26_HTML.jpg](A324674_4_En_7_Fig26_HTML.jpg)Figure 7-26.Accept default Portrait orientation, and accept the other AVD defaultsIf you want to see what the device frame looks like, take a look at Figure [7-27](#Fig27) to see that the device frame simply makes your application look like it is running on a smartphone. I left this on, to make screenshots for this book more realistic.![A324674_4_En_7_Fig27_HTML.jpg](A324674_4_En_7_Fig27_HTML.jpg)Figure 7-27.The Nexus 5 API 24 AVD is now shown in the Virtual Device Manager listOnce you click the Finish button, you will get the Your Virtual Devices dialog , with an entry for the Nexus 5 API 24 device. I’m not sure why the Your CPU does not support required features and the ARM CPU/ABI is supported for the AMD CPU, as you will soon see in the next section. Possibly some code should be added in this dialog series to detect if the AMD processor is in use and the ARM v7a ABI System Image has been installed and remove this message from this dialog. Ignore it for now, and no need to “Troubleshoot” (link) a problem that does not actually exist. Let’s run the application next, and make sure that it (and the AVD) actually works!

## 运行应用程序:使用 Gradle 构建应用程序

Now that you have installed your AVD , you can use your Android Studio Run menu, and test your application. As you can see in Figure [7-28](#Fig28), your Run ➤ Run ‘app’ menu sequence is used to test your app the first time. Once you have used Run, make sure that you use the Run ➤ Stop menu sequence to stop the executing app in memory, even if you have minimized or even closed the AVD emulator, which is a separate process.![A324674_4_En_7_Fig28_HTML.jpg](A324674_4_En_7_Fig28_HTML.jpg)Figure 7-28.Use a Run ➤ Run ‘app’ menu sequence and test your Java code in the AVDThis will open the Event Log pane at the bottom of the Android Studio IDEA, and start telling you what is being done, primarily in the Gradle Build System , to sync and build your application in to an executable format, as is shown in Figure [7-29](#Fig29).![A324674_4_En_7_Fig29_HTML.jpg](A324674_4_En_7_Fig29_HTML.jpg)Figure 7-29.Open your Event Log pane to see Gradle events (sync, build, execution)If there are no errors in the app Java or XML, the AVD emulator, seen in Figure [7-30](#Fig30), will open, execute (run), and display your Android 7 Hello World application.![A324674_4_En_7_Fig30_HTML.jpg](A324674_4_En_7_Fig30_HTML.jpg)Figure 7-30.MyApplication running in Nexus 5 emulator switching between ActivitiesLet’s test your application, by clicking on the UPGRADE APP button, seen on the left side of Figure [7-30](#Fig30), and make sure your event handling and Intent processing opens the Hello Universe activity, shown on the right side of Figure [7-30](#Fig30). To test all of your code, click on the DOWNGRADE APP button next, and make sure your event handling and Intent processing opens the Hello World activity (MainActivity), shown on the left side of Figure [7-30](#Fig30). Click these buttons back and forth a few times to make sure there are no memory leaks or errors generated, to stress test your app.Notice the Icon Toolbar (in the center of Figure [7-30](#Fig30)) that accompanies the AVD emulator. The top two (tiny) icons will minimize (left) and close (right) your AVD, and the rest are hardware (in this case smartphone) controls including, from top to bottom, Power, Audio, Orientation, Camera, Zoom, as well as the Back, Home, History and Overflow menu buttons found in Android’s ActionBar, and on the hardware device.Congratulations, you have created your first Android 7 application! We will be looking at other user interface design paradigms in the remaining chapters, as well as how to use other types of new media assets, and advanced concepts such as MySQL databases and Services (background processing and threads).

## 摘要

In this seventh chapter, you learned about how to make your Android application interactive. This is done by leveraging Intent objects, events, event listeners, and event handling. Intent objects are unique to the Android platform; however, events and event processing can be found in many programming platforms, including Java and JavaFX, HTML5 and JavaScript, and other OOP languages as well.We spent the first part of the chapter learning some basic concepts regarding the important Android superclasses and Java interfaces that allow these events and Intent objects to be processed, allowing user interface designs to be interactive.You learned about how to add a new class to an application, to create the Hello Universe Activity subclass that was used to host the Universe UI design you created in Chapter [6](06.html) by using Android Studio 2.3’s new Visual Design Editor .You coded an event listener structure and an onClick event listener, which starts a new Activity, by using an Intent object, configured with the Activity Context and the target Activity subclass name. You cross-wired the two Activity classes together, so you could go back and forth from Hello World to Hello Universe.Next, you learned how to set up an AVD emulator that you can use to launch and test an application. You did this by using the AVD Manager series of dialogs.Finally, you tested your application using the Android Studio Run menu, and saw that your two Hello World Activity UI designs work properly and can call each other back and forth without any crashes.Next, in Chapter [8](08.html) you will start to learn about some of the other more popular Android UI design paradigms, such as the navigation drawer UI design, tab-based UI design, and a scrolling UI design .