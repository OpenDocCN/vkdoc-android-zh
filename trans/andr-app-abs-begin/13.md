© Wallace Jackson 2017Wallace JacksonAndroid Apps for Absolute Beginners10.1007/978-1-4842-2268-3_13

# 13.Android 服务和线程:后台处理

Wallace Jackson<sup>1</sup>(1)Lompoc, California, USAIn Chapter [12](12.html) on digital audio, you utilized the Android AudioManager class, which is a subclass of the Android Service class. In Chapter [11](11.html), you also learned about the Android FullscreenActivity, which has both threads (runnable) and Service features, which we will cover during this chapter. Also in this chapter, we will take a good look at the Android Service classes and related processing concepts, such as processes and threads.Developers use the Android Service class and subclasses to perform background asynchronous operations. “Asynchronous” means that these operations, or more accurately, your Java code structures that utilize Service and thread classes, can “go off on their own” and process data streams or perform complex computation, 100% in the background, undetected by your application’s user. Background Service asynchronous operations can do this without having to synchronize with an application user interface design, which is probably busy controlling how your application’s content (its subject matter and objective) is being presented to your application’s users.Examples of using Android Service subclasses include the playback of long-form digital video and audio, using the MediaPlayer class, while your user is using other areas of the application, talking to servers, or databases, in the background, downloading data, managing file input-output streams, streaming new media content (digital video streams or digital audio streams), handling networking (SMTP and HTTP) protocol transactions, handling payment gateway transactions, real-time processing of GPS data, and similarly complex computational or data-processing tasks. The user would also be doing other things using their devices, such as answering phone calls. This chapter looks at the Android Service class and all of the various characteristics of Android Service classes. We’ll look at how their features, functions, settings, constants, and characteristics are declared in your Android application. Declaring a Service for usage is done in your AndroidManifest.xml file, by using the <service> tag.This is one of the most complex topics in Android OS, and is not generally touched upon by Absolute Beginners; however, to cover Android development thoroughly, I had to include it, thus, these last two chapters will be somewhat advanced. This is because this topic involves advanced concepts like binding, synchronization, processes, processor cycles, threads, access control, permissions, and similarly advanced OS layer (under the hood at a core OS kernel level) topics, as these are all accomplished using the Linux Kernel (the lowest operating system layer) for the Android 7.1.1 OS. We looked at these different levels of the Android OS back in Chapter [3](03.html), so you can refer to Figure [3-1](http://dx.doi.org/10.1007/978-1-4842-2268-3_3Fig1) if you need another “refresher” view of this Android OS and application hierarchy.Tasks that are delegated to an Android Service also tend to be very processor intensive, so keep your end user’s battery life in mind if you are going to develop processing-intensive applications. As you might guess, your two primary power drains on the Android battery are prolonged CPU processing and display screen backlight usage for long periods of time. Services are generally utilized when you need to handle things that need to be running in the background of an app, in parallel with Android user’s real-time usage of your application, but not directly synchronized with (connected with) your end user’s real-time usage of your application’s user interface design.Tasks that are delegated to Android’s Service class are not typically tied to user interface and user experience tasks. This is because forcing concurrent (synchronized) processing might cause that user interface task, which is ultimately a user experience task, to become stilted or jerky. Overloading a processor ultimately will cause stilted playback, and will not portray a smooth user interface response, and will therefore not result in a positive user experience.

## Android 的服务类:特征

In Android, a Service can be defined as an application component that can perform CPU processor-intensive functions in the background. The Service is provided without the need for any user interface design, or any Activity display screen front end. A Service does not require any user interaction in order to accomplish its processing tasks. As you might imagine, like anything else, an Android Service object is created using the class in Android named, you guessed it, Service, in the Android app package (so, you import android.app.Service).The Android application starts a Service object by using an Intent object, and the Service object will continue to process in the background, even if the Android device owner switches over to a different Android application to do something else, for instance, answering phone calls, replying to incoming email, or accepting social media connection requests. Any Android application component can bind to a started Service object and then later interact with it. Components can also perform interprocess communication, which you may have heard referred to as simply IPC. We will be taking a closer look at processes and threads in the next section of the chapter, after the overview of the Android Service class and primary Service object attributes.Binding is an advanced programming concept, that involves establishing a real-time connection between two separate application component processes. Once bound, the processes will alert each other whenever something has changed in the other one. An alerted process can then check, and see if an update needs to be made based on that change. If you are a game programmer, you will commonly define a bind between the scoreboard UI design and your game scoring logic engine, for instance, so your scoreboard numeric read-out will change in real time, as the game is being played. You’ll bind a Service so that your application can follow progress regarding tasks.An Android Service usually will take one of two forms—either “bound” or “started.” Let’s start with the started Service, as it is the most common. An Android Service becomes started when an application component, such as an Activity, specifically starts it by using a method call. This is done by calling the . startService() method.Once it has started, a Service can run in the background indefinitely, even in a scenario where a component that started the Service gets subsequently destroyed, that is, removed from system memory. This can be done by either the application program logic, or by the Android OS if it becomes necessary for the overall function of the device. A started Service performs a single operation and does not return a result to the calling entity, much like a void method performs its task without returning anything to the object calling the method. For example, a started Service might download (or upload) data files over your network. When your started Service operation is completed, the Service object should automatically stop itself. This helps optimize Android operating system resources, such as device CPU processing cycles and system memory usage, which should always be conserved.A bound Service is created when an Android application component binds to a Service. This is accomplished by calling a .bindService() method. The bound Service offers a client-server interface that allows components to interact with the bound Service. Just like with a client-server relationship, you can send requests, get results, and you can even do all of this across (between) different processes, using interprocess communication (IPC) . A bound Service remain in system memory as long as other Android application components are still bound to it. Multiple application components can bind to a bound Service at the same time. When all of these application components unbind from the Service, that Service is destroyed: that is, removed from the device’s system memory.We will take a look at both of these types of Service formats, as well as a hybrid approach, where your Service can work in both of these ways, and at the same time. What this means is that you can start your Service, so that it is a started Service and can run indefinitely, and later allow it to be bound. Whether the Android Service is specified as started or bound is determined by whether you have implemented a couple of the more often used Service class callback methods. For instance, the Service class .onStartCommand() method will allow components to start a Service, and the .onBind() method will allow components to bind to that Service.Starting in 64-bit Android OSes (5.0 and later versions) there is also a scheduled Service . A Service can be scheduled when an object created with the Android JobScheduler class launches the Service. You can use this JobScheduler class by registering jobs, and specifying their requirements for network access and execution timing. The Android OS will then optimally schedule these jobs for execution, at the most optimal time. This JobScheduler class provides methods that allow developers to specify the Service execution parameters. The JobScheduler class and a scheduled Service is more advanced than the basic Service, but I wanted to cover scheduled Service classes here, so that you know it is an option, for more advanced Service scheduling, once you become a more advanced Android application developer, that is.Regardless of whether your application’s Service is started, bound, hybrid (both started and bound), or scheduled, it is possible that other application components can utilize that Service, even from a separate application, if you allow it. This is similar to the way that any of your application components can start (launch) an Activity subclass, by starting it using an Intent object, even if that Activity is not a part of your package. We covered using Intent objects way back in Chapter [7](07.html). You will see how Android apps use Intent objects to start a Service subclass, which we will create during this chapter named AmbientAudioService. This class will use a background service to play background ambient audio with Android’s MediaPlayer component.

### 控制你的服务:隐私和优先权

Service subclasses will run at a higher priority than inactive Activity subclasses whose UI is not active or being viewed on the device. Because of this fact, it is far less likely that the Android operating system will terminate a Service class than it will an Activity class. If your Activity subclass is active, or currently in use by your user on their display screen, it will obviously possess the highest priority, as the assumption is that the user is currently and actively using it to interface (hence the term “user interface”) with the application, and therefore with the Android hardware device.It is important to note that you can declare your Service as private using your Android manifest XML file. This will block access to your Service subclass from other external Android applications. This is usually a good idea for security reasons, which I also discuss in the chapter. Android developers will often do this as a programming or development best practice, unless other Android applications will absolutely need to use their Service.A Service subclass, as a default, always runs inside the primary thread of the host application’s primary process. This is often called a UI thread, as it runs the UI. Services that run inside of this primary application process are often termed local Services. You will be reading about processes and threads in the next section of the chapter.A common misconception among Android programmers is that Android Service subclasses always run on their own separate threads. This is certainly possible, if you configure your Service subclass in that way. The Service does not, in fact, by default create its own thread, and thus won’t run in a separate thread, unless you specify that.What this means is that if your Service is going to do any CPU-intensive work (such as decoding streaming data in real time) or blocking operations (such as real-time network access over busy network protocols), you should create a new thread within your Service in order to do that type of processing so UI performance is not affected.It is important to note that you may not need to use another thread for your Service class apart from the thread it is on (using already); for instance, in the example in this chapter we play a music file using the MediaPlayer in a Service without needing to spawn another thread. The only way to determine if this is needed is to first try using a Service class for your background processing, and then, if it affects user experience, consider using a thread.

### 进程或线程:基础信息

When one of your Android application components, such as the MainActivity class, starts, and your application does not have any other components currently running, the Android operating system will launch a new process for your application using the Linux kernel. This single thread of execution is commonly called the UI thread. A process can generate or launch (I often use the popular industry term spawn) more than one thread. There is a Thread class (and therefore, a Thread object can be created) for the Android OS. As a rule, all of your Android application components will run inside of this same initial process and thread. This is generally termed the main thread, the primary thread, or the UI thread. If one of your Android application components starts, and Android sees that a primary process already exists for your application, due to the fact that another component from your application already exists, the new component will also be started within that same application process and thread.To start your own thread, you must do so specifically within your Java code by creating a Thread object. You can also have different components in your application run in separate processes, and you can create additional threads for any process. This is what is usually done with Android Service subclasses. The Service process for Android is created using XML markup, unlike the Thread object, which is created using Java.You will be taking a look at creating a <service> using XML, during the next section of the chapter. Creating a Thread object, and how to do this, and when to do so, is currently beyond the scope of this Absolute Beginner title. There are entire books written on the subject of multi-process programming, threads, binding, and similar topics for professional Android developers; however, those are on the other end of the spectrum from this book.The default functionality in the Android OS is all of your Android application components will run in the same process used to launch your application. Most of the bootstrap Android applications will not need to change this behavior, and should not interfere with this default application launching and running functionality, unless there is a very compelling functional reason (which would be too advanced to cover in this book title) for doing so.For advanced applications (which we are not going to be covering in this book), I will cover this concept here, to be thorough regarding Android OS and its processes. If you happen to find yourself in development situations where you absolutely need to control which Android process/thread a certain application component belongs to, and functions in, you can specify your own custom processes in your application’s AndroidManifest.xml file. The core difference is threads run in a shared memory space, whereas processes run in their own memory space.Let’s take a look at how to spawn a process using the android:process parameter inside of the four major areas of Android. These four major functional areas each implemented by using a superclass, include the Activity, the Service, the broadcast receiver (communication messages), and the content provider (database storage). These use the Android OS <activity>, the <service>, the <receiver>, and the <provider> parent tags, respectively.

### 衍生一个进程:android:process XML 参数

The AndroidManifest.xml application component tags for each major type of application component, whether it is an Activity <activity> tag, a Service <service> tag, a broadcast receiver <receiver> tag, or the content provider <provider> tag, can include the optional android:process parameter. This parameter will allow you to control the process that a component will run inside of (or under, if you prefer to visualize it that way).An android:process parameter should be utilized to specify the process under which the application component needs to run. You can set up this process parameter in such a way that each of the application’s components run inside its own process, or you can “mix and match” components and processes in such a way that some of your application components will share a given process, while others will not share that process and would even have their own process (memory space) altogether.If you want to get really complex, you could set these android:process parameters so that components from different Android applications can execute together inside the same Android process (memory space). This can only be accomplished when those particular applications share the same Linux user ID, and which are signed with the same certificates. This topic is also too complex for this book; I mention it here just so that you know about it, in case you wish to research it further.It is interesting to note that the global <application> tag in the Android manifest XML file will also accept an android:process parameter. Using the android:process parameter inside of your <application> tag will set the default process value for your application, which would then be applied to all of your application’s components, which are located inside of the XML application component definition (nested) hierarchy. Of course, this would not include those application components that then utilize their own android:process parameter. In this situation, the application component child tag that utilized the android:process parameter to specify a different process for that particular application component would override the global or default process that you set as the process for your application to use via the android:process parameter inside the <application> tag. If you want all your components, except for one or two, to share the same custom process, define that process in your <application> tag and then override it selectively using one of the component child tags with android:process.It is important to note that the Android OS has the option to shut down any of your processes at any given time. This is so that it can efficiently manage your user’s system hardware resources (memory and processing cycles). This could be important when system memory is running low or if the memory used by your process is required by other processes that have a higher priority level, or are receiving more usage (attention) from the end user.Application components running inside of a process that gets terminated by Android are subsequently destroyed (which means they’re removed from memory). Not to worry, as any of these processes can be restarted again, at a later time, for any of the application components that still require that something be accomplished for or by a user. In fact, that is exactly why the savedInstanceState Bundle object that you are now familiar with is often utilized.When deciding which process to kill, the Android OS weighs their relative importance to a user. For example, Android more readily shuts down processes that are hosting Activity subclasses that are no longer visible on the screen, as compared to a process hosting a visible Activity that is being used. This decision regarding whether or not to terminate a process depends on the state of the components running in that process. The rules Android uses to decide which process to terminate are important to understand, so, let’s dive deeper into this topic next.

### 流程生命周期:保持流程的活力

Android 7.1.1 OS will try to keep your application processes in its system memory for as long as it can. However, it sometimes needs to destroy some older processes running in the OS. This is done in order to reclaim the system memory resources for newer or higher priority processes. After all, so many Android devices ship with only 2 or, at most, 4 gigabytes of main system memory; this may change in 2018 with iTV sets featuring the nVidia Tegra Parker chipset and 8 or more gigabytes of memory. Android system memory can fill up fairly quickly, as users simultaneously play games, launch apps, read e-books, stream music, and place (and receive) phone calls.Even when iTV set devices start to ship with 8 gigabytes of main memory, you will still have memory management issues, and using processes and threads provide the tools for optimizing these memory management issues, so it is important that you understand how processes are handled in Android. In case you are wondering, a 32-bit OS will only address 3.24 MB of system memory, so Pre-Android 5 devices only have 1 to 3 megabytes! The 64-bit version of Android (5, 5.1, 6, 7, 7.1.1 and later) is based upon 64-bit Linux and 64-bit Java, and has no memory limitation.The way that the Android OS determines which of its processes to keep, and which of its processes to terminate, is via a priority hierarchy. Android will place each running process into this priority hierarchy, which is based on each of the components running in the process queue , as well as the current status (running, idle, or stopped) of those application components. The way that Android removes processes from this process priority hierarchy, which is ultimately how memory is cleared, and reallocated, for any Android device, is that the process with the lowest priority (or least importance) is terminated first. Then the next lowest priority process is terminated, then the next lowest, until system resources that are needed for a higher priority process have been recovered for use.There are five process priority levels in this priority hierarchy. Once you know what these are, you will see how practical the process priority hierarchy is, and you’ll have an overview of how Service subclasses (background processing) or Activity subclasses (user interfaces) fit into this process priority schema. Let’s get into this now, before we take a look at how to implement a Service using XML markup and Java code.This process (threading) information is quite important to understand for any Android developer at any level, from Absolute Beginner through an Expert Professional, even if you don’t implement custom processes in your Android 7 applications. The five process priority levels are summarized in Table [13-1](#Tab1) for your quick reference.Table 13-1.Android’s five process priority levels , and what type of priority characteristics they exhibit regarding an app

<colgroup><col> <col></colgroup> 
| 进程优先级 | 特性 |
| --- | --- |
| 前台进程 | 当前正在处理用户界面和内容的主进程 |
| 可见流程 | 对屏幕上可见内容仍有影响的第二个过程 |
| 服务流程 | 包含当前正在处理的后台处理服务的已启动进程 |
| 后台进程 | 包含当前在设备屏幕上不可见的活动的流程 |
| 清空流程 | 当前不包含任何活动应用程序组件的进程 |

Let’s take a look at each of these in greater detail, so you better understand what these priority levels represent.

#### 前台进程

The highest priority process level is called the foreground process. This is the primary process that is currently running (actively processing), and that is required for the application task that the user is currently engaging in.A process will be considered a foreground process if it contains an activity (user interface) that a user is actively interfacing with, or if it hosts a service which is bound to that activity that the user is interfacing with. Note that an activity (subclass) in Android OS in an Activity, and that a service (subclass) in Android OS is a Service.A process will also be considered to be a foreground process if it is actively processing a Service subclass that is running in the foreground, which means that the Service object generated by your subclass implementation has already called the .startForeground() method.If the Service object is currently executing one of the .onCreate(), .onDestroy(), or .onStart() Service life cycle callbacks, which you will be learning about during this chapter, or is broadcasting a BroadcastReceiver object that is calling its .onReceive() method, it will be given a top foreground process priority-level status in Android.In an optimal Android operating system scenario, only a few foreground processes will be running at any given time. This is not common as Android device users tend to invoke several different applications and functions at the same time, which is why devices such as smartphones often become hot and lose their power charge rapidly. Regardless of proper use (or overuse), Android processes will be terminated only as a last resort, if the system memory gets scarce, and the Android OS cannot continue to run optimally.

#### 可见过程

The next highest priority process level is a visible process. This is a process that doesn’t contain any foreground process components, but that can still affect what the users are seeing on their displays. A process is deemed to be visible if it contains an activity that is not in the foreground, but that is still visible to the user display screen. An example of this would be an activity whose . onPause() method has been invoked. Another example would be a foreground process activity that starts a dialog that permits another activity to be seen in the background.A process that contains a Service subclass that has been bound to a visible process would also be able to get visible process priority. A visible process is considered to be almost as important as a foreground process. Thus a visible process is not terminated, unless that is absolutely required to keep all foreground processes running in the Android OS memory space. Visible and foreground processes are thus extremely similar in the Android OS.

#### 服务过程

The middle priority process level in the five levels is a Service process. This is a process that contains a Service that has been started with the . startService() method call, but that Android has not classified in either of the two higher-process priority-level categories. The Service class processes, because they have no user interface screen, and are running asynchronously in the background, are not directly tied to anything that a user sees on a display, or interacts with. They are important to Android apps development, which is why I cover them in this chapter.Since a Service is still performing a task that the end user wants to complete, such as playing an album of music in the background, or downloading a file over their network, Android will keep a process that contains a Service object active, unless there is not enough memory to support them along with foreground and visible processes.

#### 后台处理

The second lowest priority process level is the background process. This is a process that contains an Activity subclass that is not currently visible to the end user. An example of this is when the Activity subclass . onStop() method has been called. Note that a background process by its very nature should not affect the user experience.Since a background process has no detectible impact on user experience, Android will terminate these whenever it becomes necessary to recover system memory for any higher priority-level process (foreground, visible, or Service). If there are several background processes running, Android keeps background processes in something called the LRU (Least Recently Used) list. This list guarantees that a process containing the Activity most recently utilized by the user is the last process to be terminated.Note that Activity subclasses that implement their life cycle methods correctly, and save their current states using the savedInstanceState Bundle object, will not have any discernible effect on user experience due to termination. This is because when a user navigates back to their UI screen for that Activity, a process will again be started for it, and your Activity subclass will restore all of its visible states. This is done by reloading your savedInstanceState Bundle object.

#### 空进程

The lowest priority process level is the empty process. This is a process that does not hold any currently active application components. If you are wondering why these empty processes would be kept in system memory at all, the strategic reason to keep the empty process alive is for memory caching optimization, which improves the startup time the next time a component, most probably an Activity, needs to be loaded (run) inside the process.The Android operating system will terminate these empty processes once system memory is full in an attempt to balance the overall system memory resources between the various process caches, and with its underlying Linux OS kernel memory caches, which are at such a low level that Android 7.1.1 developers cannot directly access them.

#### 优先级排序的增加

It is important to notice that process priority-level rank might be increased because another process is dependent on a process. Any Android process that is currently servicing another process cannot be ranked lower than the process that it’s servicing. This is a very logical ranking behavior, if you think about it for a minute.Let’s say your content provider (which is a database or data store, which we will be covering in more detail in the next Chapter [14](14.html)) that is contained in Process 01 is busy providing content to a user interface Activity in Process 02, or a Service object in Process 01 is bound to an application component in Process 02\. In these scenarios, Process 01 will always be considered by Android OS to be as important as Process 02\. This is logical because the two processes are acting together as one unified user experience, and thus should be ranked equally.The next section takes a bird’s-eye view at threads, which are even lower level than processes, and can be utilized within a process (but only implemented using Java 8 code) to schedule processor-intensive or user interface tasks. This is very advanced information, and only included in this book so that you have a comprehensive overview of this “under the hood” programming topic. It is not expected that, as an Android 7.1.1 Absolute Beginner, you will write Java 8 code that controls thread execution.

### 线程警告:不要干扰 UI 线程

After Android launches your application, using the AndroidManifest.xml file, the operating system will spawn a thread of execution. This main thread is in charge of dispatching and managing system-level and application-level events, which you learned about during Chapter [7](07.html). The events take place between the operating system and your app, such as an incoming phone call, as well as between your user interface widget event handlers and your application Java 8 logic, like clicks on an animal image to trigger audio.The main thread also controls drawing graphics, playing video, audio, or animation assets to an Activity display screen, so it’s doing a lot of processing. This is a reason you might need to spawn your own thread, if something you want to do with your Android application might overload the heavy workload that is on the main (primary) thread. Unless (or until) you spawn your second thread, the main thread will be running your entire application.The main or primary thread is also often referred to as the UI thread, or user interface thread . This is because it’s the thread inside of which the application components interact with components in the Android UI toolkit. The Android UI toolkit includes all the components, as classes, contained in the android.widget as well as the android.view packages, which you learned about during Chapters [6](06.html) through [9](09.html). All of these Android UI toolkit components will run inside of, or under, this main process, and are handled (managed) inside of this UI thread.For this reason methods that respond to event handling callbacks, such as the .onKeyDown() event handler used to report keyboard hardware interaction, or one of the life-cycle callback methods, such as the .start() method or the .pause() method, will always run inside the UI thread. This UI thread is contained within the main process for your Android 7.1.1 application. When the application dispatches intensive processing in response to user interface interactions, a single thread model can result in a slow user experience performance. This is why you must learn how to utilize threads properly, if you are going to do advanced Android application development in the future.The reason for this is obvious. If extensive processing is happening in your UI thread, performing long-winded operations, such as network access, complex calculations, or SQLite database queries, this will block some portion of the user interface response processing. These more complex operations will reduce the amount of processing cycles that are available to the UI, and will essentially block the UI-related events from being smoothly, that is, quickly, processed. When application UI threads become blocked, UI events cannot be dispatched for handling, and this includes drawing graphics, playing samples, and animating elements to the display screen. From a user experience standpoint, an application may appear to hang, which is not desirable and is not at all professional.It is important to note that if your application blocks the UI thread for more than a few seconds (more than five seconds, actually) the user will be shown a dialog containing an undesirable (from a user experience standpoint) “Application is Not Responding” dialog (developers often abbreviate this, and call it the “A N R”dialog). It is important to note that the Android 7.x UI toolkit is not currently what is known as thread-safe. For this reason, you should not at any time manipulate your application’s user interface elements from inside a worker thread.A worker thread is any non-UI thread, and is also commonly referred to as the background thread. In other words, it is a thread that you have spawned using your application’s Java code. This would be done in order to off-load intensive, worker bee background processing, so that your UI will continue to function smoothly.Just remember, the first rule of Android thread processing is that you must do all manipulation to your user interface elements from the inside of the UI thread, which is the application’s main, or primary, thread.The second key rule is more general, and it is simply to not block the UI thread at any time for any reason. This is why you are able to create worker threads, in case you need to do something that may block the UI thread. By block, I mean to stop a UI thread from smoothly processing the application UI functions and content rendering.

### Android 应用应该使用服务还是线程？

An Android Service is an application component that can run in the background, even when your users are not interacting with the application. If you need to perform work outside of your main UI thread, but only while the user is interacting with the application user interface, that is when you should create an Android Thread object within that class in your application. This is commonly used for more advanced applications, such as 3D games.This would be done by instantiating a HandlerThread or an AsyncTask object. If you declare a Thread object in your class, you do not have to go to the trouble of declaring an entire Android Service subclass in the manifest. If you look at it using the “static versus dynamic” standpoint, which I have been teaching you over the course of this book, you are implementing a thread dynamically, in Java 8 code, whereas you implement a Service statically, using XML markup to declare it before use in your Android manifest XML file, so Android can optimize it!Let’s say that you wanted to stream some music from a music Service while your Activity is running. What you do is create a Thread object using the .onCreate() method, start it running using the .onStart() method, and stop it by using the .onStop() method. As mentioned, you will probably want to utilize a more refined Android Thread subclass, such as the AsyncTask or HandlerThread class, instead of using a more general Thread class, which is generally used as a superclass in order to create more application-friendly thread-related subclasses.So when would you use Service subclasses over spawning Thread objects in existing classes, you might wonder? If you remember from the previous section, Android processes containing a Service subclass will be prioritized higher than processes that utilize a background processing activity (Thread object). For this reason, if your apps are going to undertake extensive processing, access, or streaming operations, then you’ll want to start a Service component subclass for that operation, rather than simply create a Thread subclass object like an AsyncTask.This is an especially relevant consideration if your background process is going to outlast your Activity screen. As an example, an Activity that is uploading a video that you created using the Android Camera class to a web server would want to utilize the Service subclass methodology to perform this upload. This is so that this upload process will continue in the background and finish uploading even if the user leaves that video capture Activity.Thus, the primary reason that you will want to use a Service subclass over a Thread object, is because using the Service component will guarantee that your processing operation will have at least the Service process priority level, regardless of what happens to your Activity subclass. If you use the Thread subclass approach, your application could drop below the Service process priority-level based upon your end user’s usage or interaction, because with that approach, your Activity subclass only contains a Thread subclass and not a Service subclass.Next, you will learn how to write a Service subclass, and how to call it, using an Intent object. You will do this using the ScrollingActivity Activity subclass that you created in Chapter [12](12.html). You will implement the Android Service class life cycle by creating an ambient background audio player background Service component named AmbientAudioService.java.This will be a Service subclass that will extend the Service class, by utilizing the Java extends keyword inside of the class declaration. You will code the main Service class life cycle methods in your Java code, including onCreate(), onStart(), and onDestroy() methods. You will leverage an Android Intent object in one of these in order to start a background Service, which will play background audio for that DigitalAudioSequencer Android application project you created in Chapter [12](12.html).Finally, you will also look at how to add the <service> tag to the AndroidManifest.xml file, and you’ll test your background audio Service subclass inside of your Nexus 5 AVD emulator. This will show you how to mix audio using SoundPool (Chapter [12](12.html)), MediaPlayer (Chapter [11](11.html)), and Service (Chapter [13](13.html)) Android superclasses.As you can see, you are learning more advanced topics and techniques as this book progresses, as I am attempting to take you from an Absolute Beginner, to someone who is familiar with how Android works, what Android Studio can do, and how advanced you can become during your journey from Absolute Beginner to a working Android developer. To do this, I must cover some topics beyond the Absolute Beginner experience level.

## 创建服务:AmbientAudioService

Let’s take a look at how you can direct Android Studio to code a Service class for you, using the Android Studio 2.3 IDE, along with the proper work process, which can be seen in Figure [13-1](#Fig1).

1.  1。在 Android Studio 2.3 中打开您的 DigitalAudioSequencer 项目，并右键单击项目窗格的/app/Java/com . example . user . digital audio sequencer/文件夹，因为这是您希望 Android Studio 创建的这个AmbientAudioService.java文件所在的位置。
2.  2。接下来，选择新➤服务➤服务菜单序列，如图左侧 [13-1](#Fig1) 所示。
3.  3。该菜单选择将打开新 Android 组件-配置组件对话框，如右侧图 [13-1](#Fig1) 所示。
4.  4。命名您的服务子类 AmbientAudioService 并选中类名字段下方的启用复选框，取消选中导出复选框，因为只有这个数字音频序列器项目将使用这个服务子类。
5.  5。最后点击完成按钮，这会告诉 Android Studio 为你生成代码，并在 Android Studio 中打开一个名为AmbientAudioActivity.java的标签页，带有引导代码。我们将通过检查代码，然后修改代码以适应该代码的特定环境音频背景应用程序，来了解更多有关该服务的特征。![A324674_4_En_13_Fig1_HTML.jpg](A324674_4_En_13_Fig1_HTML.jpg)图 13-1。使用新➤服务的➤服务菜单序列，并在配置组件中命名类 AmbientAudioService
6.  6。看一下 AmbientAudioService 类 Java 代码，如图 [13-2](#Fig2) 所示，我们将在本章的剩余部分为其添加功能，在此之前，我们将仔细研究一些与 Android 服务相关的服务类的相关细节。![A324674_4_En_13_Fig2_HTML.jpg](A324674_4_En_13_Fig2_HTML.jpg)图 13-2。Android Studio 使用 Android 服务超类创建您的引导 AmbientAudioService 子类
7.  7 .。首先查看 import 语句，确定使用了哪些 Android 类来使这个服务子类工作。第一个是这个类所基于的服务超类，所以显然我们需要那些方法、常量等等，它们在 android.app 包中。 Intent 类中的第二个，这样我们可以使用 Intent 对象来触发服务。第三个是 IBinder 类，这样，如果您需要创建一个绑定服务，您可以创建 iBinder 对象，以便与public I binder onBind(Intent Intent)方法结构一起使用，该方法结构也是在这个 bootstrap 类中为您提供的，以防您想要使用它。
8.  8。在导入语句之后，我们使用公共类 AmbientAudioService 扩展服务 Java 语句将类声明为公共并扩展服务。
9.  9。在类声明之后，Android Studio 用这个空的 Java 方法声明写了一个(空的)必需的构造函数方法和体:public AmbientAudioService(){...}
10.  10。如你所见，Android Studio 为你提供了实现基本服务子类所需的一切代码基础设施，这对于绝对初学者来说是一个很好的开端。我们将在这个类中添加对象和方法来实现一个可以作为后台服务播放的 MediaPlayer 。

Next, let’s take a look at how your Android manifest needs to be set up for a Service class, and any Service subclass that you utilize or create, such as the one we will be creating during the rest of this chapter, to function.

### 配置 AndroidManifest 以添加一个

Whenever you add an Android Activity, Service, content provider, or broadcast receiver component into your Android application, you need to declare it for use inside of your Android manifest XML file, which is utilized to define, configure, secure, permission, optimize, specify (hardware device support in the Google Play store), and launch the Android application.We will take a look at this as it relates to Service, using the <service> tag, next, and see if Android Studio 2.3 added the correct markup to the AndroidManifest.xml. Right-click on your AndroidManifest.xml file, which is inside of the project’s /app/manifests/ folder, and select Jump to Source. Inside of the <application> tag, there should be a child <service> tag after the first <activity> tag and before closing </application> and </manifest> tags.The <service> tag Android Studio inserted should implement the android:name=".AmbientAudioService" parameter, which allows Android OS to wire up the Service subclass that will utilize the Service object. Based on your dialog selections, Android Studio also included an android:enabled="true"and an android:exported="false"parameter, to keep your Service private, as a standard security measure, unless you’re creating a Service for other apps to use. The <service> tag should look like the following markup:<serviceandroid:name=".AmbientAudioService"android:enabled=”true”android:exported="false” ></service>The Android Studio modified AndroidManifest.xml file Service markup is shown highlighted in orange and blue at the bottom of Figure [13-3](#Fig3).![A324674_4_En_13_Fig3_HTML.jpg](A324674_4_En_13_Fig3_HTML.jpg)Figure 13-3.Open AndroidManifest.xml file to see how Android Studio added a <service> tag under the <application> tagNext, let’s take a closer look at the Android Service class, and see what we are allowed to add to the basic Service class Java code that is seen in Figure [13-2](#Fig2) to create a MediaPlayer background digital audio player Service subclass, using our bootstrap AmbientAudioService class Android Studio just created.

## 服务:后台处理服务

The public abstract class Service extends the ContextWrapper class and implements the ComponentCallbacks2 interface. This is the base class for all Service subclasses. Service has 33 known direct subclasses, which you can use directly, or you can subclass Service and code your own, as we are going to do. Its class hierarchy looks like the following:java.lang.Object> android.content.Context> android.content.ContextWrapper> android.app.ServiceWe will use a simple but popular example of how to use a MediaPlayer inside of a Service to play a one megabyte one minute MPEG4 audio in a seamless loop, just to give you an idea regarding how a Service works.

## 配置 AmbientAudioService:播放音频

Let’s go into your bootstrap AmbientAudioService.java class, which Android Studio has written for you, and customize it to play a short ambient background audio loop using the Android MediaPlayer class and a one megabyte, highly optimized, MPEG-4 digital audio asset. I am doing this here as a follow-on to Chapter [12](12.html), using the same project, to show you how to provide looped long-form background audio for the animal samples.

1.  1。在你的 AmbientAudioService 类的顶部声明一个 MediaPlayer 对象，就在类声明之后，如图 [13-4](#Fig4) 所示。如果您键入“MediaP”，您将获得一个弹出助手，您可以双击media player(Android . media)选项。Android Studio 随后会为您添加这个对象声明，并且会额外编写您的import Android . media . media player；语句，可以在图上方的 [13-5](#Fig5) 中看到。![A324674_4_En_13_Fig4_HTML.jpg](A324674_4_En_13_Fig4_HTML.jpg)图 13-4。在 AmbientAudioService 类的顶部声明一个 MediaPlayer 对象，命名为 ambientAudioPlayer![A324674_4_En_13_Fig5_HTML.jpg](A324674_4_En_13_Fig5_HTML.jpg)图 13-5。在 AmbientAudioService()构造函数下面添加一行，键入" on "，并选择 public void onCreate()方法
2.  2。将这个MediaPlayerobjectambientAudioPlayer命名为，并用分号结束 Java 声明。可以看到完成的media player ambientAudioPlayer；申报图中的 [13-6](#Fig6) 。![A324674_4_En_13_Fig6_HTML.jpg](A324674_4_En_13_Fig6_HTML.jpg)图 13-6。在 onCreate()方法中的 super.onCreate()方法后添加一个 ambientAudioPlayer MediaPlayer 对象
3.  3。下一步是添加一个 onCreate() 方法结构，您将在其中实例化您的 MediaPlayer 对象。在 Android Studio 为您创建的 AmbientAudioService() 构造函数方法下添加一行代码，键入“on”，在弹出的帮助器下拉菜单中双击 public void onCreate() {} 选项，将其插入到您的类体中。Android Studio 将为该类编写一个 bootstrap onCreate() 方法，看起来应该像下面的 Java 代码结构:public void onCreate(){super。onCreate()；}
4.  4。在 super.onCreate() 下面添加一行代码；超类方法调用并键入单词“ambient”，然后双击ambientAudioPlayer media player选项来插入 MediaPlayer 对象，这样就可以使用等号和来实例化它。create() 方法。
5.  5。添加等号后，再键入“Me”，这样就会出现 Android Studio 的弹出编码助手下拉菜单。注意，列表中有一个选项，可以对整个对象以及实例化 MediaPlayer 对象所需的方法调用(包括点符号)进行编码。
6.  6。选择你的media player . create(Context Context，int resId) (android.media) 选项，如图 [13-7](#Fig7) ，双击这个，告诉 Android Studio 2.3 为你编写这个实例化的 Java 代码结构。您将使用 Java this 关键字来传递当前类的上下文对象，以及 /app/res/raw 资源 ID 路径到 ambient.m4a 文件，使用 R.raw.ambient 作为第二个方法参数。这将实例化 MediaPlayer ，然后你接下来要做的就是配置 MediaPlayer 对象，我们可以继续创建一些其他的类方法来启动 MediaPlayer ，停止 MediaPlayer ，并在应用程序使用完毕时销毁(从系统内存中删除) MediaPlayer 对象。![A324674_4_En_13_Fig7_HTML.jpg](A324674_4_En_13_Fig7_HTML.jpg)图 13-7。选择 media player . create(Context Context，int resid) (android.media)选项，进行代码实例化
7.  7。将 ambient.m4a 音频资产从图书仓库复制到 DigitalAudioSequencer 项目 app/res/raw/ 文件夹中。我在这里省略了这个图，因为你已经在前面的一些章节中看到了如何去做。该资产将出现在 Android Studio 2.3 中，如图 [13-8](#Fig8) 左侧所示。![A324674_4_En_13_Fig8_HTML.jpg](A324674_4_En_13_Fig8_HTML.jpg)图 13-8。添加 ambienaudioplayer . set looping(true)方法调用来完成你的 onCreate()方法结构
8.  8。一旦音频资产对 Android Studio 可见，您就可以在您的 MediaPlayer(Context，ResourceID) 代码构造中引用数字音频资产。将 Java this 关键字和资源路径添加到中。create() 方法，然后添加一个。setLooping() 方法，并将其设置为布尔值 true 来配置 MediaPlayer 循环播放背景音频。完成配置后，Java 方法结构应该如下所示:@ Overridepublic voidonCreate(){super。onCreate()；ambientAudioPlayer = media player。创建 ( 本，r . raw . ambient)；ambientaudiolayer。设置循环 ( 真)；}T51】
9.  9。当您在 MainActivity 的 onCreate() 方法中使用 startService() 方法调用时，将会调用您的 onStartCommand() 方法的内容，我们接下来将在这里添加这些内容。这相当于在 onStartCommand() 方法中添加了一个 MediaPlayer.start() 方法调用。在您的 onCreate() 方法构造下添加一行代码，再次键入“on”，并选择public int onstart command(intent，flags，startId) {...} 选项，然后双击它，让 Android Studio 2.3 在ambienaudioservice类内部对其进行编码，如图 [13-9](#Fig9) 所示。![A324674_4_En_13_Fig9_HTML.jpg](A324674_4_En_13_Fig9_HTML.jpg)图 13-9。添加一行文本，键入" on "，并选择服务类 onStartCommand (intent，flags，startId)方法调用
10.  10。Android studio 将对您的 onStartCommand()方法进行编码，如图 [13-10](#Fig10) 所示，包括一个return super . onstart command(intent，flags，startId) 语句直到超类，传递所有进入该方法调用的参数。添加您的 ambientAudioPlayer 对象，然后点击句点键，并选择一个 void start() 方法调用选项。在您的 return 语句之前执行此，因为在 return 之后的任何代码都不会被执行。![A324674_4_En_13_Fig10_HTML.jpg](A324674_4_En_13_Fig10_HTML.jpg)图 13-10。在 return 语句前添加一个 ambientAudioPlayer 对象，键入一个句点，并选择一个 start()方法
11.  11。添加完 ambientAudioPlayer 代码语句后，方法如下:@ Overridepublic intonstart command(Intent Intent，int flags，int startId){ambientAudioPlayer。启动()；返回super . onstart command(intent，flags，startId)；}
12.  12。接下来，在 onStartCommand() 方法后添加一行代码，并键入“on”，如图 [13-11](#Fig11) 所示，并拥有 Android Studio 代码的主体 public void onDestroy() {...} 方法给你。![A324674_4_En_13_Fig11_HTML.jpg](A324674_4_En_13_Fig11_HTML.jpg)图 13-11。添加一行文本，键入" on "，并选择 public void onDestroy()方法从服务超类中调用
13.  13。on destroy()方法中的第一条语句应该停止 MediaPlayer 播放你的环境音频循环，使用ambientaudioplayer . stop()方法调用，如图 [13-12](#Fig12) 所示。![A324674_4_En_13_Fig12_HTML.jpg](A324674_4_En_13_Fig12_HTML.jpg)图 13-12在 super.onDestroy()方法调用前添加一个 MediaPlayer 对象。停止( )和。release()方法调用
14.  14。on destroy()方法中的第二条语句应该使用ambientaudioplayer . release()方法从系统内存中删除 MediaPlayer 对象，该方法为其他 Android 操作系统或应用程序释放系统内存。
15.  15。确保super . on destroy()；方法调用是最后一个，因为您希望 MediaPlayer 对象在您希望 Service 对象停止并释放自身之前停止并释放，这是使用完成的。onDestroy() 方法调用。您完成的代码将如下所示:@ Overridepublic voidon destroy(){ambientAudioPlayer。停止()；ambientaudiolayer。释放()；超级。on destroy()；}

You have now coded your first Service subclass, which is shown in its finished form in Figure [13-13](#Fig13). It has onCreate(), onStartCommand(), and onDestroy() methods that create, start, and stop/remove the MediaPlayer object from system memory based on the same three life cycle stages of the Service object itself. Pretty cool.![A324674_4_En_13_Fig13_HTML.jpg](A324674_4_En_13_Fig13_HTML.jpg)Figure 13-13.The completed AmbientAudioService class, customized to implement the basic MediaPlayer functionalityNext, let’s take a look at the ScrollingActivity class and see exactly what Java code we need to add to that class in the onCreate() method, in order to start this Service, and have it play background ambient audio for this Android application.

## 启动服务:使用。startService()

Now that you have created your AmbientAudioService Service subclass, and declared it for use in your Android manifest XML file, you are ready to start it by using the .startService() method that you learned about earlier in the chapter. This is done using an Intent object, in a very similar fashion to starting up an Activity, which you have done already, so this should be familiar to you. Let’s get right into the Java 8 programming part of your scrolling Activity class, which will contain a startService() method call, as the very last step in your onCreate() method.

1.  1。单击ScrollingActivity.java选项卡，在 onCreate() 方法的末尾添加一行代码，以便在启动应用程序之前启动ambienaudioservice服务子类(对象)。如图 [13-14](#Fig14) 所示，输入“star”，从下拉帮助菜单中选择startService(Intent service)component name选项。![A324674_4_En_13_Fig14_HTML.jpg](A324674_4_En_13_Fig14_HTML.jpg)图 13-14。在 onCreate()方法的底部添加一行代码，键入 star，然后双击 startService()
2.  2。在 startService() 方法参数区域内，我们将通过键入 Java new 关键字，然后键入 Intent 来嵌套另一个 Java 构造(或者在您的助手下拉菜单中键入“In”并选择 Intent )。
3.  3。在您的 Intent() 构造函数方法参数区域内，键入 Java this 关键字，以传递 ScrollingActivity 类上下文对象，然后是一个逗号，然后是您想要启动的服务子类的名称，在本例中，它将是ambientaudioservice . class。你的 Java startService() 方法调用语句，一旦完全完成，如图 [13-15](#Fig15) 所示，并且应该看起来像下面的 Java 代码:![A324674_4_En_13_Fig15_HTML.jpg](A324674_4_En_13_Fig15_HTML.jpg)图 13-15。startService()内部实例化一个新的 Intent 对象传递 Context (this)和 ambientaudioservice . classstartService(newIntent(this，ambientaudioservice . class)；T52】
4.  4。现在您已经准备好使用运行➤运行‘app’菜单序列并测试 Nexus 5 AVD 中的代码。应用程序现在调用服务，如图 [13-16](#Fig16) 中以淡黄色和蓝色突出显示的，并播放动物样本后面的背景音乐，当它们通过 SoundPool 触发时，它们与背景中的环境音轨完美混合。我将放弃截图，因为应用程序看起来与第 [12](12.html) 章中的一样。![A324674_4_En_13_Fig16_HTML.jpg](A324674_4_En_13_Fig16_HTML.jpg)图 13-16。已完成的 ScrollingActivity.java 类代码用 startService()结束，onCreate()方法

You now have a high-level overview of background processing in Android, and have created a Service subclass.

## 摘要

In this chapter, you learned about the Android Service component subclasses as well as about processing concepts, principles, prioritization, and optimization. You learned about Thread objects, and how these threads differ from Service components. You learned all about different types of Android Services, including started Services, bound Services, and a hybrid between these two types, as well as about scheduled Services, characteristics of Services, caveats about using Services, and when to utilize a Service subclass versus using a Thread class based object.You learned about processes as well, and how to spawn your own process in your Android manifest XML file. You learned how to assign different application components to their own process (shared memory), by using the android:process parameter inside of your parent <application> tag or its child component tags, such as <activity>, <service>, <provider>, or <receiver>.You created your own Service subclass called AmbientAudioService to start a MediaPlayer object (and stop it on exit) so that you could play ambient background audio effects while your SoundPool effects are being triggered by your users. Then you wrote Java code that called the Service subclass from the ScrollingActivity subclass using the startService() method.In Chapter[14](14.html), you will learn all about content provider classes in Android, which is an advanced area that includes SQLite database technology. I saved the most complicated chapter for last. As you can see, I am as always trying to cover things in the most logical, optimal fashion, as you progress through this journey to learn Android.