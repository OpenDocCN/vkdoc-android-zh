## 第四章

## 绘制环境

在这一章中，你将学习如何渲染游戏的背景。背景为游戏设定了基调和环境。对于星际战士来说，这个环境将会是一个由恒星、行星、宇宙飞船和残骸组成的背景。您将使用 OpenGL 将背景设置到游戏中，并渲染到屏幕上。

鉴于单一背景已经相当令人印象深刻，那么两个背景一定是两倍。嗯，不完全是这样——但是两个不同速度的背景给你的游戏带来了视觉深度，会非常有趣。你将在游戏中添加第二层背景，滚动速度将比第一层更快。

在本章的后面，你将从游戏设置中休息一下，让你的游戏以每秒 60 帧的速度运行。虽然许多设备可能无法以每秒 60 帧的速度运行完整的游戏，但这是大多数游戏开发者的目标。

无论你的游戏有多好，如果玩家不能使用它，它就没有任何意义。因此，在这一章中，你还将修改你的主菜单，使之能够在玩家选择开始选项时启动游戏。

到这本书的这一点，你应该有一个工作的闪屏，淡入游戏的主菜单和一些循环的背景音乐。这是一大成就；然而这一章的代码会更复杂。同样，你可以随意跳过这一章，但是要意识到大多数的例子都是累积的，因为它们都建立在前面的例子中。

最后，在这一章中，你将被介绍到大量的 OpenGL。我确实意识到大多数普通的 Android 开发人员可能没有接触过太多的 OpenGL。在你阅读本章的过程中，我会尽可能多地给出 OpenGL 的背景和说明。

说了这么多，让我们直接开始画游戏的背景。

### 渲染背景

在前一章中，你使用了 Android 的`ImageView`来显示一个位图作为游戏的闪屏。对于闪屏和主菜单来说，这是一个可以接受的解决方案。但是在这个过程中有太多的开销并且没有足够的灵活性来将其用于游戏的图形。如果你想办法用这个过程来显示你的游戏图形，游戏会运行得很慢，如果它能加载的话。

要快速将这个游戏的背景绘制到屏幕上，你需要一个既轻便又灵活的工具。幸运的是，Android 已经实现了这样一个工具:OpenGL ES。OpenGL ES 是嵌入式系统的 OpenGL 标准(为了便于讨论，我在本书中只将其称为 OpenGL)。从第一个 SDK 版本开始，它就以各种形式出现在 Android 上。OpenGL 提供了一种有用的、灵活的、相当成熟的处理游戏图形的方法。

一开始，OpenGL 在 Android 上的实现有很多问题，而且不像其他系统那样功能丰富。然而，随着更多 Android 版本的出现，OpenGL 的实现变得更加坚实。这并不是说现在还没有——在这一章中，你至少会学到一个重要的 OpenGL bug。

你将为*星际战士*创建一个相当复杂的双层、重复、滚动的背景。具体来说，您将看到一个滚动(并重复)的更大的背景图像，它与以更快速度移动的第二个滚动图像部分重叠。这将使背景看起来复杂，具有三维效果。[图 4–1](#fig_4_1)显示了背景完成后的样子。

![images](images/0401.jpg)

**图 4–1。** *完成后的背景*

首先，你需要一个新的活动来运行你的游戏。当玩家点击你在前一章的主菜单中创建的开始按钮时，这个活动就会启动。

#### 创造创造创造

游戏活动是当你开始你的实际游戏时将被启动的 Android 活动，至少是玩家将实际玩的游戏的一部分(相对于闪屏或主菜单)。虽然启动画面和菜单看起来像是游戏的一部分，但就本章的目的而言，你是根据功能将它们分开的。

到目前为止，您已经创建了游戏的几个关键特性，但是您还没有编写任何支持游戏运行的代码。这种情况现在将会改变。您将创建运行*星际战士*游戏的活动。

在主包中创建一个名为`SFGame.java`的新类。创建类后，在 Eclipse 中打开它。应该是这样的:

`package com.proandroidgames;

public class SFGame {

}`

注意:请记住，如果您没有按顺序阅读本书，您在这里看到的代码可能与您的不同，因为您可能用不同的包或类名创建了您的基类。

修改您的`SFGame`类来扩展`Activity`，并包含任何未实现的方法。

`package com.proandroidgames;

import android.app.Activity;
import android.os.Bundle;

public class SFGame extends Activity {

@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView();
}

}`

**提示:**此时，您应该按照上一章中的指示，使用`AndroidManifest`将`SFGameActivity`与`StarFighter`项目关联起来。

按原样保存该文件。它现在做不了什么。事实上，它仅仅是一个活动的外壳，如果您现在运行它，您将幸运地得到一个空白屏幕，但是您很可能会收到一个漂亮的语法错误。

您需要构建一个视图，让`SFGame`活动能够显示。视图将调用将游戏显示到屏幕上。`SFGame`活动是视图到达屏幕的管道。

让我们来谈谈接下来会发生什么。

##### 创建游戏视图

在《T2》第三章中，你使用了一个预制的 Android 视图`ImageView`来显示游戏的启动画面和主菜单。这是一种可接受的显示静态图形的方法。然而，你在这里创造了一个极限推动游戏。一个像`ImageView`一样有如此多开销和如此有限功能集的视图不会给你创造一个游戏所需要的灵活性。因此，你需要在别处寻找你的图形渲染工具。

Android 自带的 OpenGL 工具正好适合这项工作。您将使用 OpenGL 来显示和操作游戏图形。它为您提供了快速显示 2D 和 3D 图形所需的能力和灵活性，非常适合您正在编写的游戏。

如果您过去做过任何 Android 开发，您可能会使用画布绘制到屏幕上。OpenGL 有自己的画布类型，您需要使用它在屏幕上显示 OpenGL 图形。`GLSurfaceView`将允许你在屏幕上显示游戏图形。

至此，您已经创建了`SFGame`活动，但是您现在需要一些东西来显示它。让我们创建一个名为`SFGameView`的新类:

`package com.proandroidgames;

public class SFGameView{

}`

现在，修改这个类来扩展`GLSurfaceView`。

`package com.proandroidgames;

import android.opengl.GLSurfaceView;

public class SFGameView extends GLSurfaceView {

}`

创建了扩展`GLSurfaceView`的类后，您可以在您的`SFGame`活动中添加对它的引用。在前一章中，您将`StarFighter`活动中的`setContentView()`的值设置为一个布局。到目前为止，`SFGame`活动的`setContentView()`值还没有设置，或者设置为默认的`main`布局。但是，您可以将这个值设置为`GLSurfaceView`。将刚刚创建的`SFGamesetContentView()`设置为`SFGameView`将允许您开始使用和显示 OpenGL。

打开`SFGame`活动，并创建您刚刚创建的`SFGameViewGLSurfaceView`的实例。

`package com.proandroidgames;

import android.app.Activity;
import android.os.Bundle;

public class SFGame extends Activity {

private SFGameView gameView;

@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView();
}
}`

现在，实例化`SFGameView`，并将`setContentView()`设置为新的实例。

`package com.proandroidgames;

import android.app.Activity;
import android.os.Bundle;

public class SFGame extends Activity {
private SFGameView gameView;

@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
gameView = new SFGameView(this);
setContentView(gameView);
}
}`

这是足够使用`SFGameView`显示游戏的代码。然而，你需要提前考虑，当玩家使用它的时候，你的游戏会发生什么。如果你现在投入一些额外的时间，你可以非常简单地避免一些非常痛苦的头痛。

##### 使用 onResume()和 onPause()

可能发生的最常见的事情之一是玩家可以通过给予另一个`Activity`焦点来中断游戏。这可能是有意的——如果玩家开始另一项活动并给予关注——也可能是无意的——如果玩家在游戏过程中接到电话。如果处理不当，这两种情况都会对你的游戏造成严重破坏。令人惊讶的是，这两种情况很容易编码。

Android 提供了几个处理程序来应对你的活动可能被打断的情况。如果你的活动失去了另一个活动的焦点，不管是有意还是无意，Android 都会向你的活动发送一个暂停事件。当你的活动再次成为活动时，Android 会给它发送一个恢复事件。

`Activity`类可以实现`onPause()`和`onResume()`来处理这些情况。在您的`SFGame`活动中简单地覆盖这些，如下所示:

`package com.proandroidgames;

import android.app.Activity;
import android.os.Bundle;

public class SFGame extends Activity {

private SFGameView gameView;

@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
gameView = new SFGameView(this);
setContentView(gameView);
}
@Override
protected void onResume() {

}

@Override
protected void onPause() {

}

}`

现在，您可以添加一些代码，根据需要暂停和恢复您的游戏活动。

`package com.proandroidgames;

import android.app.Activity;
import android.os.Bundle;

public class SFGame extends Activity {
private SFGameView gameView;

@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
gameView = new SFGameView(this);
setContentView(gameView);
}
@Override
protected void onResume() {
super.onResume();
gameView.onResume();` `}

@Override
protected void onPause() {
super.onPause();
**gameView.onPause();**
}

}`

**注:**`onResume()`和`onPause()`功能指的是活动执行本身的暂停，而不是游戏的暂停。暂停游戏是分开处理的。

再次保存您的`SFGame`类。您现在有了一个显示`GLSurfaceView`的活动。您需要通过`SFGame`活动为`SFGameView`创建一些要显示的内容。你需要创建的是一个`GLSurfaceView`渲染器。

#### 创建渲染器

您创建的`GLSurfaceView``SFGameView`只是一个显示 OpenGL 的视图。`GLSurfaceView`需要渲染器的帮助来完成繁重的工作。理论上，你可以将渲染器整合到`GLSurfaceView`中。然而，我更喜欢代码的清晰分离，以区分不同的功能；这使得故障排除变得更加容易。

在您的`StarFighter`包中创建一个名为`SFGameRenderer`的新类。

`package com.proandroidgames;

public class SFGameRenderer{

}`

现在你需要实现`GLSurfaceView`的渲染器。

`package com.proandroidgames;

import android.opengl.GLSurfaceView.Renderer;

public class SFGameRenderer implements Renderer{

}
Be sure to add in the unimplemented methods:
package com.proandroidgames;

import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;

import android.opengl.GLSurfaceView.Renderer;

public class SFGameRenderer implements Renderer{` `@Override
public void onDrawFrame(GL10 gl) {
// TODO Auto-generated method stub

}

@Override
public void onSurfaceChanged(GL10 gl, int width, int height) {

}

@Override
public void onSurfaceCreated(GL10 gl, EGLConfig config) {

}
}`

这些方法的功能应该是不言自明的。当渲染器在屏幕上绘制一帧时，调用`onDrawFrame()`方法。当视图的大小已经改变时，调用`onSurfaceChanged()`方法，即使是在最初改变的时候。最后，在创建`GLSurface`时，调用`onSurfaceCreated()`方法。

让我们按照它们被调用的顺序开始编码。首先出场的是`onSurfaceCreated()`。

##### 创建您的 OpenGL 表面

在`onSurfaceCreated()`中，你将初始化你的 OpenGL 并加载你的纹理。

提示:用 OpenGL 的说法，纹理也可以是图像，就像你的背景一样。你将在本章的后面得到这个，但是从技术上来说，你将使用这个游戏的背景图像作为纹理应用到两个平面三角形上并显示出来。

第一步是启用 OpenGL 的二维纹理映射功能

`package com.proandroidgames;

import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;
import android.opengl.GLSurfaceView.Renderer;

public class SFGameRenderer implements Renderer{
@Override
public void onDrawFrame(GL10 gl) {
}
@Override
public void onSurfaceChanged(GL10 gl, int width, int height) {
}

@Override` `public void onSurfaceCreated(GL10 gl, EGLConfig config) {
**gl.glEnable(GL10.GL_TEXTURE_2D);**
}
}`

注意，`onSurfaceCreated()`将 OpenGL ( `GL10 gl`)的一个实例作为参数。当渲染器被调用时，这个实例将由`GLSurfaceView`传递给方法。您不必担心为此流程创建 GL10 的实例；它会自动为您完成。

接下来，你想让 OpenGL 测试你的表面中所有物体的深度。这需要一些解释。即使你正在创建一个 2-D 游戏，你也需要用 3-D 术语来思考。

想象一下，OpenGL 环境是一个舞台。你想在游戏中画的一切都是这个舞台上的演员。现在，想象你正在拍摄演员在舞台上走动的场景。最终的电影是正在发生的事情的二维表现。如果一个演员走到另一个演员的前面，那么这个演员在电影中是看不到的。然而，如果你正在看这些演员在剧院的现场表演，根据你坐的位置，你仍然可以看到后面的演员。

这和 OpenGL 的工作思路是一样的。即使你正在制作一个二维游戏，OpenGL 也将把所有的东西当作三维空间中的三维物体来对待。事实上，在 OpenGL 中开发 2d 和 3d 的唯一区别是你如何告诉 OpenGL 渲染最终的场景。因此，你需要注意你的物体在三维空间中的位置，以确保它们在二维游戏中正确的渲染。接下来通过启用 OpenGL 深度测试，你给了 OpenGL 一种方法来文本化你的纹理并决定它们应该如何被渲染。

`package com.proandroidgames;

import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;
import android.opengl.GLSurfaceView.Renderer;

public class SFGameRenderer implements Renderer{
@Override
public void onDrawFrame(GL10 gl) {
}
@Override
public void onSurfaceChanged(GL10 gl, int width, int height) {
}

@Override
public void onSurfaceCreated(GL10 gl, EGLConfig config) {
gl.glEnable(GL10.GL_TEXTURE_2D);
gl.glClearDepthf(1.0f);
gl.glEnable(GL10.GL_DEPTH_TEST);
gl.glDepthFunc(GL10.GL_LEQUAL);

}
}`

您将添加到该方法中的最后两行代码与混合有关。你现在不必太担心这个，因为你真的不会注意到这段代码的效果，直到本章的后面。你要在游戏中绘制的所有图像都要有透明的区域。这两行代码将设置 OpenGL 的混合功能来创建透明度。

`package com.proandroidgames;

import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;
import android.opengl.GLSurfaceView.Renderer;

public class SFGameRenderer implements Renderer{
@Override
public void onDrawFrame(GL10 gl) {
}
@Override
public void onSurfaceChanged(GL10 gl, int width, int height) {
}

@Override
public void onSurfaceCreated(GL10 gl, EGLConfig config) {
gl.glEnable(GL10.GL_TEXTURE_2D);
gl.glClearDepthf(1.0f);
gl.glEnable(GL10.GL_DEPTH_TEST);
gl.glDepthFunc(GL10.GL_LEQUAL);

gl.glEnable(GL10.GL_BLEND);
gl.glBlendFunc(GL10.GL_ONE, GL10.GL_ONE);
}
}`

##### 加载游戏纹理

在`onSurfaceCreated()`方法中你应该做的下一件事是加载你的纹理。然而，这将是一个有点复杂的过程，您将在下一节中处理它。现在，在代码中添加一个注释，表明您将回到这里，然后让我们继续讨论`onSurfaceChanged()`。

**注意:**你在游戏中添加的所有纹理都将被添加到`onSurfaceCreated()`方法中。

`public class SFGameRenderer implements Renderer{
@Override
public void onDrawFrame(GL10 gl) {
}
@Override
public void onSurfaceChanged(GL10 gl, int width, int height) {
}

@Override
public void onSurfaceCreated(GL10 gl, EGLConfig config) {` `gl.glEnable(GL10.GL_TEXTURE_2D);
gl.glClearDepthf(1.0f);
gl.glEnable(GL10.GL_DEPTH_TEST);
gl.glDepthFunc(GL10.GL_LEQUAL);

gl.glEnable(GL10.GL_BLEND);
gl.glBlendFunc(GL10.GL_ONE, GL10.GL_ONE);

//TODO Add texture loading for background image
}
}`

`onSurfacedChanged()`方法将处理显示图像所需的所有设置。每次调整屏幕大小时，方向都会改变，并且在初次启动时，会调用此方法。

你需要设置`glViewport()`并调用渲染例程来完成`onSurfacedChanged()`。

`glViewport()`方法有四个参数。前两个参数是屏幕左下角的 x 和 y 坐标。通常，这些值将是`(0,0)`,因为屏幕的左下角将是 x 轴和 y 轴相交的地方——各自的 0 坐标。`glViewport()`方法的下两个参数是视窗的宽度和高度。除非你希望你的游戏比设备的屏幕小，否则这些应该被设置为设备的宽度和高度。

`public class SFGameRenderer implements Renderer{
@Override
public void onDrawFrame(GL10 gl) {
}
@Override
public void onSurfaceChanged(GL10 gl, int width, int height) {

gl.glViewport(0, 0, width,height);
}

...

}`

注意，调用表面，在本例中是`SFGameView`，向`onSurfacedChanged()`方法发送`width`和`height`参数。您可以将`glViewport()`的宽度和高度设置为`SFGameView`发送的相应的`width`和`height`。

**注:**`SFGameView`发来的`width`和`height`将代表设备的宽度和高度减去屏幕顶部的通知栏。

如果`glViewport()`代表拍摄场景的镜头，那么`glOrthof()`就是图像处理器。设置好视口后，你现在要做的就是使用`glOrth0f()`渲染表面。

##### 渲染表面

要访问`glOrthof()`,你需要将 OpenGL 置于投影矩阵模式。OpenGL 有不同的矩阵模式，允许您访问引擎的不同部分。在这本书里，你会接触到大部分，如果不是全部的话。这是你第一次合作。投影矩阵模式允许您访问场景的渲染方式。

要进入投影矩阵模式，您需要将`glMatrixMode()`设置为`GL_PROJECTION`。

`public class SFGameRenderer implements Renderer{
@Override
public void onDrawFrame(GL10 gl) {
}

...

@Override
public void onSurfaceCreated(GL10 gl, EGLConfig config) {
gl.glEnable(GL10.GL_TEXTURE_2D);
gl.glClearDepthf(1.0f);
gl.glEnable(GL10.GL_DEPTH_TEST);
gl.glDepthFunc(GL10.GL_LEQUAL);

gl.glEnable(GL10.GL_BLEND);
gl.glBlendFunc(GL10.GL_ONE, GL10.GL_ONE);

//TODO Add texture loading for background image
}
}`

现在 OpenGL 处于投影矩阵模式，您需要加载当前身份。把身份想象成 OpenGL 的默认状态。

`public class SFGameRenderer implements Renderer{
@Override
public void onDrawFrame(GL10 gl) {
}

...

@Override
public void onSurfaceCreated(GL10 gl, EGLConfig config) {
gl.glEnable(GL10.GL_TEXTURE_2D);
gl.glClearDepthf(1.0f);
gl.glEnable(GL10.GL_DEPTH_TEST);
gl.glDepthFunc(GL10.GL_LEQUAL);
gl.glEnable(GL10.GL_BLEND);
gl.glBlendFunc(GL10.GL_ONE, GL10.GL_ONE);

//TODO Add texture loading for background image
}
}`

加载身份后，您可以设置`glOrthof()`，它将为您的场景设置一个正交的二维渲染。这个调用有六个参数，每个参数定义一个裁剪平面。

剪裁平面向渲染器指示停止渲染的位置。换句话说，任何落在裁剪平面之外的图像都不会被`glOrthof()`拾取。六个剪裁平面是左、右、下、上、近和远。这些代表 x、y 和 z 轴上的点。

`public class SFGameRenderer implements Renderer{
@Override
public void onDrawFrame(GL10 gl) {
}
@Override
public void onSurfaceChanged(GL10 gl, int width, int height) {

gl.glViewport(0, 0, width,height);

gl.glMatrixMode(GL10.GL_PROJECTION);
gl.glLoadIdentity();
**gl.glOrthof(0f, 1f, 0f, 1f, -1f, 1f);**

}

@Override
public void onSurfaceCreated(GL10 gl, EGLConfig config) {
gl.glEnable(GL10.GL_TEXTURE_2D);
gl.glClearDepthf(1.0f);
gl.glEnable(GL10.GL_DEPTH_TEST);
gl.glDepthFunc(GL10.GL_LEQUAL);

gl.glEnable(GL10.GL_BLEND);
gl.glBlendFunc(GL10.GL_ONE, GL10.GL_ONE);

//TODO Add texture loading for background image
}
}`

这就是你为游戏设置渲染和投影所要做的一切。继续并保存`SFGameRenderer`；您将在本章稍后回到`onDrawFrame()`。

设置好`onSurfaceCreated()`和`onSurfaceChanged()`方法后，您可以返回到添加到`onSurfaceCreated()`的注释。在本章的下一节，你将把你的背景图像作为一个纹理载入，并从`onSurfaceCreated()`调用它。

#### 使用 OpenGL 加载图像

OpenGL 中的图像是作为纹理加载的。这就是说，一个图像，任何你想用 OpenGL 显示的图像，实际上都被当作一个应用于 3d 对象的纹理。

在这个游戏中，你创建的是二维图形，但是 OpenGL 会把它们当作三维对象。因此，您将构建正方形和三角形来映射您的图像。一旦您的图像作为纹理映射到这些平面形状上，您就可以将它们发送到渲染器中。听起来真的比实际复杂。

让我们从将一个文件复制到 Eclipse 中作为背景开始。我使用的图像称为`backgroundstars.png`，如图 4–2 中的[所示。](#fig_4_2)

![images](images/0402.jpg)

**图 4–2***。背景图像*

如果你使用的是摩托罗拉 Droid 型号的手机，OpenGL 中有一个漏洞，至少可以追溯到 Android 的 Froyo 版本。幸运的是，有一个变通办法。

我个人有一个 Droid X，亲眼见过这个 bug。如果您在 Droid 上使用 OpenGL 将图像作为纹理加载，您可能最终只会在图像应该出现的地方看到一个白框。这个错误与你的 Android 包中图片的大小和位置有关。

对于 Android 的大多数正常安装，图像可以放在任何`res/drawable-[density]`文件夹中，并且可以是任何尺寸。在上一章中，您将一些不同尺寸的图像放入了`res/drawable-hdpi`文件夹中，希望显示它们没有问题。

要避免这种可怕的机器人白盒错误，请遵循以下两个步骤。首先，在你的`res`下创建一个名为`drawable-nopi`的新的`drawable`文件夹。旧版本的 Android 安装了这个文件夹；我只能假设机器人手机上的某些东西仍然在引用它。您想使用 OpenGL 显示的所有图像现在都应该放在这个新的`res/drawable-nopi`文件夹中。

其次，你必须确保你的图像是 256 ^ 256(2 的幂)的衍生物。背景图像(参见[图 4–1](#fig_4_1))为 256×256 像素。不过我发现 128 128 和 64 64 也可以。希望这个错误能在未来版本的 Droid 手机或 Android 软件中得到修复。

也就是说，把你正在用作背景的图像复制到你各自的`res/drawable`文件夹中。您现在可以使用`R.java`文件来引用它。

现在，创建一个新类，`SFBackground`。这个新的类文件将被调用来加载图像作为纹理，并将其返回给渲染器。

`package com.proandroidgames;

public class SFBackground {

}`

您将从 SFGameRenderer 调用`SFBackground.loadTexture()`方法来将背景加载到 OpenGL。但是首先你需要构建构造函数。`SFBackground`类的构造函数将设置所有你需要与 OpenGL 交互的变量。

您将需要一个数组来保存纹理的贴图坐标，一个数组来保存顶点的坐标，一个数组来保存顶点的索引。您还将创建一个指向纹理的指针数组。

注意:在这个类中，你将只加载一个纹理到类中，但是在以后的章节中，你将加载多个纹理到一个类中。因此，为了使代码尽可能通用，您将对大多数纹理加载类使用相同的结构。

`package com.proandroidgames;

public class SFBackground {
private int[] textures = new int[1];

private float vertices[] = {
0.0f, 0.0f, 0.0f,
1.0f, 0.0f, 0.0f,
1.0f, 1.0f, 0.0f,
0.0f, 1.0f, 0.0f,
};
private float texture[] = {
0.0f, 0.0f,
1.0f, 0f,
1, 1.0f,
0f, 1f,
};
private byte indices[] = {
0,1,2,
0,2,3,
};
public SFBackground() {

}
}`

在下一节中，您将添加构建多边形来保存纹理的数组。

##### 顶点、纹理和索引。。。我的天啊。

让我们简单讨论一下顶点、纹理和索引值代表什么。`vertices[]`数组列出了一系列的点。这里的每一行代表一个正方形的一个角的 x、y 和 z 值。在这种情况下，您正在制作一个与屏幕全尺寸相同的正方形。这将确保图像覆盖整个背景区域。

`texture[]`数组表示图像的角(即纹理)将与您创建的正方形的角对齐的位置。同样，在这种情况下，你希望纹理覆盖整个正方形，从而覆盖整个背景。数组保存了一个指针，指向你正在加载到你的形状上的每一个纹理。您正在将此硬编码为 1，因为您将只在此形状上加载一个背景图像。

最后，`indices[]`数组保存了正方形表面的定义。正方形的面被分成两个三角形。这个数组中的值是这些三角形按逆时针顺序排列的角。请注意，一条线(两点)重叠(0 和 2)。[图 4–3](#fig_4_3)说明了这个概念。

![images](images/0403.jpg)

**图 4–3。** *标注索引点*

现在，创建一些缓冲区来存放这些数组。然后可以将缓冲区加载到 OpenGL 中。

`package com.proandroidgames;

import java.nio.ByteBuffer;
import java.nio.FloatBuffer;

public class SFBackground {

**private FloatBuffer vertexBuffer;**
**private FloatBuffer textureBuffer;**
**private ByteBuffer indexBuffer;**

private int[] textures = new int[1];

private float vertices[] = {
0.0f, 0.0f, 0.0f,
1.0f, 0.0f, 0.0f,
1.0f, 1.0f, 0.0f,
0.0f, 1.0f, 0.0f,` `};
private float texture[] = {
0.0f, 0.0f,
1.0f, 0.0f,
1.0, 1.0f,
0.0f, 1.of,
};
private byte indices[] = {
0,1,2,
0,2,3,
};
public SFBackground() {

}

}`

在`SFBackground`类的构造函数中，您将使用适当的数组填充适当的缓冲区。

`package com.proandroidgames;

**import java.nio.ByteOrder;**
import java.nio.ByteBuffer;
import java.nio.FloatBuffer;

public class SFBackground {

private FloatBuffer vertexBuffer;
private FloatBuffer textureBuffer;
private ByteBuffer indexBuffer;

private int[] textures = new int[1];

private float vertices[] = {
0.0f, 0.0f, 0.0f,
1.0f, 0.0f, 0.0f,
1.0f, 1.0f, 0.0f,
0.0f, 1.0f, 0.0f,
};
private float texture[] = {
0.0f, 0.0f,
1.0f, 0.0f,
1.0, 1.0f,
0.0f, 1.of,
};
private byte indices[] = {
0,1,2,
0,2,3,
};

public SFBackground() {

**ByteBuffer byteBuf = ByteBuffer.allocateDirect(vertices.length * 4);**
**byteBuf.order(ByteOrder.nativeOrder());**
**vertexBuffer = byteBuf.asFloatBuffer();**
**vertexBuffer.put(vertices);**` `**vertexBuffer.position(0);**

**byteBuf = ByteBuffer.allocateDirect(texture.length * 4);**
**byteBuf.order(ByteOrder.nativeOrder());**
**textureBuffer = byteBuf.asFloatBuffer();**
**textureBuffer.put(texture);**
**textureBuffer.position(0);**

**indexBuffer = ByteBuffer.allocateDirect(indices.length);**
**indexBuffer.put(indices);**
**indexBuffer.position(0);**

}

}`

这里的代码应该是不言自明的。您正在用顶点和纹理数组的值创建一个`ByteBuffer`。请注意，每个数组中的值的数量都乘以 4，以在`ByteBuffer`中分配空间。这是因为数组中的值是浮点数，而浮点数的大小是字节的四倍。索引数组是整数，可以直接加载到`indexBuffer`中。

##### 创建 loadTexture()方法

接下来，您需要创建`loadTexture()`方法。`loadTexture()`方法将接收一个图像指针，然后将图像加载到流中。然后，该流将作为纹理加载到 OpenGL 中。在绘制过程中，你将把这个纹理映射到顶点上。

`package com.proandroidgames;

**import javax.microedition.khronos.opengles.GL10;**

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
**import android.content.Context;**
**import android.graphics.Bitmap;**
**import android.graphics.BitmapFactory;**
**import android.opengl.GLUtils;**
**import java.io.IOException;**
**import java.io.InputStream;**

public class SFBackground {

...

public SFBackground() {

...

}
**public void loadTexture(GL10 gl,int texture, Context context) {**` `**InputStream imagestream = context.getResources().openRawResource(texture);**
**Bitmap bitmap = null;**
**try {**

**bitmap = BitmapFactory.decodeStream(imagestream);**

**}catch(Exception e){**

**}finally {**
**//Always clear and close**
**try {**
**imagestream.close();**
**imagestream = null;**
**} catch (IOException e) {**
**}**
**}**

**gl.glGenTextures(1, textures, 0);**
**gl.glBindTexture(GL10.GL_TEXTURE_2D, textures[0]);**

**gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MIN_FILTER,**
**GL10.GL_NEAREST);**
**gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MAG_FILTER,**
**GL10.GL_LINEAR);**

**gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_S,**
**GL10.GL_REPEAT);**
**gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_T,**
**GL10.GL_REPEAT);**

**GLUtils.texImage2D(GL10.GL_TEXTURE_2D, 0, bitmap, 0);**

**bitmap.recycle();**
**}**

}`

`loadTexture()`的第一部分相当简单。它接收指针并将结果图像加载到位图流中。然后关闭该流。

然而`loadTexture()`的第二部分在 OpenGL 中相当沉重。第一行生成一个纹理指针，它的结构就像一个字典。

`gl.glGenTextures(1, textures, 0);`

第一个参数是需要生成的纹理名称的数量。当需要将纹理绑定到一组顶点时，您将通过名称从 OpenGL 中调用它们。这里，你只加载一个纹理，所以你只需要生成一个纹理名称。第二个参数是您为保存每个纹理的数量而创建的`int`数组。同样，现在这个数组中只有一个值。最后，最后一个参数保存指针在数组中的偏移量。因为数组是从零开始的，所以偏移量是 0。

第二行将纹理绑定到 OpenGL。

`gl.glBindTexture(GL10.GL_TEXTURE_2D, textures[0]);`

如果你同时加载了两个纹理，那么这前两行各有两行:一行加载第一个图像，一行加载第二个图像。

接下来的两行处理 OpenGL 如何将纹理映射到顶点上。您希望映射快速进行，但产生清晰的像素。

`gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MIN_FILTER, GL10.GL_NEAREST);
gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MAG_FILTER, GL10.GL_LINEAR);`

`The following two lines are important.Star Fighter is a scrolling shooter`游戏，所以`background`应该是`continuously scroll to give the illusion that the playable character is flying through space. Obviously, the image you are using for the background is finite. Therefore, to create the illusion that your player is flying through the endless vastness of space, the image must repeat ad infinitum. Luckily, OpenGL can handle this for you.`

`gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_S, GL10.GL_REPEAT);
gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_T, GL10.GL_REPEAT);`

在这两行中，你告诉 OpenGL 在 S 和 T 方向上不断重复你的背景纹理。现在，你的顶点是屏幕的大小，初始的背景纹理将直接映射到它的上面。到了滚动背景的时候(在本章的下一节)，你实际上是在移动顶点上的纹理，而不是移动顶点。通过移动纹理，您允许 OpenGL 为您重复纹理，以覆盖移动纹理时暴露的顶点。这是 OpenGL 的一个非常方便的特性，尤其是在游戏开发中。

最后，在`loadTexture()`方法的最后两行，您将创建的位图输入流与第一个纹理相关联。然后位图流被回收。

`GLUtils.texImage2D(GL10.GL_TEXTURE_2D, 0, bitmap, 0);
bitmap.recycle();`

##### 绘制你的纹理

完成`SFBackground`类需要编写的最后一段代码是将纹理绘制到顶点上的方法。

`package com.proandroidgames;

import javax.microedition.khronos.opengles.GL10;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.opengl.GLUtils;
import java.io.IOException;
import java.io.InputStream;

public class SFBackground {` `...

**public void draw(GL10 gl) {**

**gl.glBindTexture(GL10.GL_TEXTURE_2D, textures[0]);**

**gl.glFrontFace(GL10.GL_CCW);**
**gl.glEnable(GL10.GL_CULL_FACE);**
**gl.glCullFace(GL10.GL_BACK);**

**gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);**
**gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);**

**gl.glVertexPointer(3, GL10.GL_FLOAT, 0, vertexBuffer);**
**gl.glTexCoordPointer(2, GL10.GL_FLOAT, 0, textureBuffer);**

**gl.glDrawElements(GL10.GL_TRIANGLES, indices.length,**
**GL10.GL_UNSIGNED_BYTE, indexBuffer);**

**gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);**
**gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);**
**gl.glDisable(GL10.GL_CULL_FACE);**

**}**

public SFBackground() {

...

}
public void loadTexture(GL10 gl,int texture, Context context) {
InputStream imagestream = context.getResources().openRawResource(texture);
Bitmap bitmap = null;
try {

bitmap = BitmapFactory.decodeStream(imagestream);

}catch(Exception e){

}finally {

try {
imagestream.close();
imagestream = null;
} catch (IOException e) {
}
}

gl.glGenTextures(1, textures, 0);
gl.glBindTexture(GL10.GL_TEXTURE_2D, textures[0]);

gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MIN_FILTER,
GL10.GL_NEAREST);` `gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MAG_FILTER,
GL10.GL_LINEAR);

gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_S,
GL10.GL_REPEAT);
gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_T,
GL10.GL_REPEAT);

GLUtils.texImage2D(GL10.GL_TEXTURE_2D, 0, bitmap, 0);

bitmap.recycle();
}

}`

每次你想要绘制背景时，都会调用`draw()`方法，而`loadTexture()`方法只会在你初始化游戏时调用。

这个方法的第一行将纹理绑定到你的目标。把它想象成把一颗子弹放进枪膛；纹理被加载并准备使用。

`gl.glBindTexture(GL10.GL_TEXTURE_2D, textures[0]);`

`draw()`方法中接下来的三行告诉 OpenGL 启用剔除，基本上忽略任何不在正面的顶点。因为你是在二维正交视图中渲染游戏，你不希望 OpenGL 花费宝贵的处理器时间来处理玩家永远看不到的顶点。现在，你所有的顶点都是面向前方的，但是这是一个很好的代码。

`gl.glFrontFace(GL10.GL_CCW);
gl.glEnable(GL10.GL_CULL_FACE);
gl.glCullFace(GL10.GL_BACK);`

接下来的四行启用顶点和纹理状态，并将顶点和纹理缓冲区加载到 OpenGL 中。

`gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
gl.glVertexPointer(3, GL10.GL_FLOAT, 0, vertexBuffer);
gl.glTexCoordPointer(2, GL10.GL_FLOAT, 0, textureBuffer);`

最后，纹理被绘制到顶点上，所有启用的状态都被禁用。

`**gl.glDrawElements(GL10.GL_TRIANGLES, indices.length, GL10.GL_UNSIGNED_BYTE,**
**indexBuffer);**
**gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);**
**gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);**
**gl.glDisable(GL10.GL_CULL_FACE);**`

您的`SFBackground`类现在已经完成，可以被`SFGameRenderer`调用了。保存`SFBackground.java`文件并重新打开`SFGameRenderer`。

##### 调用 loadTexture()和 draw()

您需要添加对`SFBackground`的`loadTexture()`和`draw()`方法的适当调用。将从`SFGameRenderer`的`onSurfaceCreated()`方法中调用`loadTexture()`方法。

因为`SFBackground`的`loadTexture()`方法将一个图像指针作为参数，所以需要给`SFEngine`添加一个新的常量。打开`SFEngine`并添加下面的常量指向你添加到 drawable 文件夹的 backgroundstars.png 文件。

`package com.proandroidgames;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ImageButton;
package com.proandroidgames;

import android.content.Context;
import android.content.Intent;
import android.view.View;

public class SFEngine {
/*Constants that will be used in the game*/
public static final int GAME_THREAD_DELAY = 4000;
public static final int MENU_BUTTON_ALPHA = 0;
public static final boolean HAPTIC_BUTTON_FEEDBACK = true;
public static final int SPLASH_SCREEN_MUSIC = R.raw.warfieldedit;
public static final int R_VOLUME = 100;
public static final int L_VOLUME = 100;
public static final boolean LOOP_BACKGROUND_MUSIC = true;
public static Context context;
public static Thread musicThread;
**public static final int BACKGROUND_LAYER_ONE = R.drawable.backgroundstars;**

/*Kill game and exit*/
public boolean onExit(View v) {
try
{
Intent bgmusic = new Intent(context, sfmusic.class);
context.stopService(bgmusic);
musicThread.stop();
return true;
}catch(Exception e){
return false;
}

}

}`

您现在将调用`SFBackground`类的`loadTexture()`方法，并向其传递该常量。这将把背景星星图像作为纹理加载到 OpenGL 中。

保存`SFEngine`，并返回`SFGameRenderer`。您现在将实例化一个新的`SFBackground`，并从`onSurfaceCreated()`调用它的`loadTexture()`方法。最好实例化新的`SFBackground`，这样就可以在整个类中访问它。在本课程中，您将多次调用`SFBackground`。

`package com.proandroidgames;

import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;

import android.opengl.GLSurfaceView.Renderer;

public class SFGameRenderer implements Renderer{

**private SFBackground background = new SFBackground();**

@Override
public void onDrawFrame(GL10 gl) {

}

@Override
public void onSurfaceChanged(GL10 gl, int width, int height) {
gl.glViewport(0, 0, width,height);

gl.glMatrixMode(GL10.GL_PROJECTION);
gl.glLoadIdentity();

gl.glOrthof(0f, 1f, 0f, 1f, -1f, 1f);

}

@Override
public void onSurfaceCreated(GL10 gl, EGLConfig config) {

**gl.glEnable(GL10.GL_TEXTURE_2D);**
**gl.glClearDepthf(1.0f);**
**gl.glEnable(GL10.GL_DEPTH_TEST);**
**gl.glDepthFunc(GL10.GL_LEQUAL);**

**gl.glEnable(GL10.GL_BLEND);**
**gl.glBlendFunc(GL10.GL_ONE, GL10.GL_ONE);**

**background.loadTexture(gl,SFEngine.BACKGROUND_LAYER_ONE, SFEngine.context);**

}

}`

在这一点上，如果你调用了`SFBackground`的`draw()`方法，你将得到一个静态的星域图像。然而，一个静态的背景不是你在这个游戏中想要的。*星际战士*的主要可玩角色在太空中与敌人战斗，为了模拟太空中的比赛，背景需要滚动。在下一节中，您将创建一个滚动背景的方法，就好像您正在星空中飞行一样。

#### 滚动背景

与你在这一章已经完成的相比，编写滚动背景的方法将会非常容易。在`**SFGameRenderer**`中，创建一个名为`scrollBackground1()`的新方法。

您还需要一个名为`bgScroll1`的新 float。当你不在这个方法中时，这个浮动将记录背景滚动了多少。因为您需要值在`scrollBackground1()`方法之外持久化，所以在类可以访问它的地方创建它。

**注意:**你将这个方法命名为`scrollBackground1()`，因为在本章的后面，你将创建一个`scrollBackground2()`来滚动背景的第二层。

`package com.proandroidgames;

import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;

import android.opengl.GLSurfaceView.Renderer;

public class SFGameRenderer implements Renderer{
private SFBackground background = new SFBackground();

**private float bgScroll1;**

@Override
public void onDrawFrame(GL10 gl) {
// TODO Auto-generated method stub
}

**private void scrollBackground1(GL10 gl){**

**}**

@Override
public void onSurfaceChanged(GL10 gl, int width, int height) {
// TODO Auto-generated method stub

gl.glViewport(0, 0, width,height);

gl.glMatrixMode(GL10.GL_PROJECTION);
gl.glLoadIdentity();

gl.glOrthof(0f, 1f, 0f, 1f, -1f, 1f);

}` `@Override
public void onSurfaceCreated(GL10 gl, EGLConfig config) {
// TODO Auto-generated method stub

gl.glEnable(GL10.GL_TEXTURE_2D);
gl.glClearDepthf(1.0f);
gl.glEnable(GL10.GL_DEPTH_TEST);
gl.glDepthFunc(GL10.GL_LEQUAL);

**gl.glEnable(GL10.GL_BLEND);**
**gl.glBlendFunc(GL10.GL_ONE, GL10.GL_ONE);**

background.loadTexture(gl,SFEngine.BACKGROUND_LAYER_ONE, SFEngine.context);

}

}`

在这个方法中你要做的第一件事是测试以确保`bgScroll1`的值不会超过一个浮点数的最大可能值并抛出一个异常。`bgScroll1`升到那么高的几率非常小，尤其是当你看到我们将它增加多少的时候。然而，谨慎行事总是更好。

测试`bgScroll1`不等于浮动的最大尺寸。如果`bgScroll1`是浮动的最大尺寸，将其设置为零。

`package com.proandroidgames;

import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;

import android.opengl.GLSurfaceView.Renderer;

public class SFGameRenderer implements Renderer{
private SFBackground background = new SFBackground();

private float bgScroll1;

@Override
public void onDrawFrame(GL10 gl) {
// TODO Auto-generated method stub
}

private void scrollBackground1(GL10 gl){
**if (bgScroll1 == Float.MAX_VALUE){**
**bgScroll1 = 0f;**
**}**

}

...

}`

在本章的前面，我们讨论了 OpenGL 的两种矩阵模式:纹理和投影。你必须把 OpenGL 放在纹理矩阵模式下来滚动顶点上的纹理。

注意:记住你实际上是在顶点上移动纹理。您没有移动顶点。

因为您没有移动顶点，所以您需要确保它们在正确的位置，并且没有意外移动。为什么呢？这是学习 OpenGL 的棘手部分之一。

##### OpenGL 矩阵

将 OpenGL 设置为纹理矩阵模式，甚至模型视图矩阵模式(用于移动和缩放顶点)将使您在那时分别访问 OpenGL 中的*所有*纹理和*所有*顶点。这意味着当你将 OpenGL 放入纹理矩阵模式，并在 x 轴上移动一个单位的纹理时，你实际上是将 OpenGL 中的所有纹理在 x 轴上移动了一个单位。

这种情况在一个游戏中可能是有问题的，在这个游戏中，你可能有任何数量的物品在任何给定的时间以不同的速度和方向移动和缩放。然而，如果 OpenGL 同时处理所有的纹理和所有的顶点，你如何分别移动单独的项目呢？

这可能听起来很混乱，但是有一个合理的方法来解决这个问题。

所有矩阵模式都保存在一个堆栈中。这个过程是将模式推出堆栈(在这个例子中，是纹理矩阵模式)。一旦模式离开堆栈，你就移动所有的纹理，并且只重画那些你希望被特定的移动影响的纹理。然后将纹理弹出堆栈，并对要移动的下一个纹理重复该过程。

在开始使用矩阵模式之前，您必须小心地将它重置回默认状态，否则它将具有您上次设置的值。例如，假设你有纹理 A 和纹理 b，你想把纹理 A 在 x 轴上移动 1 个单位，在 y 轴上移动 1 个单位。你想把纹理 B 在 x 轴上移动 1 个单位。将纹理矩阵推出堆栈，并在 x 轴和 y 轴上各移动一个单位。然后绘制纹理 A，将矩阵弹出堆栈。那很容易。

现在，你移动到纹理 b。你将矩阵推出堆栈，并在 x 轴上移动矩阵 1 单位。然而，矩阵已经被设置为(1，1)，因为你在纹理 A 上做的最后一个操作是在每个轴上将纹理矩阵移动 1 个单位。所以你无意中在 x 轴上移动了 2 个单位，在 y 轴上移动了 1 个单位。因此，在将矩阵推出堆栈后，需要将其重置为默认状态，以确保从默认单位开始。使用`glLoadIdentity()`调用完成矩阵复位。

您将执行的用于滚动背景的 OpenGL 操作是`glTranslatef()`。`glTranslatef()`方法有三个参数，值 x、y 和 z。它将根据提供的值调整当前矩阵。你将把你滚动背景的值存储在一个常量中。将以下常量添加到`SFEngine`。

`**public static float SCROLL_BACKGROUND_1 = .002f;**`

保存`SFEngine`并移回`SFGameRenderer`。滚动背景纹理的第一步是将模型矩阵模式推出堆栈并重置它，以防将来任何移动会影响模型模式。然后你将把纹理矩阵推出堆栈，并进行滚动。

在 `scrollBackground1()` 方法中添加以下几行:

`**gl.glMatrixMode(GL10.GL_MODELVIEW);**
**gl.glLoadIdentity();**
**gl.glPushMatrix();**
**gl.glScalef(1f, 1f, 1f);**
**gl.glTranslatef(0f, 0f, 0f);**
package com.proandroidgames;

import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;

import android.opengl.GLSurfaceView.Renderer;

public class SFGameRenderer implements Renderer{
private SFBackground background = new SFBackground();

private float bgScroll1;

@Override
public void onDrawFrame(GL10 gl) {
// TODO Auto-generated method stub
}

private void scrollBackground1(GL10 gl){
if (bgScroll1 == Float.MAX_VALUE){
bgScroll1 = 0f;
}
**/*This code just resets the scale and translate of the**
**Model matrix mode, we are not moving it*/**
**gl.glMatrixMode(GL10.GL_MODELVIEW);**
**gl.glLoadIdentity();**
**gl.glPushMatrix();**
**gl.glScalef(1f, 1f, 1f);**
**gl.glTranslatef(0f, 0f, 0f);**
}

@Override
public void onSurfaceChanged(GL10 gl, int width, int height) {
// TODO Auto-generated method stub

gl.glViewport(0, 0, width,height);`  `gl.glMatrixMode(GL10.GL_PROJECTION);
gl.glLoadIdentity();

gl.glOrthof(0f, 1f, 0f, 1f, -1f, 1f);

}

@Override
public void onSurfaceCreated(GL10 gl, EGLConfig config) {
// TODO Auto-generated method stub

gl.glEnable(GL10.GL_TEXTURE_2D);
gl.glClearDepthf(1.0f);
gl.glEnable(GL10.GL_DEPTH_TEST);
gl.glDepthFunc(GL10.GL_LEQUAL);

**gl.glEnable(GL10.GL_BLEND);**
**gl.glBlendFunc(GL10.GL_ONE, GL10.GL_ONE);**

background.loadTexture(gl,SFEngine.BACKGROUND_LAYER_ONE, SFEngine.context);

}

}`

同样，这段代码在这一点上比任何东西都更像是内务处理。

##### 变换纹理

现在，你要加载纹理矩阵模式，并执行你的滚动。您将通过`bgScroll1`中的值调整 y 轴。这样做的结果是背景将沿着 y 轴移动`bgScroll1`中的量。

`package com.proandroidgames;

import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;

import android.opengl.GLSurfaceView.Renderer;

public class SFGameRenderer implements Renderer{
private SFBackground background = new SFBackground();
private float bgScroll1;

@Override
public void onDrawFrame(GL10 gl) {
// TODO Auto-generated method stub

}
private void scrollBackground1(GL10 gl){
if (bgScroll1 == Float.MAX_VALUE){
bgScroll1 = 0f;
}
gl.glMatrixMode(GL10.GL_MODELVIEW);
gl.glLoadIdentity();` `gl.glPushMatrix();
gl.glScalef(1f, 1f, 1f);
gl.glTranslatef(0f, 0f, 0f);

**gl.glMatrixMode(GL10.GL_TEXTURE);**
**gl.glLoadIdentity();**
**gl.glTranslatef(0.0f, bgScroll1, 0.0f); //scrolling the texture**

}

@Override
public void onSurfaceChanged(GL10 gl, int width, int height) {
// TODO Auto-generated method stub

gl.glViewport(0, 0, width,height);

gl.glMatrixMode(GL10.GL_PROJECTION);
gl.glLoadIdentity();

gl.glOrthof(0f, 1f, 0f, 1f, -1f, 1f);

}

@Override
public void onSurfaceCreated(GL10 gl, EGLConfig config) {
// TODO Auto-generated method stub

gl.glEnable(GL10.GL_TEXTURE_2D);
gl.glClearDepthf(1.0f);
gl.glEnable(GL10.GL_DEPTH_TEST);
gl.glDepthFunc(GL10.GL_LEQUAL);

gl.glEnable(GL10.GL_BLEND);
gl.glBlendFunc(GL10.GL_ONE, GL10.GL_ONE);

background.loadTexture(gl,SFEngine.BACKGROUND_LAYER_ONE, SFEngine.context);

}

}`

在`scrollBackground1()`中你需要做的最后一件事是通过调用`SFBackground`的`draw()`方法来绘制背景，将矩阵弹出堆栈，并增加`bgScroll1`。

`package com.proandroidgames;

import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;

import android.opengl.GLSurfaceView.Renderer;

public class SFGameRenderer implements Renderer{
private SFBackground background = new SFBackground();
private float bgScroll1;`  `@Override
public void onDrawFrame(GL10 gl) {
// TODO Auto-generated method stub

}
private void scrollBackground1(GL10 gl){
if (bgScroll1 == Float.MAX_VALUE){
bgScroll1 = 0f;
}

gl.glMatrixMode(GL10.GL_MODELVIEW);
gl.glLoadIdentity();
gl.glPushMatrix();
gl.glScalef(1f, 1f, 1f);
gl.glTranslatef(0f, 0f, 0f);

gl.glMatrixMode(GL10.GL_TEXTURE);
gl.glLoadIdentity();
gl.glTranslatef(0.0f, bgScroll1, 0.0f);

**background.draw(gl);**
**gl.glPopMatrix();**
**bgScroll1 += SFEngine.SCROLL_BACKGROUND_1;**
**gl.glLoadIdentity();**

}

@Override
public void onSurfaceChanged(GL10 gl, int width, int height) {
// TODO Auto-generated method stub

gl.glViewport(0, 0, width,height);

gl.glMatrixMode(GL10.GL_PROJECTION);
gl.glLoadIdentity();

gl.glOrthof(0f, 1f, 0f, 1f, -1f, 1f);

}

@Override
public void onSurfaceCreated(GL10 gl, EGLConfig config) {
// TODO Auto-generated method stub

gl.glEnable(GL10.GL_TEXTURE_2D);
gl.glClearDepthf(1.0f);
gl.glEnable(GL10.GL_DEPTH_TEST);
gl.glDepthFunc(GL10.GL_LEQUAL);

gl.glEnable(GL10.GL_BLEND);
gl.glBlendFunc(GL10.GL_ONE, GL10.GL_ONE);

background.loadTexture(gl,SFEngine.BACKGROUND_LAYER_ONE, SFEngine.context);

}` `}`

这个小方法是你滚动游戏背景所需要的。简单回顾一下这个方法的作用:

*   它重置模型矩阵，以确保它没有被无意中移动。
*   它加载纹理矩阵并沿 y 轴移动`SCROLL_BACKGROUND_1`中的值。
*   它绘制背景并将矩阵弹出堆栈。

这种滚动会给你一个很好的移动星域，玩家的飞船可以飞过。现在试着运行你的游戏，看看背景是如何滚动的。如果有任何问题，这也是一个很好的时机，在您进入更复杂的代码之前进行一些调试。然而，特别是以今天的游戏标准来看，目前的背景相当简单。你需要做些什么来给它一点活力。

在下一节中，您将添加第二层的背景。这将给你的游戏背景一些深度，即使是 2-D 游戏。如果你看过任何两层侧滚游戏，像*超级马里奥兄弟*，你应该注意到两层滚动的速度不同。在接下来的部分中，您将为您的游戏提供这种两层、两种速度的滚动效果。

### 添加第二层

此时，您已经初始化了 OpenGL，将背景图像作为纹理加载，并创建了一个方法来将该纹理向下滚动到游戏的背景中。现在，是时候创建第二层背景了。这第二层将非常容易创建，尤其是与你从游戏外观中获得的好处相比。

第二层的大部分实现实际上已经完成；您只需要创建一个新的滚动函数，添加几个新的常量，并实例化您的`SFBackground`的一个新副本。

首先，给你的`res/drawable`文件夹添加一张新图片。我用过的图像叫做`debris.png`。

注意:因为你已经完成了背景第一层的大部分工作，所以我不会像本章前面的部分那样详细。

将图像放入`res/drawable`文件夹后，您可以向 SFEngine 添加两个常量。第一个是指向新图像文件的指针，该文件可以传递给 SFBackground 的 loadTexture()方法，第二个是保存第二层背景的滚动值的 float。这个浮动常量是背景第二层的关键部分，因为它会使第二层滚动得比第一层更快——给你的游戏增加一些深度。

将以下常量添加到您的 SFEngine 中。

`**public static float SCROLL_BACKGROUND_2 = .007f;**
**public static final int BACKGROUND_LAYER_TWO = R.drawable.debris;**`

请注意，`SCROLL_BACKGROUND_2`被设置为比`SCROLL_BACKGROUND_1`更高的(十进制)值。值越大，意味着 y 轴的增量越大，因此背景的第二层看起来比第一层移动得更快。如果第二层滚动得比第一层快，就会产生背景有深度的错觉。

接下来，回到你的`SFGameRenderer`，实例化一个名为`background2`的`SFBackground`的新副本。注意，您正在重用`SFBackground`类。这种重用是游戏引擎代码和特定于游戏的代码之间的部分区别。因为`SFBackground`是通用的，可以加载和绘制作为纹理传递给它的任何图像，所以它是引擎的一部分，可以重复用于我们的任何背景层。

因为您正在实例化一个新的`SFBackground`副本，所以您也应该创建一个名为`bgScroll2`的新 float。这个浮动将跟踪背景第二层的累积滚动系数，而不是背景第一层的滚动系数，后者保存在`bgScroll1`浮动中。

`package com.proandroidgames;

import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;

import android.opengl.GLSurfaceView.Renderer;

public class SFGameRenderer implements Renderer{
private SFBackground background = new SFBackground();
**private SFBackground background2 = new SFBackground();**
private float bgScroll1;
**private float bgScroll2;**
@Override
public void onDrawFrame(GL10 gl) {
// TODO Auto-generated method stub

}
private void scrollBackground1(GL10 gl){
if (bgScroll1 == Float.MAX_VALUE){
bgScroll1 = 0f;
}

gl.glMatrixMode(GL10.GL_MODELVIEW);
gl.glLoadIdentity();
gl.glPushMatrix();
gl.glScalef(1f, 1f, 1f);
gl.glTranslatef(0f, 0f, 0f);

gl.glMatrixMode(GL10.GL_TEXTURE);
gl.glLoadIdentity();
gl.glTranslatef(0.0f, bgScroll1, 0.0f);` `background.draw(gl);
gl.glPopMatrix();
bgScroll1 += SFEngine.SCROLL_BACKGROUND_1;
gl.glLoadIdentity();

}

@Override
public void onSurfaceChanged(GL10 gl, int width, int height) {
// TODO Auto-generated method stub

gl.glViewport(0, 0, width,height);

gl.glMatrixMode(GL10.GL_PROJECTION);
gl.glLoadIdentity();

gl.glOrthof(0f, 1f, 0f, 1f, -1f, 1f);

}

@Override
public void onSurfaceCreated(GL10 gl, EGLConfig config) {
// TODO Auto-generated method stub

gl.glEnable(GL10.GL_TEXTURE_2D);
gl.glClearDepthf(1.0f);
gl.glEnable(GL10.GL_DEPTH_TEST);
gl.glDepthFunc(GL10.GL_LEQUAL);

gl.glEnable(GL10.GL_BLEND);
gl.glBlendFunc(GL10.GL_ONE, GL10.GL_ONE);

background.loadTexture(gl,SFEngine.BACKGROUND_LAYER_ONE, SFEngine.context);

}

}`

#### 加载第二个纹理

现在你已经为第二层实例化了`SFBackground`的副本，你可以为它加载纹理了。您将调用与背景的第一层相同的`loadTexture()`方法。在调用了`SFGameRenderer`的`onSurfaceCreated()`方法中的第一个之后，你将调用背景的第二层的`loadTexture()`。

`package com.proandroidgames;

import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;

import android.opengl.GLSurfaceView.Renderer;` `public class SFGameRenderer implements Renderer{
private SFBackground background = new SFBackground();
private SFBackground background2 = new SFBackground();
private float bgScroll1;
private float bgScroll2;

...

@Override
public void onSurfaceCreated(GL10 gl, EGLConfig config) {
// TODO Auto-generated method stub

gl.glEnable(GL10.GL_TEXTURE_2D);
gl.glClearDepthf(1.0f);
gl.glEnable(GL10.GL_DEPTH_TEST);
gl.glDepthFunc(GL10.GL_LEQUAL);

gl.glEnable(GL10.GL_BLEND);
gl.glBlendFunc(GL10.GL_ONE, GL10.GL_ONE);

background.loadTexture(gl,SFEngine.BACKGROUND_LAYER_ONE, SFEngine.context);
**background2.loadTexture(gl,SFEngine.BACKGROUND_LAYER_TWO, SFEngine.context);**

}

}`

确保当你为背景的第二层调用`loadTexture()`方法时，你传递给它正确的图像指针。之前，您在`SFEngine`中创建了一个名为`BACKGROUND_LAYER_TWO`的新常量，它有一个指向新图像的指针；这是你应该传递给`background2`的`loadTexture()`方法的指针。

你现在有一个新的背景层实例化，你正在加载一个纹理到它。接下来，您需要编写一个新的方法来控制滚动。

#### 滚动第二层

你将在这个滚动方法中做一些与背景第一层的滚动方法稍有不同的事情。因为背景的第二层只是较小的图像，不应该控制背景的整体外观，所以您将在模型矩阵视图中调整顶点的大小，以便第二层纹理的顶点是屏幕宽度的一半。然后，您将沿着 x 轴移动顶点，因此图像看起来在屏幕右侧的一半。

在您的`SFGameRenderer`中创建一个名为`scrollBackground2()`的新方法。您还应该插入与在`scrollBackground1()`中相同的测试，以确保`bgScroll2`没有超过浮动的最大大小。

`package com.proandroidgames;

import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;

import android.opengl.GLSurfaceView.Renderer;

public class SFGameRenderer implements Renderer{
private SFBackground background = new SFBackground();
private SFBackground background2 = new SFBackground();
private float bgScroll1;
private float bgScroll2;

@Override
public void onDrawFrame(GL10 gl) {
// TODO Auto-generated method stub

}
private void scrollBackground1(GL10 gl){
if (bgScroll1 == Float.MAX_VALUE){
bgScroll1 = 0f;
}

gl.glMatrixMode(GL10.GL_MODELVIEW);
gl.glLoadIdentity();
gl.glPushMatrix();
gl.glScalef(1f, 1f, 1f);
gl.glTranslatef(0f, 0f, 0f);

gl.glMatrixMode(GL10.GL_TEXTURE);
gl.glLoadIdentity();
gl.glTranslatef(0.0f,bgScroll1, 0.0f);

background.draw(gl);
gl.glPopMatrix();
bgScroll1 += SFEngine.SCROLL_BACKGROUND_1;
gl.glLoadIdentity();

}

**private void scrollBackground2(GL10 gl){**
**if (bgScroll2 == Float.MAX_VALUE){**
**bgScroll2 = 0f;**
**}**

**}**

...

}`

#### 处理矩阵

这里是`scrollBackground2()`的代码要稍微改变的地方。在`scrollBackground1()`中，您添加了一些内务代码，以确保模型矩阵没有改变，并将其重置为默认值。在`scrollBackground2()`中，你将对模型矩阵进行两次转换。首先，您将在 x 轴上缩放模型矩阵，使其为屏幕大小的一半。然后，您将在 x 轴上移动模型矩阵，使其位于屏幕右侧的一半。

因为您是在模型矩阵而不是纹理矩阵上执行这些操作，所以您将转换顶点而不是应用于它的纹理。也就是说，虽然在视觉上你会看到纹理收缩并移动到屏幕的一侧，但你实际上是在收缩和移动顶点，而不是纹理。

您将把`glScale()`方法的 x 值设置为. 5，以便在 x 轴上将顶点缩小一半。请小心理解，将轴设置为 0.5 并不意味着您要向它添加 0.5 个单位。所有的值都相乘。因此，通过将`glScale()`的 x 设置为. 5，您是在告诉 OpenGL 将 x 的当前值乘以. 5，从而(在您的例子中)将 x 轴缩小一半。

`package com.proandroidgames;

import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;

import android.opengl.GLSurfaceView.Renderer;

public class SFGameRenderer implements Renderer{
private SFBackground background = new SFBackground();
private SFBackground background2 = new SFBackground();
private float bgScroll1;
private float bgScroll2;

@Override
public void onDrawFrame(GL10 gl) {
// TODO Auto-generated method stub

}
private void scrollBackground1(GL10 gl){
if (bgScroll1 == Float.MAX_VALUE){
bgScroll1 = 0f;
}

gl.glMatrixMode(GL10.GL_MODELVIEW);
gl.glLoadIdentity();
gl.glPushMatrix();
gl.glScalef(1f, 1f, 1f);
gl.glTranslatef(0f, 0f, 0f);

gl.glMatrixMode(GL10.GL_TEXTURE);
gl.glLoadIdentity();
gl.glTranslatef(0.0f,bgScroll1, 0.0f);`

`background.draw(gl);
gl.glPopMatrix();
bgScroll1 += SFEngine.SCROLL_BACKGROUND_1;
gl.glLoadIdentity();

}
private void scrollBackground2(GL10 gl){
if (bgScroll2 == Float.MAX_VALUE){
bgScroll2 = 0f;
}

**gl.glMatrixMode(GL10.GL_MODELVIEW);**
**gl.glLoadIdentity();**
**gl.glPushMatrix();**
**gl.glScalef(.5f, 1f, 1f);**
**gl.glTranslatef(1.5f, 0f, 0f);**

}
@Override
public void onSurfaceChanged(GL10 gl, int width, int height) {
// TODO Auto-generated method stub

gl.glViewport(0, 0, width,height);

gl.glMatrixMode(GL10.GL_PROJECTION);
gl.glLoadIdentity();

gl.glOrthof(0f, 1f, 0f, 1f, -1f, 1f);

}

@Override
public void onSurfaceCreated(GL10 gl, EGLConfig config) {
// TODO Auto-generated method stub

gl.glEnable(GL10.GL_TEXTURE_2D);
gl.glClearDepthf(1.0f);
gl.glEnable(GL10.GL_DEPTH_TEST);
gl.glDepthFunc(GL10.GL_LEQUAL);

gl.glEnable(GL10.GL_BLEND);
gl.glBlendFunc(GL10.GL_ONE, GL10.GL_ONE);

background.loadTexture(gl,SFEngine.BACKGROUND_LAYER_ONE, SFEngine.context);
background2.loadTexture(gl,SFEngine.BACKGROUND_LAYER_TWO, SFEngine.context);

}

}`

注意`scrollBackground1()`和`scrollBackground2()`的区别。因为`scrollBackground2()`直接处理模型矩阵，所以你要确保你在`scrollBackground1()`中有代码来重置它。否则，你的星域背景将会被减半并被推到屏幕的右边。

#### 完成 scrollBackground2()方法

`scrollBackground2()`方法的其余部分与`scrollBackground1()`相同。你需要将背景纹理沿着 y 轴移动`bgScroll2`中的值，然后将该值增加`SCROLL_BACKGROUND_2`。

`package com.proandroidgames;

import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;

import android.opengl.GLSurfaceView.Renderer;

public class SFGameRenderer implements Renderer{
private SFBackground background = new SFBackground();
private SFBackground background2 = new SFBackground();
private float bgScroll1;
private float bgScroll2;

@Override
public void onDrawFrame(GL10 gl) {
// TODO Auto-generated method stub

}
private void scrollBackground1(GL10 gl){
if (bgScroll1 == Float.MAX_VALUE){
bgScroll1 = 0f;
}

gl.glMatrixMode(GL10.GL_MODELVIEW);
gl.glLoadIdentity();
gl.glPushMatrix();
gl.glScalef(1f, 1f, 1f);
gl.glTranslatef(0f, 0f, 0f);

gl.glMatrixMode(GL10.GL_TEXTURE);
gl.glLoadIdentity();
gl.glTranslatef(0.0f,bgScroll1, 0.0f);

background.draw(gl);
gl.glPopMatrix();
bgScroll1 += SFEngine.SCROLL_BACKGROUND_1;
gl.glLoadIdentity();

}
private void scrollBackground2(GL10 gl){
if (bgScroll2 == Float.MAX_VALUE){
bgScroll2 = 0f;
}

**gl.glMatrixMode(GL10.GL_MODELVIEW);**`
`**gl.glLoadIdentity();**
**gl.glPushMatrix();**
**gl.glScalef(.5f, 1f, 1f);**
**gl.glTranslatef(1.5f, 0f, 0f);**

**gl.glMatrixMode(GL10.GL_TEXTURE);**
**gl.glLoadIdentity();**
**gl.glTranslatef( 0.0f,bgScroll2, 0.0f);**

**background2.draw(gl);**
**gl.glPopMatrix();**
**bgScroll2 += SFEngine.SCROLL_BACKGROUND_2;**
**gl.glLoadIdentity();**
}
@Override
public void onSurfaceChanged(GL10 gl, int width, int height) {
// TODO Auto-generated method stub

gl.glViewport(0, 0, width,height);

gl.glMatrixMode(GL10.GL_PROJECTION);
gl.glLoadIdentity();

gl.glOrthof(0f, 1f, 0f, 1f, -1f, 1f);

}

@Override
public void onSurfaceCreated(GL10 gl, EGLConfig config) {
// TODO Auto-generated method stub

gl.glEnable(GL10.GL_TEXTURE_2D);
gl.glClearDepthf(1.0f);
gl.glEnable(GL10.GL_DEPTH_TEST);
gl.glDepthFunc(GL10.GL_LEQUAL);

gl.glEnable(GL10.GL_BLEND);
gl.glBlendFunc(GL10.GL_ONE, GL10.GL_ONE);

background.loadTexture(gl,SFEngine.BACKGROUND_LAYER_ONE, SFEngine.context);
background2.loadTexture(gl,SFEngine.BACKGROUND_LAYER_TWO, SFEngine.context);

}

}`

到目前为止，你已经在这一章中做了大量的编码工作，而且你已经有了一个相当完整的环境，玩家可以在其中体验游戏。然而，`SFGameRenderer`的一个非常重要的部分留给了编码；`onDrawFrame()`法。这种方法不仅可以控制背景的滚动(以及最终的绘制)，还可以控制游戏运行的帧速率。

### 以每秒 60 帧的速度运行

游戏运行速度的圣杯是每秒 60 帧。您的游戏应该以每秒 60 帧或尽可能接近每秒 60 帧的速度运行，以获得流畅的游戏体验。在本章的这一节，你将编写一个快速线程暂停例程，确保你的游戏以每秒 60 帧的速度运行。

使用`GLSurfaceView`渲染器作为游戏(`SFGameRenderer`)的主要启动点的好处是它已经为你线程化了。除非你明确地设置它，否则`onDrawFrame()`方法会被不断地调用。您不需要担心为游戏执行手动设置任何额外的线程或者在循环中调用游戏方法。当您将`SFGameRenderer`设置为活动的主视图时，将执行一个线程化操作，该操作将持续调用`SFGameRenderer`的`onDrawFrame()`方法。

因此，您需要整理这个方法的运行方式，以便将其限制在一秒钟内运行 60 次。

您可以在`onDrawFrame()`中放一个快速暂停例程，让线程休眠一段特定的时间。你想让线程休眠的时间是 1 秒除以 60。您将把这个值存储在`SFEngine`中的一个常量中。

`public class SFEngine {
/*Constants that will be used in the game*/
public static final int GAME_THREAD_DELAY = 4000;
public static final int MENU_BUTTON_ALPHA = 0;
public static final boolean HAPTIC_BUTTON_FEEDBACK = true;
public static final int SPLASH_SCREEN_MUSIC = R.raw.warfieldedit;
public static final int R_VOLUME = 100;
public static final int L_VOLUME = 100;
public static final boolean LOOP_BACKGROUND_MUSIC = true;
**public static final int GAME_THREAD_FPS_SLEEP = (1000/60);**
public static Context context;
public static Thread musicThread;
public static Display display;
public static float SCROLL_BACKGROUND_1 = .002f;
public static float SCROLL_BACKGROUND_2 = .007f;
public static final int BACKGROUND_LAYER_ONE = R.drawable.backgroundstars;
public static final int BACKGROUND_LAYER_TWO = R.drawable.debris;

/*Kill game and exit*/
public boolean onExit(View v) {
try
{
Intent bgmusic = new Intent(context, sfmusic.class);
context.stopService(bgmusic);
musicThread.stop();

return true;
}catch(Exception e){
return false;
}`

`}

}`

**提示:**在[第五章](05.html#ch5)中，你将可以选择稍微修改这个公式。当你添加更多的对象时，你需要考虑 OpenGL 渲染游戏所需的时间。目前，这个公式应该没问题。

#### 暂停游戏循环

既然常量已经创建，您可以在`onDrawFrame()`方法中设置暂停例程。在方法的顶部，插入`Thread.sleep()`。

`package com.proandroidgames;

import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;

import android.opengl.GLSurfaceView.Renderer;

public class SFGameRenderer implements Renderer{
private SFBackground background = new SFBackground();
private SFBackground background2 = new SFBackground();
private float bgScroll1;
private float bgScroll2;

@Override
public void onDrawFrame(GL10 gl) {
// TODO Auto-generated method stub
**try {**
**Thread.sleep(SFEngine.GAME_THREAD_FPS_SLEEP);**
**} catch (InterruptedException e) {**
**// TODO Auto-generated catch block**
**e.printStackTrace();**
**}**

**}**
private void scrollBackground1(GL10 gl){
if (bgScroll1 == Float.MAX_VALUE){
bgScroll1 = 0f;
}

gl.glMatrixMode(GL10.GL_MODELVIEW);
gl.glLoadIdentity();
gl.glPushMatrix();
gl.glScalef(1f, 1f, 1f);
gl.glTranslatef(0f, 0f, 0f);

gl.glMatrixMode(GL10.GL_TEXTURE);
gl.glLoadIdentity();
gl.glTranslatef(0.0f,bgScroll1, 0.0f);`

`background.draw(gl);
gl.glPopMatrix();
bgScroll1 += SFEngine.SCROLL_BACKGROUND_1;
gl.glLoadIdentity();

}
private void scrollBackground2(GL10 gl){
if (bgScroll2 == Float.MAX_VALUE){
bgScroll2 = 0f;
}

gl.glMatrixMode(GL10.GL_MODELVIEW);
gl.glLoadIdentity();
gl.glPushMatrix();
gl.glScalef(.5f, 1f, 1f);
gl.glTranslatef(1.5f, 0f, 0f);

gl.glMatrixMode(GL10.GL_TEXTURE);
gl.glLoadIdentity();
gl.glTranslatef( 0.0f,bgScroll2, 0.0f);

background2.draw(gl);
gl.glPopMatrix();
bgScroll2 += SFEngine.SCROLL_BACKGROUND_2;
gl.glLoadIdentity();
}
@Override
public void onSurfaceChanged(GL10 gl, int width, int height) {
// TODO Auto-generated method stub

gl.glViewport(0, 0, width,height);

gl.glMatrixMode(GL10.GL_PROJECTION);
gl.glLoadIdentity();

gl.glOrthof(0f, 1f, 0f, 1f, -1f, 1f);

}

@Override
public void onSurfaceCreated(GL10 gl, EGLConfig config) {
// TODO Auto-generated method stub

gl.glEnable(GL10.GL_TEXTURE_2D);
gl.glClearDepthf(1.0f);
gl.glEnable(GL10.GL_DEPTH_TEST);
gl.glDepthFunc(GL10.GL_LEQUAL);

gl.glEnable(GL10.GL_BLEND);
gl.glBlendFunc(GL10.GL_ONE, GL10.GL_ONE);

background.loadTexture(gl,SFEngine.BACKGROUND_LAYER_ONE, SFEngine.context);
background2.loadTexture(gl,SFEngine.BACKGROUND_LAYER_TWO, SFEngine.context);`

`}

}`

现在，你把*放在包含`Thread.sleep()`的`try. . .catch`和*之后，任何东西都只能每秒运行 60 次。您将使用这个带有暂停例程的`onDrawFrame()`作为您的游戏循环。在这里，你可以做任何你需要在游戏中调用的事情。

#### 清除 OpenGL 缓冲区

游戏循环的第一步是清除 OpenGL 缓冲区。这将为你将要做的所有渲染和转换准备 OpenGL。

`@Override
public void onDrawFrame(GL10 gl) {
// TODO Auto-generated method stub
try {
Thread.sleep(SFEngine.GAME_THREAD_FPS_SLEEP);
} catch (InterruptedException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
**gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);**

}`

一旦缓冲区被清空，你可以调用你在本章最后一节创建的两个滚动方法。这两种方法将适当地移动和绘制背景的两个层。

`@Override
public void onDrawFrame(GL10 gl) {
// TODO Auto-generated method stub
try {
Thread.sleep(SFEngine.GAME_THREAD_FPS_SLEEP);
} catch (InterruptedException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
**gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);**

**scrollBackground1(gl);**
**scrollBackground2(gl);**

}`

最后你要调用 OpenGL 的透明度混合函数。这个 OpenGL 函数将确保你应该能够看透的一切都是透明的。如果没有这个功能，你将看不到纹理周围的顶点。

`@Override
public void onDrawFrame(GL10 gl) {`
`// TODO Auto-generated method stub
try {
Thread.sleep(SFEngine.GAME_THREAD_FPS_SLEEP);
} catch (InterruptedException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
**gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);**

**scrollBackground1(gl);**
**scrollBackground2(gl);**

**//All other game drawing will be called here**

**gl.glEnable(GL10.GL_BLEND);**
**gl.glBlendFunc(GL10.GL_ONE, GL10.GL_ONE);**
}`

恭喜你！您刚刚成功地使用 OpenGL 创建了一个两层、双速滚动的背景。运行游戏前的最后一步是连接主菜单的开始按钮来调用`SFGame`活动。

### 修改主菜单

打开您在上一章中创建的`SFMainMenu`文件。在[第 3 章](03.html#ch3)中，你为开始按钮创建了一个`onClickListener()`。您将为`SFGame`活动的这个方法添加一个新的意图。将此活动添加到`onClickListener()`将在玩家点击(或触摸)主菜单上的开始按钮时开始您的游戏活动。

`start.setOnClickListener(new OnClickListener(){
@Override
public void onClick(View v) {
/** Start Game!!!! */
**Intent game = new Intent(getApplicationContext(),SFGame.class);**
**SFMainMenu.this.startActivity(game);**

**}**
});`

您可以编译并运行您的代码。您应该会看到闪屏淡入主菜单。如果你点击主菜单上的开始按钮，你将进入你的游戏，你会看到两层背景以不同的速度随着背景音乐滚动。

点击设备上的后退菜单按钮返回主菜单，点击退出按钮退出游戏，杀死线程。

**注意:**记住，你还没有输入一些重要的内务代码。例如，如果你离开游戏的焦点，线程会继续运行(音乐也是)。在本书的后面部分，您将添加代码来解决这个问题。现在，当你测试你的游戏时，确保你通过点击退出按钮来终止线程。

### 总结

在这一章中，你学习了游戏开发者在游戏中添加背景的几个关键技巧。具体来说，您现在应该对以下内容有了基本的了解:

*   创建一个`GLSurface`实例
*   创建渲染器
*   正在初始化 OpenGL
*   从图像中加载纹理
*   修改 OpenGL 矩阵
*   推动和弹出矩阵
*   使用`glScale()`和`glTranslatef()`移动纹理和顶点
*   使用`Thread.sleep()`编组渲染器

在下一章，你将添加你的第一个可玩角色到游戏中。