第章 4

发现继承、多态和接口

基于对象的语言是一种封装了对象的状态和行为的语言。Java 对封装的支持(在[第三章](03.html)中讨论)使它成为一种基于对象的语言。然而，Java 也是一种*面向对象语言*，因为它支持继承和多态(以及封装)。(面向对象语言是基于对象语言的子集。)在第 4 章中，我将向你介绍 Java 支持继承和多态的语言特性。此外，我还将向您介绍接口，这是 Java 的终极抽象类型机制。

构建类层次结构

我们倾向于用“汽车是交通工具”或“储蓄账户是银行账户”这样的话来对事物进行分类通过做出这些陈述，我们实际上是在说(从软件开发的角度来看)汽车继承了车辆状态(例如，品牌和颜色)和行为(例如，停放和显示里程)，储蓄账户继承了银行账户状态(例如，余额)和行为(例如，存款和取款)。汽车、车辆、储蓄账户和银行账户是真实世界实体类别的示例，而*继承*是相似实体类别之间的层次关系，其中一个类别从至少一个其他实体类别继承状态和行为。从单一类别继承是*单一继承*，从至少两个类别继承是*多重继承*。

Java 支持单继承和多继承以方便代码重用——为什么要多此一举？Java 支持类上下文中的单一继承，其中一个类通过类扩展从另一个类继承状态和行为。因为涉及到类，Java 把这种继承称为*实现继承*。

Java 还支持接口上下文中的单继承和多继承，在接口上下文中，类通过接口实现从一个或多个接口继承行为模板，或者接口通过接口扩展从一个或多个接口继承行为模板。因为涉及到接口，Java 把这种继承称为*接口继承*。(我将在本章后面讨论接口。)

**注意**你通过小心地扩展类，实现接口，扩展接口来重用代码。你从接近你想要的东西开始，延伸它以达到你的目标。你不能通过简单的复制和粘贴来重用代码。复制和粘贴通常会导致冗余(即不可重用)和错误代码。

在这一节中，我首先通过关注类扩展向您介绍 Java 对实现继承的支持。然后我向您介绍一个特殊的类，它位于 Java 类层次结构的顶端。在向您介绍了组合(重用代码的实现继承的替代方法)之后，我将向您展示如何使用组合来克服实现继承的问题。

扩展类

Java 提供了保留字扩展，用于指定两个类之间的层次关系。例如，假设您有一个车辆类，并想引入一个汽车类作为一种车辆。[清单 4-1](#list1) 使用扩展来巩固这种关系。

*[清单 4-1](#_list1)* 。通过扩展关联两个类

```java
class Vehicle
{
   // member declarations
}

class Car extends Vehicle
{
   // member declarations
}

```

清单 4-1 编纂了一个被称为“是-是”关系的关系:汽车是一种交通工具。在这个关系中， Vehicle 被称为*基类*、*父类*或*超类*；而汽车又被称为*的派生类*、*的子类*，或者*的子类*。

**注意**你不能扩展一个最终类。例如，如果您将车辆声明为最终类车辆，编译器会在遇到类车辆扩展车辆时报告一个错误。当开发人员不希望这些类被扩展(出于安全或其他原因)时，他们会将自己的类声明为 final。

除了能够提供自己的成员声明， Car 还能够从它的 Vehicle 超类继承成员声明。如清单 4-2 所示，非私有继承的成员可以被 Car 类的成员访问。

*[清单 4-2](#_list2)* 。继承成员

```java
class Vehicle
{
   private String make;
   private String model;
   private int year;

   Vehicle(String make, String model, int year)
   {
      this.make = make;
      this.model = model;
      this.year = year;
   }

   String getMake()
   {
      return make;
   }

   String getModel()
   {
      return model;
   }

   int getYear()
   {
      return year;
   }
}

public class Car extends Vehicle
{
   private int numWheels;

```

```java
  Car(String make, String model, int year, int numWheels)
   {
      super(make, model, year);
      this.numWheels = numWheels;
   }

   public static void main(String[] args)
   {
      Car car = new Car("Ford", "Fiesta", 2009, 4);
      System.out.println("Make = " + car.getMake());
      System.out.println("Model = " + car.getModel());
      System.out.println("Year = " + car.getYear());
      // Normally, you cannot access a private field via an object
      // reference. However, numWheels is being accessed from
      // within a method (main()) that is part of the Car class.
      System.out.println("Number of wheels = " + car.numWheels);
   }
}

```

[清单 4-2](#list2) 的车辆类声明了私有字段，用于存储车辆的品牌、型号和年份；将这些字段初始化为传递的参数的构造函数；和 getter 方法来检索这些字段的值。

Car 子类提供了一个私有的 numWheels 字段，一个初始化 Car 对象的 Vehicle 和 Car 层的构造函数，以及一个用于测试该类的 main() 类方法。

汽车的构造函数使用保留字超级用面向汽车的参数调用汽车的构造函数，然后初始化汽车的 numWheels 实例字段。 super() 调用类似于指定 this() 调用同一个类中的另一个构造函数，但是调用的是超类构造函数。

**注意**super()调用只能出现在构造函数中。此外，它必须是构造函数中指定的第一个代码。如果没有指定 super() ，并且超类没有无参数构造函数，编译器会报错，因为当 super() 不存在时，子类构造函数必须调用无参数超类构造函数。

Car 的 main() 方法创建一个 Car 对象，将该对象初始化为特定的品牌、型号、年份和车轮数量。四个 System.out.println() 方法调用随后输出该信息。

前三个 System.out.println() 方法调用通过调用 Car 实例继承的 getMake() 、 getModel() 和 getYear() 方法来检索它们的信息片段。最后的 System.out.println() 方法调用直接访问实例的 numWheels 字段。尽管直接访问一个实例字段通常不是一个好主意(这样做违反了信息隐藏)，但是提供这种访问的 Car 的 main() 方法只是为了测试这个类，并不存在于使用这个类的实际应用中。

因为汽车被声明为公共类，[清单 4-2](#list2) 将被存储在一个名为Car.java的文件中。因此，执行javac Car.java将该源代码编译成 Vehicle.class 和 Car.class 。然后执行 java Car 来测试 Car 类。该执行会产生以下输出:

```java
Make = Ford
Model = Fiesta
Year = 2009
Number of wheels = 4

```

**注意**实例不能被修改的类被称为*不可变类*。车就是一个例子。如果 Car 的 main() 方法(可以直接读取或写入 numWheels )不存在， Car 也将是不可变类的一个例子。同样，一个类不能继承构造函数，也不能继承私有的字段和方法。例如，汽车不继承车辆的构造者，也不继承车辆的私有制造、型号、年份字段。

子类可以*覆盖*(替换)一个继承的方法，这样子类的方法版本被调用。[清单 4-3](#list3) 向您展示了覆盖方法必须指定与被覆盖方法相同的名称、参数列表和返回类型。

*[清单 4-3](#_list3)* 。重写方法

```java
class Vehicle
{
   private String make;
   private String model;
   private int year;

   Vehicle(String make, String model, int year)
   {
      this.make = make;
      this.model = model;
      this.year = year;
   }

   void describe()
   {
      System.out.println(year + " " + make + " " + model);
   }
}

public class Car extends Vehicle
{
   private int numWheels;

   Car(String make, String model, int year, int numWheels)
   {
      super(make, model, year);
   }

   void describe()
   {
      System.out.print("This car is a "); // Print without newline – see Chapter 1.
      super.describe();
   }

   public static void main(String[] args)
   {
      Car car = new Car("Ford", "Fiesta", 2009, 4);
      car.describe();
   }
}

```

[清单 4-3](#list3) 的汽车类声明了一个 describe() 方法 ，该方法覆盖了汽车的 describe() 方法，以输出一个面向汽车的描述。该方法使用保留字 super 通过 super.describe()调用车辆的 describe() 方法；。

**注意**通过在方法名前加上保留字 super 和成员访问操作符，从覆盖子类方法中调用超类方法。如果不这样做，最终会递归调用子类的覆盖方法。使用超级和成员访问操作符从子类中访问非私有超类字段，通过声明同名字段来屏蔽这些字段。

如果您要编译[清单 4-3](#list3) ( 贾瓦克 Car.java)并运行汽车应用( java 汽车)，您会发现汽车的覆盖 describe() 方法代替汽车的覆盖 describe() 方法执行，并输出这辆汽车是 2009 款福特嘉年华。

**注意**你不能覆盖一个最终方法。例如，如果 Vehicle 的 describe() 方法被声明为 final void describe() ，当遇到试图在 Car 类中覆盖该方法时，编译器会报告一个错误。当开发人员不希望这些方法被覆盖(出于安全或其他原因)时，他们将方法声明为 final 。此外，您不能使重写方法的可访问性低于它所重写的方法。例如，如果 Car 的 describe() 方法被声明为 private void describe() ，编译器会报告一个错误，因为私有访问比默认的包访问更难访问。然而， describe() 可以通过将它声明为 public 而变得更容易访问，比如在 public void describe() 中。

假设您碰巧用下面显示的方法替换了清单 4-3 中的的 describe() 方法:

```java
void describe(String owner)
{
   System.out.print("This car, which is owned by " + owner + ", is a ");
   super.describe();
}

```

修改后的 Car 类现在有两个 describe() 方法，前面明确声明的方法和从 Vehicle 继承的方法。void describe(String owner)方法不会覆盖 Vehicle 的 describe() 方法。相反，它重载此方法。

Java 编译器通过让您在子类的方法头前加上 @Override 注释来帮助您检测在编译时重载而不是覆盖方法的企图，如以下代码所示(我将在第 6 章的[中讨论注释):](06.html)

```java
@Override
void describe()
{
   System.out.print("This car is a ");
   super.describe();
}

```

指定 @Override 告诉编译器这个方法覆盖了另一个方法。如果改为重载方法，编译器会报告错误。如果没有这个注释，编译器不会报告错误，因为方法重载是一个有效的特性。

**提示**养成用 @Override 注释作为覆盖方法前缀的习惯。这个习惯将帮助你更快地发现重载错误。

在第 3 章中，我讨论了类和对象的初始化顺序，在这里你学到了类成员总是首先被初始化，并且是自顶向下的顺序(同样的顺序也适用于实例成员)。实现继承增加了几个细节:

*   超类的类初始化器总是在子类的类初始化器之前执行。
*   子类的构造函数总是调用超类构造函数来初始化对象的超类层，然后初始化子类层。

Java 对实现继承的支持只允许你扩展一个类。您不能扩展多个类，因为这样做会导致问题。例如，假设 Java 支持多重实现继承，你决定通过[清单 4-4](#list4) 所示的类结构来建模一匹飞马(来自希腊神话)。

*[清单 4-4](#_list4)* 。多重实现继承的虚拟演示

```java
class Bird
{
   void describe()
   {
      // code that outputs a description of a bird's appearance and behaviors
   }
}

class Horse
{
   void describe()
   {
      // code that outputs a description of a horse's appearance and behaviors
   }
}

public class FlyingHorse extends Bird, Horse
{
   public static void main(String[] args)
   {
      FlyingHorse pegasus = new FlyingHorse();
      pegasus.describe();
   }
}

```

清单 4-4 的类结构揭示了由于鸟和马声明了一个描述()方法而产生的歧义。 FlyingHorse 继承了这些方法中的哪一个？一个相关的歧义来自于同名字段，可能是不同的类型。哪个字段是继承的？

终极超类

一个没有显式扩展另一个类的类隐式扩展了 Java 的对象类(位于 java.lang 包中——我会在下一章讨论包)。例如，[清单 4-1](#list1) 的车辆类扩展了对象，而车辆扩展了车辆。

对象是 Java 的终极超类，因为它是所有其他类的祖先，但它本身并不扩展任何其他类。对象提供了一组其他类继承的公共方法。[表 4-1](#Tab1) 描述了这些方法。

[表 4-1](#_Tab1) 。对象的方法

| 方法 | 描述 |
| --- | --- |
| 对象克隆() | 创建并返回当前对象的副本。 |
| 布尔等于(对象对象) | 确定当前对象是否等于由 obj 标识的对象。 |
| void finalize() | 完成当前对象。 |
| 阶级<？> getClass() | 返回当前对象的类对象。 |
| int hashCode() | 返回当前对象的哈希代码。 |
| 作废通知() | 唤醒一个正在等待当前对象的监视器的线程。 |
| 见通知 All() | 唤醒所有等待当前对象监视器的线程。 |
| 字符串 toString() | 返回当前对象的字符串表示形式。 |
| void wait() | 使当前线程等待当前对象的监视器，直到它通过 notify() 或 notifyAll() 被唤醒。 |
| 无效等待(长超时) | 使当前线程在当前对象的监视器上等待，直到它通过 notify() 或 notifyAll() 被唤醒，或者直到指定的超时值(以毫秒为单位)已经过去，以先到者为准。 |
| void wait(长超时，int nanos) | 使当前线程在当前对象的监视器上等待，直到它通过 notify() 或 notifyAll() 被唤醒，或者直到指定的超时值(以毫秒为单位)加上毫微秒值(以纳秒为单位)已经过去，以先到者为准。 |

我稍后将讨论 clone() 、 equals() 、 finalize() 、 hashCode() 和 toString() 方法，但是将 notify() 、 notifyAll() 和 wait() 方法的讨论推迟到第 8 章进行。

克隆

clone() 方法*克隆*(复制)一个对象而不调用构造函数。它将每个原语或引用字段的值复制到它在克隆中的对应物，这个任务被称为*浅复制*或*浅克隆* 。清单 4-5 展示了这种行为。

*[清单 4-5](#_list5)* 。浅克隆一个雇员对象

```java
public class Employee implements Cloneable
{
   String name;
   int age;

   Employee(String name, int age)
   {
      this.name = name;
      this.age = age;
   }

   public static void main(String[] args) throws CloneNotSupportedException
   {
      Employee e1 = new Employee("John Doe", 46);
      Employee e2 = (Employee) e1.clone();
      System.out.println(e1 == e2); // Output: false
      System.out.println(e1.name == e2.name); // Output: true
   }
}

```

[清单 4-5](#list5) 声明了一个雇员类，带有姓名和年龄实例字段以及一个用于初始化这些字段的构造函数。 main() 方法使用此构造函数将一个新的 Employee 对象的这些字段的副本初始化为 John Doe 和 46 。

**注意**一个类必须实现 java.lang.Cloneable 接口，否则它的实例不能通过 Object 的 clone() 方法进行浅层克隆——该方法执行运行时检查，查看该类是否实现了 Cloneable 。(我将在本章后面讨论接口。)如果一个类没有实现 Cloneable ， clone() 抛出Java . lang . clonenotsupportedexception。(因为CloneNotSupportedException是一个被检查的异常，所以[清单 4-5](#list5) 需要通过将throws CloneNotSupportedException附加到 main() 方法的头来满足编译器的要求。我将在下一章讨论异常。)java.lang.String 类就是一个没有实现 Cloneable 的类的例子；因此，字符串对象不能被浅克隆。

将 Employee 对象的引用赋给局部变量 e1 后， main() 调用该变量上的 clone() 方法复制该对象，然后将结果引用赋给变量 e2 。因为 clone() 返回对象，所以需要 (Employee) 转换。

为了证明引用被分配给 e1 和 e2 的对象是不同的， main() 接下来通过 == 比较这些引用，并输出布尔结果，结果恰好为假。为了证明 Employee 对象是浅克隆的， main() 接下来通过 == 比较两个 Employee 对象的 name 字段中的引用，并输出布尔结果，结果恰好为真。

**注意** 对象的 clone() 方法最初被指定为 public 方法，这意味着可以从任何地方克隆任何对象。出于安全原因，这个访问后来被更改为 protected ，这意味着只有与要调用其 clone() 方法的类在同一个包中的代码，或者这个类的子类中的代码(不考虑包)，才能调用 clone() 。

浅层克隆并不总是可取的，因为原始对象及其克隆通过它们的等效引用字段引用同一个对象。例如，[清单 4-5](#list5) 的两个雇员对象中的每一个都通过其名称字段引用同一个字符串对象。

虽然对于实例不可变的字符串来说不是问题，但是通过克隆的引用字段改变可变对象会导致原始(非克隆)对象通过其引用字段看到相同的改变。例如，假设您向雇员添加了一个名为雇佣日期的引用字段。该字段的类型为日期，具有年、月和日实例字段。因为日期是可变的，所以您可以在分配给雇佣日期的日期实例中更改这些字段的内容。

现在，假设您计划更改克隆的日期，但希望保留原始的雇员对象的日期。使用浅层克隆无法做到这一点，因为原始的雇员对象也可以看到这一变化。要解决这个问题，您必须修改克隆操作，以便它为雇员克隆的雇佣日期字段分配一个新的日期引用。这个任务被称为*深度复制*或*深度克隆* ，在[清单 4-6](#list6) 中演示。

*[清单 4-6](#_list6)* 。深度克隆雇员对象

```java
class Date
{
   int year, month, day;

   Date(int year, int month, int day)
   {
      this.year = year;
      this.month = month;
      this.day = day;
   }
}

public class Employee implements Cloneable
{
   String name;
   int age;
   Date hireDate;

   Employee(String name, int age, Date hireDate)
   {
      this.name = name;
      this.age = age;
      this.hireDate = hireDate;
   }

   @Override
   protected Object clone() throws CloneNotSupportedException
   {
      Employee emp = (Employee) super.clone();
      if (hireDate != null) // no point cloning a null object (one that doesn't exist)
         emp.hireDate = new Date(hireDate.year, hireDate.month, hireDate.day);
      return emp;
   }

   public static void main(String[] args) throws CloneNotSupportedException
   {
      Employee e1 = new Employee("John Doe", 46, new Date(2000, 1, 20));
      Employee e2 = (Employee) e1.clone();
      System.out.println(e1 == e2); // Output: false
      System.out.println(e1.name == e2.name); // Output: true
      System.out.println(e1.hireDate == e2.hireDate); // Output: false
      System.out.println(e2.hireDate.year + " " + e2.hireDate.month + " " +
                         e2.hireDate.day); // Output: 2000 1 20
   }
}

```

[清单 4-6](#list6) 声明日期和员工班次。 Date 类声明了 year 、 month 和 day 字段以及一个构造函数。(您可以在一行中声明一个逗号分隔的变量列表，前提是这些变量共享相同的类型，在本例中是 int 。)

Employee 覆盖 clone() 方法来深度克隆 hireDate 字段。该方法首先调用对象的 clone() 方法来浅克隆当前 Employee 对象的实例字段，然后将新对象的引用存储在 emp 中。假设 hireDate 不包含空引用，它接下来将新的 Date 对象的引用分配给 emp 的 hireDate 字段；该对象的字段被初始化为与原始 Employee 对象的 hireDate 实例相同的值。

此时，您有了一个雇员克隆，它具有浅克隆的姓名和年龄字段以及深克隆的雇佣日期字段。 clone() 方法通过返回这个雇员克隆来结束。

**注意**如果你没有从一个被覆盖的 clone() 方法中调用对象的 clone() 方法(因为你更喜欢深度克隆引用字段并自己对非引用字段进行浅层复制)，那么包含被覆盖的 clone() 方法的类就没有必要实现可克隆的，但是为了一致性，它应该实现这个接口。字符串没有覆盖 clone() ，所以字符串对象不能被深度克隆。

相等

== 和！= 运算符比较两个原始值(如整数)是否相等( == )或不相等()！= )。这些操作符还比较两个引用，看它们是否引用同一个对象。后一种比较被称为 *身份检查*。

不能使用 == 和！= 判断两个对象在逻辑上是否相同(或不相同)。例如，具有相同字段值的两个汽车对象在逻辑上是等价的。但是， == 报告它们不相等，因为它们的引用不同。

**注**因为 == 和！= 尽可能快地执行比较，因为需要快速执行字符串比较(尤其是在对大量字符串进行排序时)，所以 String 类包含特殊支持，允许通过 == 和比较文字字符串和字符串值常量表达式！= 。(我将在第 7 章的[中介绍字符串时讨论这种支持。)以下语句演示了这些比较:](07.html)

```java
System.out.println("abc" == "abc"); // Output: true
System.out.println("abc" == "a" + "bc"); // Output: true
System.out.println("abc" == "Abc"); // Output: false
System.out.println("abc" != "def"); // Output: true
System.out.println("abc" == new String("abc")); // Output: false

```

认识到除了引用相等还需要支持逻辑相等，Java 在对象类中提供了一个 equals() 方法。因为这个方法默认比较引用，所以您需要覆盖 equals() 来比较对象内容。

在覆盖 equals() 之前，确保这是必要的。例如，Java 的 java.lang.StringBuffer 类不会覆盖 equals() 。也许这个类的设计者认为没有必要确定两个 StringBuffer 对象在逻辑上是否等价。

您不能用任意代码覆盖 equals() 。这样做可能会给应用带来灾难性的后果。相反，您需要遵守 Java 文档中为该方法指定的契约，这将在下面介绍。

equals() 方法实现了非空对象引用的等价关系:

*   *它是自反的*:对于任何非空的参考值 *x* 、 *x* 。equals( *x* ) 返回 true。
*   *对称*:对于任意非空参考值 *x* 和 *y* 、 *x* 。equals(*y*)返回 true 当且仅当 *y* 。equals(*x*)返回 true。
*   *是过渡的*:对于任意非空参考值 *x* 、 *y* 、 *z* ，if *x* 。equals(*y*)返回 true， *y* 。equals(*z*)返回 true，则 *x* 。equals(*z*)返回 true。
*   *一致*:对于任意非空参考值 *x* 和 *y* ，多次调用*x*T8】。equals(*y*)始终返回 true 或始终返回 false，前提是在对象的 equals() 比较中使用的信息没有被修改。
*   对于任意非空参考值 *x* 、 *x* 、。equals(null) 返回 false。

尽管这份合同看起来有点吓人，但满足它并不难。为了证明，看看[清单 4-7](#list7) 的点类中 equals() 方法的实现。

*[清单 4-7](#_list7)* 。逻辑上比较点对象

```java
public class Point
{
   private int x, y;

   Point(int x, int y)
   {
      this.x = x;
      this.y = y;
   }

   int getX()
   {
      return x;
   }

   int getY()
   {
      return y;
   }

   @Override
   public boolean equals(Object o)
   {
      if (!(o instanceof Point))
         return false;
      Point p = (Point) o;
      return p.x == x && p.y == y;
   }

   public static void main(String[] args)
   {
      Point p1 = new Point(10, 20);
      Point p2 = new Point(20, 30);
      Point p3 = new Point(10, 20);
      // Test reflexivity
      System.out.println(p1.equals(p1)); // Output: true
      // Test symmetry
      System.out.println(p1.equals(p2)); // Output: false
      System.out.println(p2.equals(p1)); // Output: false
      // Test transitivity
      System.out.println(p2.equals(p3)); // Output: false
      System.out.println(p1.equals(p3)); // Output: true
      // Test nullability
      System.out.println(p1.equals(null)); // Output: false
      // Extra test to further prove the instanceof operator's usefulness.
      System.out.println(p1.equals("abc")); // Output: false
   }
}

```

[清单 4-7](#list7) 的覆盖 equals() 方法以 if 语句开始，该语句使用操作符的实例来确定传递给参数 o 的变量是否是 Point 类的实例。如果不是，If 语句执行返回 false。

点表达式的 o 实例满足契约的最后一部分:对于任意非空参考值 *x* 、 *x* 。equals(null) 返回 false。因为空引用不是任何类的实例，所以将该值传递给 equals() 会导致表达式计算为 false。

Point 表达式的o instance 还可以防止在向 equals() 传递除了 Point 对象之外的对象时，通过表达式 (Point) o 抛出Java . lang . classcastexception实例。(我将在下一章讨论异常。)

在转换之后，通过表达式 p.x == x & & p.y == y ，仅允许点与其他点进行比较，从而满足契约的自反性、对称性和传递性要求。

通过确保 equals() 方法是确定性的，满足了最终的契约要求，即一致性。换句话说，这个方法不依赖于任何可能随方法调用而改变的字段值。

**提示**通过首先使用 == 来确定 o 的引用是否标识当前对象，可以优化耗时的 equals() 方法的性能。只需指定 if (o == this)返回 true作为 equals() 方法的第一条语句。这种优化在[清单 4-7](#list7) 的 equals() 方法中是不必要的，该方法具有令人满意的性能。

在重写等于()时，务必重写 hashCode() 方法 。在清单 4-7 中我没有这样做，因为我还没有正式引入 hashCode() 。

最终确定

*终结*是指通过 finalize() 方法进行清理，该方法被称为*终结器*。 finalize() 方法的 Java 文档声明 finalize() 是“当垃圾收集器确定不再有对对象的引用时，由垃圾收集器在对象上调用的”。一个子类覆盖了 finalize() 方法来释放系统资源或执行其他清理。

对象的版本 finalize() 什么都不做；您必须用任何需要的清理代码重写此方法。因为在应用终止之前，虚拟机可能永远不会调用 finalize() ，所以您应该提供一个显式的清理方法，并让 finalize() 调用这个方法，作为安全网，以防这个方法没有被调用。

**注意**永远不要依赖 finalize() 来释放有限的资源，比如文件描述符。例如，如果一个应用对象打开文件，期望它的 finalize() 方法将关闭它们，当一个缓慢的虚拟机调用 finalize() 很慢时，应用可能发现自己无法打开额外的文件。让这个问题变得更糟的是， finalize() 可能会在另一个虚拟机上被更频繁地调用，导致这个太多打开文件的问题没有暴露出来。开发人员可能会错误地认为应用在不同的虚拟机上表现一致。

如果你决定覆盖 finalize() ，你的对象的子类层必须给它的超类层一个执行终结的机会。您可以通过指定 super.finalize()来完成这项任务；作为方法中的最后一条语句，如下例所示:

```java
protected void finalize() throws Throwable
{
   try
   {
      // Perform subclass cleanup.
   }
   finally
   {
      super.finalize();
   }
}

```

该示例的 finalize() 声明将 throws Throwable 附加到方法头，因为清理代码可能会抛出异常。如果抛出异常，执行离开方法，在没有 try-finally 的情况下，super . finalize()；从不执行。(我将在第 5 章的[中讨论异常并最终尝试。)](05.html)

为了防止这种可能性，子类的清理代码在保留字 try 后面的块中执行。如果抛出异常，Java 的异常处理逻辑会执行跟在 finally 保留字和 super.finalize()后面的块；执行超类的 finalize() 方法。

**注意**finalize()方法经常被用来执行*复活*(使一个未被引用的对象被引用)以实现*对象池*，当这些对象创建起来很昂贵(时间方面)时，这些对象池回收相同的对象(数据库连接对象就是一个例子)。

当您将此(对当前对象的引用)赋给类或实例字段(或另一个长期变量)时，就会发生复活。例如，您可以指定r = this；在 finalize() 内将标识为 this 的未引用对象分配给名为 r 的类字段。

由于复活的可能性，对于覆盖了 finalize() 的对象的垃圾收集会有严重的性能损失。

不能再次调用复活的对象的终结器。

散列码

hashCode() 方法返回一个 32 位整数，标识当前对象的*散列码*，一个对潜在的大量数据应用数学函数得到的小值。这个值的计算被称为*哈希*。

当覆盖 equals() 时，您必须覆盖 hashCode() ，并且根据下面的契约，在 hashCode() 的 Java 文档中指定:

*   在 Java 应用的执行过程中，只要对同一对象多次调用， hashCode() 方法必须始终返回相同的整数，前提是在对象的 equals(Object) 比较中使用的信息没有被修改。这个整数不需要从一个应用的一次执行到同一应用的另一次执行保持一致。
*   如果根据 equals(Object) 方法，两个对象相等，那么在这两个对象上调用 hashCode() 方法必须产生相同的整数结果。
*   根据 equals(Object) 方法，如果两个对象不相等，那么在这两个对象上调用 hashCode() 方法必须产生不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同的整数结果可能会提高哈希表的性能。

不遵守这个契约，你的类的实例将不能与 Java 的基于散列的集合框架类一起正常工作，比如 java.util.HashMap 。(我会在[第九章](09.html)讨论 HashMap 和其他集合框架类。)

如果你覆盖了 equals() 而没有覆盖 hashCode() ，那么最重要的是违反了契约中的第二条:相等对象的 hash 码也必须相等。这种违反可能会导致严重的后果，如下例所示:

```java
java.util.Map<Point, String> map = new java.util.HashMap<Point, String>();
map.put(p1, "first point");
System.out.println(map.get(p1)); // Output: first point
System.out.println(map.get(new Point(10, 20))); // Output: null

```

假设这个例子的语句被附加到[清单 4-7](#list7) 的 main() 方法中——Java . util .前缀和 < Point，String > 与包和泛型有关，我将在[第 5 章](05.html)和[第 6 章](06.html)中讨论。

在 main() 创建其 Point 对象并调用其 System.out.println() 方法后，它执行该示例的语句，这些语句执行以下任务:

*   第一条语句实例化了 HashMap ，它位于 java.util 包中。
*   第二条语句调用 HashMap 的 put() 方法来存储[清单 4-7](#list7) 的 p1 对象键和 HashMap 中的“第一点”值。
*   第三条语句通过 hashmap 的 get() 方法检索其 Point key 逻辑上等于 p1 的 HashMap 条目的值。
*   第四条语句相当于第三条语句，但返回空引用，而不是“第一点”。

虽然对象 p1 和 Point(10，20) 在逻辑上是等价的，但是这些对象具有不同的哈希代码，导致每个对象引用哈希表中不同的条目。如果一个对象没有存储(通过 put() )在那个条目中， get() 返回 null。

纠正这个问题需要覆盖 hashCode() 来为逻辑上等价的对象返回相同的整数值。当我在第九章的[中讨论散列表时，我会告诉你如何完成这个任务。](09.html)

字符串表示

方法返回当前对象的基于字符串的表示。这种表示默认为对象的类名，后面跟有 @ 符号，后面跟有对象散列码的十六进制表示。

例如，如果您要执行system . out . println(P1)；输出[清单 4-7](#list7) 的 p1 对象，你会看到一行类似于 Point@3e25a5 的输出。( System.out.println() 在后台调用 p1 继承的 toString() 方法。)

您应该努力覆盖 toString() 以便它返回一个简洁但有意义的对象描述。例如，你可以在[清单 4-7](#list7) 的点类中声明一个 toString() 方法，如下所示:

```java
@Override
public String toString()
{
   return "(" + x + ", " + y + ")";
}

```

这次执行system . out . println(P1)；产生更有意义的输出，比如 (10，20) 。

构图

实现继承和组合提供了两种不同的重用代码的方法。如您所知，实现继承涉及用新类扩展一个类，这是基于它们之间的“是-a”关系:例如，一辆汽车是一辆汽车。

另一方面， *composition* 关注于从其他类中合成类，这是基于它们之间的“has-a”关系。例如，汽车有一个发动机、车轮 s 和一个转向轮。

在这一章中你已经看到了作文的例子。例如，[清单 4-2](#list2) 的汽车类包括串制造和串型号字段。[清单 4-8](#list8) 的 Car 类提供了另一个组合的例子。

*[清单 4-8](#_list8)* 。一个汽车类，它的实例由其他对象组成

```java
class Car extends Vehicle
{
   private Engine engine; // bicycles don't have engines
   private Wheel[] wheels; // boats don't have wheels
   private SteeringWheel steeringWheel; // hang gliders don't have steering wheels
}

```

清单 4-8 展示了组合和实现继承并不互相排斥。虽然没有显示，汽车继承了其汽车超类的各种成员，此外还提供了自己的引擎、车轮和方向盘字段。

实现继承的问题是

实现继承有潜在的危险，尤其是当开发人员对超类没有完全的控制权，或者超类没有考虑到扩展而设计和记录的时候。

问题是实现继承破坏了封装。子类依赖于超类中的实现细节。如果这些细节在超类的新版本中发生变化，子类可能会被破坏，即使子类没有被改变。

例如，假设您已经购买了一个 Java 类库，其中一个类描述了一个约会日历。虽然您没有访问这个类的源代码的权限，但是假设清单 4-9 描述了它的部分代码。

*[清单 4-9](#_list9)* 。约会日历类

```java
public class ApptCalendar
{
   private final static int MAX_APPT = 1000;
   private Appt[] appts;
   private int size;

   public ApptCalendar()
   {
      appts = new Appt[MAX_APPT];
      size = 0; // redundant because field automatically initialized to 0
                // adds clarity, however
   }

   public void addAppt(Appt appt)
   {
      if (size == appts.length)
         return; // array is full
      appts[size++] = appt;
   }

   public void addAppts(Appt[] appts)
   {
      for (int i = 0; i < appts.length; i++)
         addAppt(appts[i]);
   }
}

```

清单 4-9 的 ApptCalendar 类存储了一个约会数组，每个约会由一个 Appt 实例描述。对于这个讨论来说， Appt 的细节无关紧要。它可能像类 Appt {} 一样微不足道。

假设您想在一个文件中记录每个约会。因为没有提供日志记录功能，所以您用[清单 4-10](#list10) 的 LoggingApptCalendar 类扩展了 ApptCalendar ，该类在重写 addAppt() 和add apput()方法时添加了日志记录行为。

*[清单 4-10](#_list10)* 。扩展约会日历类

```java
public class LoggingApptCalendar extends ApptCalendar
{
   // A constructor is not necessary because the Java compiler will add a
   // noargument constructor that calls the superclass's noargument
   // constructor by default.

   @Override
   public void addAppt(Appt appt)
   {
      Logger.log(appt.toString());
      super.addAppt(appt);
   }

   @Override
   public void addAppts(Appt[] appts)
   {
      for (int i = 0; i < appts.length; i++)
         Logger.log(appts[i].toString());
      super.addAppts(appts);
   }
}

```

[清单 4-10](#list10) 的 LoggingApptCalendar 类依赖于一个 Logger 类，它的 void log(String msg) 类方法将一个字符串记录到一个文件中(细节并不重要)。请注意使用 toString() 将 Appt 对象转换为 String 对象，然后将其传递给 log() 。

虽然这个类看起来还可以，但它并不像您预期的那样工作。假设您实例化了这个类，并通过add apput()向该实例添加了几个 Appt 实例，如下所示:

```java
LoggingApptCalendar lapptc = new LoggingApptCalendar();
lapptc.addAppts(new Appt[] { new Appt(), new Appt(), new Appt() });

```

如果还加一个system . out . println(msg)；方法调用记录器的 log(String msg) 方法，输出这个方法的参数，你会发现 log() 一共输出了六条消息；预期的三条消息(每个 Appt 对象一条)都是重复的。

当调用 LoggingApptCalendar 的add apput()方法时，它首先为传递给add apput()的apput数组中的每个 Appt 实例调用 Logger.log() 。该方法然后通过super . add appendar(appapps)调用 ApptCalendar 的add apput()方法；。

ApptCalendar 的add apput()方法在其apput数组参数中为每个 Appt 实例调用 LoggingApptCalendar 的覆盖 addAppt() 方法。 addAppt() 执行logger . log(appt . tostring())；来记录它的 appt 参数的字符串表示，最后会有三条额外的记录消息。

如果您没有覆盖add apparatus()方法，这个问题就会消失。然而，子类将被绑定到一个实现细节: ApptCalendar 的add apput()方法调用 addAppt() 。

当细节没有被记录时，依赖于实现细节并不是一个好主意。(我之前说过，你无权访问 ApptCalendar 的源代码。)当一个细节没有被记录时，它可以在类的新版本中改变。

因为一个基类的改变会破坏一个子类，这个问题被称为*脆弱基类问题* 。脆弱性的一个相关原因也与重写方法有关，它发生在新方法被添加到后续版本的超类中时。

例如，假设一个新版本的库在 ApptCalendar 类中引入了一个新的 public void addAppt(Appt appt，boolean unique) 方法。当 unique 为 false 时，该方法将 appt 实例添加到日历中；并且，当 unique 为真时，它只在之前没有添加的情况下添加 appt 实例。

因为这个方法是在 LoggingApptCalendar 类创建之后添加的， LoggingApptCalendar 不会通过调用 Logger.log() 来覆盖新的 addAppt() 方法。因此，传递给新的 addAppt() 方法的 Appt 实例不会被记录。

这里还有另一个问题:你在子类中引入了一个不在超类中的方法。超类的新版本提供了一个匹配子类方法签名和返回类型的新方法。你的子类方法现在覆盖了超类方法，并且可能不满足超类方法的契约。

有一种方法可以让这些问题消失。不要扩展超类，而是在新类中创建一个私有字段，并让这个字段引用超类的一个实例。这个任务演示了组合，因为您正在新类和超类之间形成一个“has-a”关系。

此外，让每个新类的实例方法通过保存在私有字段中的超类实例调用相应的超类方法，并返回被调用方法的返回值。这个任务被称为*转发*，新方法被称为*转发方法* 。

[清单 4-11](#list11) 展示了一个改进的 LoggingApptCalendar 类，它使用组合和转发来永远消除脆弱的基类问题和未预料到的方法覆盖的额外问题。

*[清单 4-11](#_list11)* 。合成的日志约会日历类

```java
public class LoggingApptCalendar
{
   private ApptCalendar apptCal;

   public LoggingApptCalendar(ApptCalendar apptCal)
   {
      this.apptCal = apptCal;
   }

   public void addAppt(Appt appt)
   {
      Logger.log(appt.toString());
      apptCal.addAppt(appt);
   }

   public void addAppts(Appt[] appts)
   {
      for (int i = 0; i < appts.length; i++)
         Logger.log(appts[i].toString());
      apptCal.addAppts(appts);
   }
}

```

[清单 4-11](#list11) 的 LoggingApptCalendar 类不依赖于 ApptCalendar 类的实现细节。您可以向 ApptCalendar 添加新方法，它们不会破坏 LoggingApptCalendar 。

**注意** LoggingApptCalendar 是一个*包装类*的例子，该类的实例包装其他实例。每个 LoggingApptCalendar 实例包装一个 ApptCalendar 实例。 LoggingApptCalendar 也是*装饰设计模式*的一个例子，在 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides (Addison-Wesley，1995；ISBN: 0201633612)。

什么时候应该扩展一个类，什么时候应该使用包装类？当超类和子类之间存在“is-a”关系时，扩展一个类，并且要么你对超类有控制权，要么超类已经为类扩展而设计和记录。否则，使用包装类。

“类扩展的设计和文档”是什么意思？设计意味着提供受保护的方法，这些方法与类的内部工作挂钩(以支持编写高效的子类)，并确保构造函数和 clone() 方法永远不会调用可重写的方法。文档意味着清楚地陈述重写方法的影响。

**注意**包装类不应该在*回调框架*中使用，在一个对象框架中，一个对象将自己的引用传递给另一个对象(通过 this )，这样后一个对象可以在以后调用前一个对象的方法。这种“回调前一个对象的方法”被称为*回调*。因为被包装的对象不知道它的包装类，所以它只传递它的引用(通过 this )，结果回调不涉及包装类的方法。

改变形式

一些现实世界的实体可以改变它们的形态。例如，水(相对于星际空间而言，在地球上)天然是液体，但冷冻时会变成固体，加热到沸点时会变成气体。像蝴蝶这样经历蜕变的昆虫是另一个例子。

这种改变形式的能力被称为*多态性*，对于用编程语言建模非常有用。例如，绘制任意形状的代码可以通过引入单个形状类及其 draw() 方法，并通过为每个圆形实例、矩形实例以及存储在数组中的其他形状实例调用该方法来更简洁地表达。当形状的 draw() 方法被数组实例调用时，被调用的是圆形、矩形或其他形状实例的 draw() 方法。形的画()法有很多种形式。换句话说，这个方法是多态的。

Java 支持四种多态性 :

*   *强制*:一个操作通过隐式的类型转换服务于多种类型。例如，除法可以让您将一个整数除以另一个整数，或将一个浮点值除以另一个浮点值。如果一个操作数是整数，另一个操作数是浮点值，编译器*会强制*(隐式转换)整数为浮点值，以防止类型错误。(没有支持整数操作数和浮点操作数的除法运算。)将子类对象引用传递给方法的超类参数是强制多态的另一个例子。编译器将子类类型强制为超类类型，以限制对超类的操作。
*   *重载*:相同的操作符或方法名可以在不同的上下文中使用。例如， + 可用于执行整数加法、浮点加法或字符串连接，具体取决于其操作数的类型。同样，多个同名的方法可以出现在一个类中(通过声明和/或继承)。
*   *参数化*:在一个类声明中，一个字段名可以关联不同的类型，一个方法名可以关联不同的参数和返回类型。然后，字段和方法可以在每个类实例中采用不同的类型。例如，一个字段可能是类型 java.lang.Integer 并且一个方法可能在一个类实例中返回一个整数，并且同一个字段可能是类型字符串并且同一个方法可能在另一个类实例中返回一个字符串。Java 通过泛型支持参数多态，我将在第 6 章中讨论。
*   *子类型*:一个类型可以作为另一个类型的子类型。当子类型实例出现在超类型上下文中时，对子类型实例执行超类型操作会导致该操作的子类型版本执行。例如，假设圆是点的子类，并且两个类都包含一个 draw() 方法。将 Circle 实例分配给 Point 类型的变量，然后通过该变量调用 draw() 方法，导致 Circle 的 draw() 方法被调用。

许多开发人员不认为强制和重载是有效的多态类型。他们认为强制和重载只不过是类型转换和语法糖。相反，参数和子类型被认为是有效的多态类型。

在这一节中，我将通过首先检查向上转换和后期绑定来关注子类型多态性。然后，我将向您介绍抽象类和抽象方法、向下转换和运行时类型标识，以及协变返回类型。

上传和后期绑定

[清单 4-7](#list7) 的点类将一个点表示为一个 x-y 对。因为圆(在本例中)是一个表示其中心的 x-y 对，并且半径表示其范围，所以您可以用一个引入了半径字段的圆类来扩展点。查看[清单 4-12](#list12) 。

*[清单 4-12](#_list12)* 。一个圆类扩展了点类

```java
class Circle extends Point
{
   private int radius;

   Circle(int x, int y, int radius)
   {
      super(x, y);
      this.radius = radius;
   }

   int getRadius()
   {
      return radius;
   }

   @Override
   public String toString()
   {
      return "" + radius;
   }
}

```

[清单 4-12](#list12) 的圆类将一个圆描述为一个点和一个半径，这意味着你可以将一个圆实例视为一个点实例。通过将 Circle 实例分配给 Point 变量来完成此任务，如下所示:

```java
Circle c = new Circle(10, 20, 30);
Point p = c;

```

cast 操作符不需要从圆转换到点，因为通过点的接口访问圆实例是合法的。毕竟一个圆至少是一个点。这种赋值被称为*向上转换*，因为你隐式地向上转换类型层次结构(从 Circle 子类到 Point 超类)。这也是*协方差*的一个例子，一个具有更大范围值的类型(圆)被转换成一个具有更小范围值的类型(点)。

将 Circle 上升到 Point 后，不能调用 Circle 的 getRadius() 方法，因为该方法不是 Point 接口的一部分。在将子类型缩小为超类之后，失去对子类型特性的访问似乎没有什么用处，但对于实现子类型多态性却是必要的。

除了将子类实例向上转换为超类类型的变量之外，子类型多态性还包括在超类中声明一个方法，并在子类中覆盖这个方法。例如，假设点和圆是图形应用的一部分，您需要在每个类中引入一个 draw() 方法来分别绘制一个点和一个圆。你以清单 4-13 中的[所示的类结构结束。](#list13)

*[清单 4-13](#_list13)* 。声明图形应用的点和圆类

```java
class Point
{
   private int x, y;

   Point(int x, int y)
   {
      this.x = x;
      this.y = y;
   }

   int getX()
   {
      return x;
   }

   int getY()
   {
      return y;
   }

   @Override
   public String toString()
   {
      return "(" + x + ", " + y + ")";
   }

   void draw()
   {
      System.out.println("Point drawn at " + toString());
   }
}

class Circle extends Point
{
   private int radius;

   Circle(int x, int y, int radius)
   {
      super(x, y);
      this.radius = radius;
   }

   int getRadius()
   {
      return radius;
   }

   @Override
   public String toString()
   {
      return "" + radius;
   }

   @Override
   void draw()
   {
      System.out.println("Circle drawn at " + super.toString() +
                         " with radius " + toString());
   }
}

```

清单 4-13 的 draw() 方法将最终绘制图形形状，但是通过 System.out.println() 方法调用模拟它们的行为在图形应用的早期测试阶段已经足够了。

现在您已经暂时完成了点和圆，您将想要在图形应用的模拟版本中测试它们的 draw() 方法。为了实现这个目标，你编写清单 4-14 中的的图形类。

*[清单 4-14](#_list14)* 。一个图形类用于测试点的和圆的 draw() 方法

```java
public class Graphics
{
   public static void main(String[] args)
   {
      Point[] points = new Point[] { new Point(10, 20), new Circle(10, 20, 30) };
      for (int i = 0; i < points.length; i++)
         points[i].draw();
   }
}

```

[清单 4-14](#list14) 的 main() 方法首先声明一个 Point s 的数组。向上造型是通过首先让数组的初始化器实例化 Circle 类，然后将这个实例的引用分配给 points 数组中的第二个元素来演示的。

继续， main() 使用 for 循环调用每个点元素的 draw() 方法。因为第一次迭代调用了 Point 的 draw() 方法，而第二次迭代调用了 Circle 的 draw() 方法，所以您会观察到以下输出:

```java
Point drawn at (10, 20)
Circle drawn at (10, 20) with radius 30

```

Java 如何“知道”在第二次循环迭代时必须调用 Circle 的 draw() 方法？难道不应该调用点的 draw() 方法，因为圆由于向上转换而被视为点？

在编译时，编译器不知道调用哪个方法。它所能做的就是验证超类中存在一个方法，并验证方法调用的参数列表和返回类型与超类的方法声明相匹配。

编译器在编译后的代码中插入一条指令，在运行时获取并使用 points[i] 中的任何引用来调用正确的 draw() 方法，而不是知道调用哪个方法。这个任务被称为*后期绑定*。

后期绑定用于调用非 final 实例方法。对于所有其他方法调用，编译器知道要调用哪个方法，并在编译后的代码中插入一条指令，该指令调用与变量的类型(而不是其值)相关联的方法。这个任务被称为*早期绑定* 。

如果要向上转换的数组是另一个数组的子类型，也可以从一个数组向上转换到另一个数组。考虑清单 4-15 中的。

*[清单 4-15](#_list15)* 。演示阵列向上投射

```java
class Point
{
   private int x, y;

   Point(int x, int y)
   {
      this.x = x;
      this.y = y;
   }

   int getX() { return x; }
   int getY() { return y; }
}

class ColoredPoint extends Point
{
   private int color;

   ColoredPoint(int x, int y, int color)
   {
      super(x, y);
      this.color = color;
   }

   int getColor() { return color; }
}

public class UpcastArrayDemo
{
   public static void main(String[] args)
   {
      ColoredPoint[] cptArray = new ColoredPoint[1];
      cptArray[0] = new ColoredPoint(10, 20, 5);
      Point[] ptArray = cptArray;
      System.out.println(ptArray[0].getX()); // Output: 10
      System.out.println(ptArray[0].getY()); // Output: 20
 //      System.out.println(ptArray[0].getColor()); // Illegal
   }
}

```

[清单 4-15](#list15) 的 main() 方法首先创建一个由一个元素组成的 ColoredPoint 数组。然后实例化这个类，并将对象的引用分配给这个元素。因为 ColoredPoint[] 是 Point[] 的一个子类型， main() 能够将 cptArray 的 ColoredPoint[] 类型向上转换为 Point[] ，并将其引用分配给p array。

main() 然后通过 ptArray[0] 调用 ColoredPoint 实例的 getX() 和 getY() 方法。它不能调用 getColor() ，因为p array的范围比 cptArray 窄。换句话说， getColor() 不是 Point 接口的一部分。

抽象类和抽象方法

假设新的需求要求您的图形应用必须包含一个矩形类。此外，该类必须包括一个 draw() 方法，并且该方法必须以类似于[清单 4-14](#list14) 的 Graphics 应用类中所示的方式进行测试。

与作为具有半径的点的圆相反，将矩形视为具有宽度和高度的点是没有意义的。更确切地说，一个矩形实例可能由一个表示其原点的点实例和一个表示其宽度和高度范围的点实例组成。

因为圆、点和矩形都是形状的例子，所以用自己的 draw() 方法声明一个 Shape 类比指定类 Rectangle extends Point 更有意义。[清单 4-16](#list16) 展示了形状的声明。

*[清单 4-16](#_list16)* 。宣告一个形状类

```java
class Shape
{
   void draw()
   {
   }
}

```

[清单 4-16](#list16) 的形状类声明了一个空的 draw() 方法，该方法的存在只是为了被覆盖和演示子类型多态性。

你现在可以重构[清单 4-13](#list13) 的点类来扩展[清单 4-16](#list16) 的形状类，保持圆形不变，并引入一个矩形类来扩展形状。然后你可以重构[清单 4-14 的](#list14)的 Graphics 类的 main() 方法来考虑形状。[清单 4-17](#list17) 展示了生成的图形类。

*[清单 4-17](#_list17)* 。一个带有新的 main() 方法的图形类，该方法考虑了形状

```java
public class Graphics
{
   public static void main(String[] args)
   {
      Shape[] shapes = new Shape[] { new Point(10, 20), new Circle(10, 20, 30),
                                     new Rectangle(20, 30, 15, 25) };
      for (int i = 0; i < shapes.length; i++)
         shapes[i].draw();
   }
}

```

因为点和矩形直接延伸形状，又因为圆通过延伸点间接延伸形状，[清单 4-17](#list17) 的 main() 方法会调用相应子类的 draw() 方法来响应形状【I】。draw()；。

虽然形状让代码更加灵活，但是有一个问题。如何阻止开发人员实例化形状并将这个无意义的实例添加到形状数组中，如下所示？

```java
Shape[] shapes = new Shape[] { new Point(10, 20), new Circle(10, 20, 30),
                               new Rectangle(20, 30, 15, 25), new Shape() };

```

实例化形状是什么意思？因为这个类描述的是一个抽象的概念，画一个通用的形状是什么意思？幸运的是，Java 为这个问题提供了一个解决方案，如[清单 4-18](#list18) 所示。

*[清单 4-18](#_list18)* 。抽象出形状类

```java
abstract class Shape
{
   abstract void draw(); // semicolon is required
}

```

[清单 4-18](#list18) 使用 Java 的抽象保留字声明一个不能实例化的类。当您尝试实例化该类时，编译器会报告一个错误。

**提示**养成声明描述通用类别(如形状、动物、车辆和账户)的类的习惯摘要。这样，您就不会无意中实例化它们。

抽象保留字也用于声明没有主体的方法。 draw() 方法不需要实体，因为它不能绘制抽象的形状。

当你试图声明一个既抽象又最终的类时，编译器会报告一个错误。例如，抽象最终类形状是一个错误，因为抽象类不能被实例化，最终类不能被扩展。当您将一个方法声明为抽象方法，但没有将其类声明为抽象方法时，编译器也会报告错误。例如，从清单 4-18 中的形状类的头中删除抽象会导致错误。这种移除是错误的，因为当非抽象(具体)类包含抽象方法时，它不能被实例化。最后，当你扩展一个抽象类时，扩展类必须覆盖抽象类的所有抽象方法，否则扩展类本身必须被声明为抽象的；否则，编译器将报告错误。

除了抽象方法之外，一个抽象类还可以包含非抽象方法。例如，[清单 4-2 中](#list2)的 Vehicle 类可以被声明为抽象。构造函数仍然存在，用于初始化私有字段，即使您不能实例化结果类。

向下转换和运行时类型识别

通过向上转换在类型层次结构中向上移动会导致无法访问子类型特征。例如，将一个 Circle 实例赋给 Point 变量 p 意味着不能使用 p 调用 Circle 的 getRadius() 方法。

但是，可以通过执行显式强制转换操作，再次访问 Circle 实例的 getRadius() 方法，例如，Circle c =(Circle)p；。这种赋值被称为*向下转换*，因为你是显式地向下移动类型层次结构(从点超类到圆子类)。这也是*逆变*的一个例子，具有较窄取值范围的类型(点)被转换为具有较宽取值范围的类型(圈)。

虽然向上转换总是安全的(超类的接口是子类接口的子集)，但是向下转换就不一样了。清单 4-19 向你展示了当向下转换使用不当时，你会陷入什么样的麻烦。

*[清单 4-19](#_list19)* 。向下抛掷的问题是

```java
class A
{
}

class B extends A
{
   void m()
   {
   }
}

public class DowncastDemo
{
   public static void main(String[] args)
   {
      A a = new A();
      B b = (B) a;
      b.m();
   }
}

```

清单 4-19 展示了一个由名为 A 的超类和名为 B 的子类组成的类层次结构。虽然 A 没有声明任何成员，但是 B 声明了一个单独的 m() 方法。

第三个名为 DowncastDemo 的类提供了一个 main() 方法，该方法首先实例化 A ，然后尝试将该实例向下转换为 B ，并将结果赋给变量 b 。编译器不会抱怨，因为在同一类型层次结构中从超类向下转换到子类是合法的。

但是，如果允许赋值，应用在试图执行 b.m()时无疑会崩溃；。崩溃的发生是因为虚拟机试图调用一个不存在的方法——类 A 没有 m() 方法。

幸运的是，这种情况永远不会发生，因为虚拟机验证强制转换是合法的。因为它检测到 A 没有 m() 方法，所以它不允许通过抛出 ClassCastException 类的实例进行强制转换。

虚拟机的 cast 验证说明了*运行时类型标识*(或简称 *RTTI* )。强制转换验证通过检查强制转换运算符的操作数类型来执行 RTTI，以确定是否允许强制转换。显然，演员不应该被允许。

第二种形式的 RTTI 涉及到操作符的实例。该运算符检查左操作数是否是右操作数的实例，如果是，则返回 true。下面的例子将的实例引入到[清单 4-19](#list19) 中，以防止类抛出异常:

```java
if(a instanceof B)
{
   B b = (B) a;
   b.m();
}

```

操作符的instance 检测到变量 a 的实例不是从 B 创建的，并返回 false 以表明这一事实。因此，执行非法强制转换的代码将不会执行。(过度使用的实例可能表明糟糕的软件设计。)

因为子类型是一种超类型，所以当其左操作数是其右操作数超类型的子类型实例或超类型实例时，的instance 将返回 true。以下示例演示了:

```java
A a = new A();
B b = new B();
System.out.println(b instanceof A); // Output: true
System.out.println(a instanceof A); // Output: true

```

这个例子假设了清单 4-19 中[所示的类结构，并实例化了超类 A 和子类 B 。第一个 System.out.println() 方法调用输出 true ，因为 b 的引用标识了 B 的实例，是 A 的子类；第二个 System.out.println() 方法调用输出 true ，因为 a 的引用标识了超类 A 的一个实例。](#list19)

还可以从一个数组向下转换到另一个数组，前提是被向下转换的数组是另一个数组的超类型，并且它的元素类型是子类型的元素类型。考虑清单 4-20 中的。

*[清单 4-20](#_list20)* 。演示数组向下转换

```java
class Point
{
   private int x, y;

   Point(int x, int y)
   {
      this.x = x;
      this.y = y;
   }

   int getX() { return x; }
   int getY() { return y; }
}

class ColoredPoint extends Point
{
   private int color;

   ColoredPoint(int x, int y, int color)
   {
      super(x, y);
      this.color = color;
   }

   int getColor() { return color; }
}

public class DowncastArrayDemo
{
   public static void main(String[] args)
   {
      ColoredPoint[] cptArray = new ColoredPoint[1];
      cptArray[0] = new ColoredPoint(10, 20, 5);
      Point[] ptArray = cptArray;
      System.out.println(ptArray[0].getX()); // Output: 10
      System.out.println(ptArray[0].getY()); // Output: 20
 //      System.out.println(ptArray[0].getColor()); // Illegal
      if (ptArray instanceof ColoredPoint[])
      {
         ColoredPoint cp = (ColoredPoint) ptArray[0];
         System.out.println(cp.getColor());
      }
   }
}

```

清单 4-20 类似于[清单 4-15](#list15) ，除了它也演示了向下转换。注意它使用的实例来验证p 数组的引用对象是类型 ColoredPoint[] 。如果该运算符返回 true，则可以安全地将p array[0]从点向下转换到 ColoredPoint ，并将引用分配给 ColoredPoint 。

共变返回类型

*协变返回类型*是一种方法返回类型，在超类的方法声明中，它是子类的覆盖方法声明中返回类型的超类型。[清单 4-21](#list21) 展示了这种语言的特性。

*[清单 4-21](#_list21)* 。协变返回类型的演示

```java
class SuperReturnType
{
   @Override
   public String toString()
   {
      return "superclass return type";
   }
}

class SubReturnType extends SuperReturnType
{
   @Override
   public String toString()
   {
      return "subclass return type";
   }
}

class Superclass
{
   SuperReturnType createReturnType()
   {
      return new SuperReturnType();
   }
}

class Subclass extends Superclass
{
   @Override
   SubReturnType createReturnType()
   {
      return new SubReturnType ();
   }
}

public class CovarDemo
{
   public static void main(String[] args)
   {
      SuperReturnType suprt = new Superclass().createReturnType();
      System.out.println(suprt); // Output: superclass return type
      SubReturnType subrt = new Subclass().createReturnType();
      System.out.println(subrt); // Output: subclass return type
   }
}

```

[清单 4-21](#list21) 声明了 SuperReturnType 和超类超类和子 ReturnType 和子类子类；每个超类和子类都声明了一个 createReturnType() 方法。超类的方法将其返回类型设置为 SuperReturnType ，而子类的覆盖方法将其返回类型设置为 SubReturnType ，后者是 SuperReturnType 的子类。

协变返回类型最小化了向上转换和向下转换。例如，子类的 createReturnType() 方法不需要将其 SubReturnType 实例向上转换为其 SubReturnType 返回类型。此外，在给变量 subrt 赋值时，这个实例不需要向下转换为 SubReturnType 。

在没有协变返回类型的情况下，您会以清单 4-22 中的[结束。](#list22)

*[清单 4-22](#_list22)* 。缺少协变返回类型时的向上转换和向下转换

```java
class SuperReturnType
{
   @Override
   public String toString()
   {
      return "superclass return type";
   }
}

class SubReturnType extends SuperReturnType
{
   @Override
   public String toString()
   {
      return "subclass return type";
   }
}

class Superclass
{
   SuperReturnType createReturnType()
   {
      return new SuperReturnType();
   }
}

class Subclass extends Superclass
{
   @Override
   SuperReturnType createReturnType()
   {
      return new SubReturnType ();
   }
}

public class CovarDemo
{
   public static void main(String[] args)
   {
      SuperReturnType suprt = new Superclass().createReturnType();
      System.out.println(suprt); // Output: superclass return type
      SubReturnType subrt = (SubReturnType) new Subclass().createReturnType();
      System.out.println(subrt); // Output: subclass return type
   }
}

```

在[清单 4-22](#list22) 中，第一个加粗的代码显示了从子返回类型到超返回类型的向上转换，第二个加粗的代码使用所需的(子返回类型)转换运算符，在将子返回类型赋值之前，从超返回类型向下转换到子返回类型。

形式化类接口

在我对信息隐藏的介绍中(参见[第三章](03.html)，我提到每个类 *X* 都公开了一个接口(一个由构造函数、方法和【可能】字段组成的协议，它们对从其他类创建的对象可用，用于创建和与 *X* 的对象通信)。

Java 通过提供保留字接口将接口概念形式化，接口用于引入一个没有实现的类型。Java 还提供了声明、实现和扩展接口的语言特性。在本节中查看了接口声明、实现和扩展之后，我将解释使用接口的基本原理。

声明接口

一个接口声明由一个标题和一个主体组成。至少，报头由保留字 interface 和标识接口的名称组成。正文以左大括号字符开始，以右大括号结束。夹在这些分隔符之间的是常量和方法头声明。考虑[清单 4-23](#list23) 。

*[清单 4-23](#_list23)* 。声明一个可绘制的界面

```java
interface Drawable
{
   int RED = 1;   // For simplicity, integer constants are used. These constants are
   int GREEN = 2; // not that descriptive, as you will see.
   int BLUE = 3;
   int BLACK = 4;
   void draw(int color);
}

```

清单 4-23 声明了一个名为 Drawable 的接口。按照惯例，接口的名称以大写字母开头。此外，多词界面名称中每个后续词的第一个字母都要大写。

**注意**许多接口名称以 able 后缀结尾。例如，标准类库包括名为可调用、可比、可克隆、可迭代、可运行和可序列化的接口。使用这个后缀不是强制性的；标准类库还提供了名为 CharSequence 、 Collection 、 Executor 、 Future 、 Iterator 、 List 、 Map 、 Set 的接口。

Drawable 声明了四个标识颜色常数的字段。 Drawable 还声明了一个 draw() 方法，必须用这些常量之一来调用该方法，以指定用于绘制某物的颜色。

**注意**你可以在接口之前加上公共接口，以使你的接口可以被其包之外的代码访问。(我将在下一章讨论包)。否则，该接口只能由其包中的其他类型访问。你也可以在接口前面加上抽象来强调一个接口是抽象的。因为接口已经是抽象的，所以在接口的声明中指定抽象的是多余的。接口的字段被隐式声明为 public 、 static 和 final 。因此，用这些保留字来声明它们是多余的。因为这些字段是常量，所以必须显式初始化；否则，编译器会报告错误。最后，接口的方法被隐式声明为公共和抽象。因此，用这些保留字来声明它们是多余的。因为这些方法必须是实例方法，所以不要将它们声明为静态的，否则编译器会报错。

Drawable 标识一个类型，指定做什么(画一些东西)但不指定如何做。它将实现细节留给实现该接口的类。这些类的实例被称为 *drawables* ，因为它们知道如何绘制自己。

**注意**没有声明成员的接口被称为*标记接口*或*标记接口*。它将元数据与类相关联。例如，可克隆的标记/标签接口的存在意味着它的实现类的实例可以被简单地克隆。RTTI 用于检测对象的类是否实现了标记/标签接口。例如，当对象的 clone() 方法通过 RTTI 检测到调用实例的类实现了 Cloneable 时，它会浅克隆该对象。

实现接口

接口本身是没有用的。为了让应用受益，接口需要由一个类来实现。Java 为此任务提供了实现保留字。这个保留字在[清单 4-24](#list24) 中有演示。

*[清单 4-24](#_list24)* 。实现可绘制接口

```java
class Point implements Drawable
{
   private int x, y;

   Point(int x, int y)
   {
      this.x = x;
      this.y = y;
   }

   int getX()
   {
      return x;
   }

   int getY()
   {
      return y;
   }

   @Override
   public String toString()
   {
      return "(" + x + ", " + y + ")";
   }

   @Override
   public void draw(int color)
   {
      System.out.println("Point drawn at " + toString() + " in color " + color);
   }
}

class Circle extends Point implements Drawable
{
   private int radius;

   Circle(int x, int y, int radius)
   {
      super(x, y);
      this.radius = radius;
   }

   int getRadius()
   {
      return radius;
   }

   @Override
   public String toString()
   {
      return "" + radius;
   }

   @Override
   public void draw(int color)
   {
      System.out.println("Circle drawn at " + super.toString() +
                         " with radius " + toString() + " in color " + color);
   }
}

```

[清单 4-24](#list24) 改进了[清单 4-13](#list13) 的类层次结构，以利用[清单 4-23](#list23) 的可绘制接口。您会注意到，每个类 Point 和 Circle 都通过将 implements Drawable 子句附加到其类头来实现该接口。

若要实现接口，该类必须为每个接口方法头指定一个方法，该方法的头与接口的方法头具有相同的签名和返回类型，并且该方法头具有一个代码体。

**注意**当实现一个方法时，不要忘记接口的方法被隐式声明为 public 。如果您忘记在实现方法的声明中包含 public ，编译器将会报告一个错误，因为您试图为实现方法分配较弱的访问。

当一个类实现一个接口时，该类继承接口的常量和方法头，并通过提供实现来覆盖方法头(因此有了 @Override 注释)。这就是所谓的*接口继承*。

原来圈的表头不需要实现 Drawable 子句。如果该子句不存在， Circle 继承了 Point 的 draw() 方法，仍然被认为是一个 Drawable ，无论它是否覆盖该方法。

接口指定一个类型，该类型的数据值是其类实现接口的对象，其行为是由接口指定的。这一事实意味着，只要对象的类实现了接口，就可以将对象的引用赋给接口类型的变量。以下示例提供了一个演示:

```java
public static void main(String[] args)
{
   Drawable[] drawables = new Drawable[] { new Point(10, 20), new Circle(10, 20, 30) };
   for (int i = 0; i < drawables.length; i++)
      drawables[i].draw(Drawable.RED);
}

```

因为 Point 和 Circle 实例是依靠这些实现 Drawable 接口的类来绘制的，所以将 Point 和 Circle 实例引用分配给 Drawable 类型的变量(包括数组元素)是合法的。

当您运行此方法时，它会生成以下输出:

```java
Point drawn at (10, 20) in color 1
Circle drawn at (10, 20) with radius 30 in color 1

```

[清单 4-23](#list23) 的可绘制界面对于绘制一个形状的轮廓很有用。假设您还需要填充形状的内部。你可以尝试通过声明[清单 4-25](#list25) 的可填充接口来满足这个需求。

*[清单 4-25](#_list25)* 。声明一个可填充的界面

```java
interface Fillable
{
   int RED = 1;
   int GREEN = 2;
   int BLUE = 3;
   int BLACK = 4;
   void fill(int color);
}

```

给定[清单 4-23](#list23) 和 [4-25](#list25) ，您可以通过指定类点实现可绘制、可填充和类圆实现可绘制、可填充来声明点和圆类实现这两个接口。然后，您可以修改 main() 方法，也将可绘制内容视为*可填充内容*，以便您可以填充这些形状，如下所示:

```java
public static void main(String[] args)
{
   Drawable[] drawables = new Drawable[] { new Point(10, 20),
                                           new Circle(10, 20, 30) };
   for (int i = 0; i < drawables.length; i++)
      drawables[i].draw(Drawable.RED);
   Fillable[] fillables = new Fillable[drawables.length];
   for (int i = 0; i < drawables.length; i++)
   {
      fillables[i] = (Fillable) drawables[i];
      fillables[i].fill(Fillable.GREEN);
   }
}

```

在调用每个 drawable 的 draw() 方法后， main() 创建一个与 Drawable 数组长度相同的 Fillable 数组。然后将每个 Drawable 数组元素复制到一个 Fillable 数组元素，然后调用 Fillable 的 fill() 方法。 (Fillable) 造型是必要的，因为 drawable 不是 Fillable。该强制转换操作将会成功，因为被复制的点和圆实例实现了可填充和可绘制。

**提示**通过在实现之后指定一个逗号分隔的接口名称列表，您可以列出您需要实现的任意多的接口。

实现多个接口会导致名称冲突，编译器会报告错误。例如，假设你试图编译清单 4-26 的接口和类声明。

*[清单 4-26](#_list26)* 。碰撞界面

```java
interface A
{
   int X = 1;
   void foo();
}

interface B
{
   int X = 1;
   int foo();
}

class Collision implements A, B
{
   @Override
   public void foo();

   @Override
   public int foo() { return X; }
}

```

清单 4-26 的 A 和 B 的每个接口都声明了一个名为 X 的常数。尽管每个常量都具有相同的类型和值，但当编译器在 Collision 的第二个 foo() 方法中遇到 X 时，它会报告一个错误，因为它不知道哪个 X 正在被继承。

说到 foo() ，编译器在遇到碰撞的第二个 foo() 声明时报错，因为 foo() 已经声明过了。不能通过仅更改方法的返回类型来重载方法。

编译器可能会报告额外的错误。例如，Java 7 编译器在被告知编译清单 4-26 中的[时会这样说:](#list26)

```java
Collision.java:19: error: method foo() is already defined in class Collision
   public int foo() { return X; }
              ^
Collision.java:13: error: Collision is not abstract and does not override abstract method foo()
in B class Collision implements A, B
^
Collision.java:16: error: foo() in Collision cannot implement foo() in B
   public void foo();
               ^
  return type void is not compatible with int
Collision.java:19: error: reference to X is ambiguous, both variable X in A and variable X
in B match
   public int foo() { return X; }
                             ^
4 errors

```

扩展接口

正如子类可以通过保留字扩展来扩展超类一样，你可以使用这个保留字让一个*子接口*扩展一个*超接口*。这也被称为*接口继承*。

例如， Drawable 和 Fillable 中重复的颜色常量，当你在一个实现类中单独指定它们的名字时，会导致名字冲突。为了避免这些名字冲突，在名字前面加上接口名和成员访问操作符，或者将这些常量放在它们自己的接口中，并让 Drawable 和 Fillable 扩展这个接口，如[清单 4-27](#list27) 所示。

*[清单 4-27](#_list27)* 。扩展颜色接口

```java
interface Colors
{
   int RED = 1;
   int GREEN = 2;
   int BLUE = 3;
   int BLACK = 4;
}

interface Drawable extends Colors
{
   void draw(int color);
}

interface Fillable extends Colors
{
   void fill(int color);
}

```

Drawable 和 Fillable 都从 Colors 继承常量，这对于编译器来说不是问题。这些常量只有一个副本(颜色为和),没有名称冲突的可能，所以编译器是满意的。

如果一个类可以通过在实现之后声明一个逗号分隔的接口名称列表来实现多个接口，那么看起来一个接口应该可以用类似的方式扩展多个接口。这个特性在[清单 4-28](#list28) 中进行了演示。

*[清单 4-28](#_list28)* 。扩展一对接口

```java
interface A
{
   int X = 1;
}

interface B
{
   double X = 2.0;
}

interface C extends A, B
{
}

```

尽管 C 继承了两个同名的常量 X 具有不同的类型和初始化器，清单 4-28 仍然可以编译。然而，如果你实现了 C ，然后试图访问 X ，如[清单 4-29](#list29) 所示，你将会遇到名称冲突。

*[清单 4-29](#_list29)* 。发现名称冲突

```java
class Collision implements C
{
   public void output()
   {
      System.out.println(X); // Which X is accessed?
   }
}

```

假设你引入一个void foo()；方法头声明成接口一个和一个int foo()；方法头声明进入接口 B 。这一次，当您试图编译修改后的[清单 4-28](#list28) 时，编译器将报告一个错误。

为什么要使用接口？

既然声明、实现和扩展接口的机制已经不存在了，那么您就可以关注使用它们的基本原理了。不幸的是，刚接触 Java 接口特性的人经常被告知，这个特性是为了解决 Java 不支持多实现继承的问题而创建的。虽然接口在这方面很有用，但这不是它们存在的理由。相反， *Java 的接口特性是通过将接口从实现中分离出来，为开发人员设计应用提供最大的灵活性。您应该始终对接口(由接口类型或抽象类提供)进行编码。*

那些坚持*敏捷软件开发*(一组基于迭代开发的软件开发方法，强调保持代码简单，频繁测试，并在可交付时交付应用的功能部分)的人知道灵活编码的重要性。他们不能将他们的代码绑定到一个特定的实现上，因为下一次迭代的需求变化可能会导致一个新的实现，并且他们可能会发现他们自己重写了大量的代码，这浪费了时间并且减慢了开发。

接口通过将接口与实现分离来帮助您实现灵活性。例如，[清单 4-17](#list17) 的图形类中的 main() 方法从 Shape 类的子类中创建一个对象数组，然后遍历这些对象，调用每个对象的 draw() 方法。唯一可以被绘制的对象是那些子类形状的对象。

假设你也有一个层次结构的类来模拟电阻、晶体管和其他电子元件。每个元件都有自己的符号，可以在电子电路的原理图中显示。也许您想为每个绘制组件符号的类添加一个绘制功能。

您可以考虑将形状指定为电子元件类层次的超类。然而，电子元件不是形状(尽管它们有形状)，所以将这些类放在以形状为根的类层次结构中是没有意义的。

但是，您可以让每个组件类实现 Drawable 接口，该接口允许您将实例化这些类的表达式添加到出现在[清单 4-25](#list25) 之前的 main() 方法中的 drawables 数组中(这样您就可以绘制它们的符号)。这是合法的，因为这些实例是可提取的。

只要有可能，您应该努力在代码中指定接口而不是类，以使您的代码能够适应变化。当使用 Java 的集合框架时尤其如此，我将在第九章详细讨论。

现在，考虑一个简单的例子，它由集合框架的 java.util.List 接口及其 java.util.ArrayList 和 java.util.LinkedList 实现类组成。以下示例展示了基于 ArrayList 类的不灵活代码:

```java
ArrayList<String> arrayList = new ArrayList<String>();
void dump(ArrayList<String> arrayList)
{
   // suitable code to dump out the arrayList
}

```

这个例子使用基于泛型的参数化类型语言特性(我将在第 6 章中讨论)来识别存储在数组列表实例中的对象种类。在这个例子中，字符串对象被存储。

这个例子是不灵活的，因为它将 ArrayList 类硬连接到多个位置。这种硬连接使开发人员特别关注数组列表，而不是一般意义上的列表。

当需求改变时，缺乏关注是有问题的，或者可能是由*剖析*(分析运行中的应用以检查其性能)带来的性能问题，这表明开发人员应该使用 LinkedList 。

这个例子只需要很少的修改就可以满足新的需求。相比之下，更大的代码库可能需要更多的更改。尽管您只需要将 ArrayList 改为 LinkedList ，为了满足编译器的要求，请考虑将 arrayList 改为 linkedList 以保持*语义*(含义)清晰——您可能需要在整个源代码中多次更改引用 ArrayList 实例的名称。

在重构代码以适应 LinkedList 时，开发人员必然会浪费时间。相反，通过编写这个示例来使用等效的常量，可以节省时间。换句话说，这个例子可以被写成依赖于接口，并且只在一个地方指定数组列表。以下示例向您展示了结果代码的外观:

```java
List<String> list = new ArrayList<String>();
void dump(List<String> list)
{
   // suitable code to dump out the list
}

```

这个例子比前一个例子灵活得多。如果一个需求或概要分析的变化建议使用 LinkedList 而不是 ArrayList ，只需用 Linked 替换 Array 就可以了。您甚至不必更改参数名。

**注意** Java 提供了描述*抽象类型*(不能实例化的类型)的接口和抽象类。抽象类型代表抽象概念(例如，drawable 和 shape)，这种类型的实例是没有意义的。

接口通过缺少实现来提高灵活性——Drawable 和 List 说明了这种灵活性。它们不依赖于任何单一的类层次结构，而是可以由任何层次结构中的任何类来实现。相反，抽象类支持实现，但可以是真正的抽象(例如，[清单 4-18](#list18) 的抽象形状类)。但是，它们仅限于出现在类层次结构的上层。

接口和抽象类可以一起使用。例如，集合框架的 java.util 包提供了 List、Map、和 Set 接口和 AbstractList、AbstractMap、和 AbstractSet 抽象类，它们提供了这些接口的框架实现。

通过实现许多接口方法，框架实现使您可以轻松地创建自己的接口实现来满足您独特的需求。如果它们不满足您的需要，您可以选择让您的类直接实现适当的接口。

练习

以下练习旨在测试您对第 4 章内容的理解:

1.  什么是实现继承？
2.  Java 如何支持实现继承？
3.  一个子类可以有两个或多个超类吗？
4.  你如何防止一个类被子类化？
5.  是非判断: super() 调用可以出现在任何方法中。
6.  如果超类声明一个带一个或多个参数的构造函数，如果子类构造函数没有使用 super() 调用那个构造函数，为什么编译器会报错？
7.  什么是不可变类？
8.  是非判断:一个类可以继承构造函数。
9.  重写一个方法是什么意思？
10.  从超类方法的覆盖子类方法中调用超类方法需要什么？
11.  如何防止方法被重写？
12.  为什么不能使一个重写的子类方法比它所重写的超类方法更难访问呢？
13.  如何告诉编译器一个方法覆盖了另一个方法？
14.  为什么 Java 不支持多实现继承？
15.  Java 的终极超类叫什么？
16.  clone() 方法的目的是什么？
17.  对象的 clone() 方法什么时候抛出CloneNotSupportedException？
18.  解释浅拷贝和深拷贝的区别。
19.  == 运算符可以用来判断两个对象在逻辑上是否等价吗？为什么或为什么不？
20.  Object 的 equals() 方法完成了什么？
21.  表达式 "abc" == "a" + "bc" 返回真还是假？
22.  如何优化一个耗时的 equals() 方法？
23.  finalize() 方法的目的是什么？
24.  你应该依靠 finalize() 来关闭打开的文件吗？为什么或为什么不？
25.  什么是哈希码？
26.  是非判断:无论何时重写 equals() 方法，都应该重写 hashCode() 方法。
27.  对象的 toString() 方法返回什么？
28.  为什么要重写 toString() ？
29.  定义构图。
30.  是非判断:组合用于描述“是-a”关系，实现继承用于描述“有-a”关系。
31.  识别实现继承的根本问题。你如何解决这个问题？
32.  定义子类型多态性。
33.  子类型多态性是如何实现的？
34.  为什么要使用抽象类和抽象方法？
35.  抽象类可以包含具体方法吗？
36.  向下抛掷的目的是什么？
37.  列出 RTTI 的两种形式。
38.  什么是协变返回类型？
39.  如何正式声明一个接口？
40.  是非判断:你可以在接口声明前加上抽象保留字。
41.  定义标记接口。
42.  什么是接口继承？
43.  你如何实现一个接口？
44.  当您实现多个接口时，您可能会遇到什么问题？
45.  如何形成接口的层次结构？
46.  为什么 Java 的接口特性如此重要？
47.  接口和抽象类完成什么？
48.  接口和抽象类有什么不同？
49.  通过声明动物、鸟、鱼、美洲知更鸟、家养金丝雀、虹鳟鱼和 SockeyeSalmon 类来建立动物层级的模型:

*   Animal 是 public 和 abstract ，声明基于 private String 的 kind 和 appearance 字段，声明一个 public 构造器，该构造器将这些字段初始化为传入的参数，声明 public 和 abstract eat() 和 move() 方法，这些方法不带参数并且其返回类型为 void
*   Bird 是 public 和 abstract ，扩展 Animal ，声明一个 public 构造函数，将它的 kind 和 appearance 参数值传递给它的超类构造函数，覆盖它的 eat() 方法以输出吃种子和昆虫(通过 System.out.println() ，并覆盖它的
*   鱼是公和摘要；延伸动物；声明一个公共构造函数，将它的种类和外观参数值传递给它的超类构造函数；覆盖它的 eat() 方法来输出吃磷虾、藻类和昆虫；并覆盖它的 move() 方法来输出游过水。
*   AmericanRobin 是 public ，扩展了 Bird ，声明了一个 public noargument 构造函数，将" American robin "" red breast "传递给它的超类构造函数。
*   DomesticCanary 是 public ，扩展了 Bird ，声明了一个 public noargument 构造函数，将 "domesticcanary" 和 "yellow，orange，black，brown，white，red" 传递给它的超类构造函数。
*   RainbowTrout 是 public ，扩展了 Fish ，并声明了一个 public noargument 构造函数，该构造函数将" RainbowTrout ""几乎贯穿其整个身体长度的鲜艳斑点五彩条纹带"传递给其超类构造函数。
*   SockeyeSalmon 是 public ，扩展了 Fish ，声明了一个 public noargument 构造函数，将" SockeyeSalmon ""鲜红色带绿头"传递给它的超类构造函数。

**注意**为了简洁，我从动物层级抽象知更鸟、金丝雀、鳟鱼和鲑鱼中省略了概括知更鸟、金丝雀、鳟鱼和鲑鱼的类。也许您可能想在层次结构中包含这些类。

虽然这个练习展示了使用继承的自然场景的精确建模，但是它也揭示了*类爆炸*的可能性——太多的类可能被引入来建模一个场景，并且维护所有这些类可能是困难的。在使用继承建模时，请记住这一点。

*   50.继续上一个练习，用一个 main() 方法声明一个 Animals 类。该方法首先声明一个 animals 数组，该数组被初始化为 AmericanRobin 、 RainbowTrout 、 DomesticCanary 和 SockeyeSalmon 对象。然后该方法遍历这个数组，首先输出 animals[i] (这导致 toString() 被调用)，然后调用每个对象的 eat() 和 move() 方法(演示子类型多态性)。
*   51\. Continuing from the previous exercise, declare a public Countable interface with a String getID() method. Modify Animal to implement Countable and have this method return kind’s value. Modify Animals to initialize the animals array to AmericanRobin, RainbowTrout, DomesticCanary, SockeyeSalmon, RainbowTrout, and AmericanRobin objects. Also, introduce code that computes a census of each kind of animal. This code will use the Census class that is declared in [Listing 4-30](#list30).

    *[清单 4-30](#_list30)* 。普查类存储四种动物的普查数据

    ```java
    public class Census
    {
       public final static int SIZE = 4;
       private String[] IDs;
       private int[] counts;

       public Census()
       {
          IDs = new String[SIZE];
          counts = new int[SIZE];
       }

       public String get(int index)
       {
          return IDs[index] + " " + counts[index];
       }

       public void update(String ID)
       {
          for (int i = 0; i < IDs.length; i++)
          {
             // If ID not already stored in the IDs array (which is indicated by
             // the first null entry that is found), store ID in this array, and
             // also assign 1 to the associated element in the counts array, to
             // initialize the census for that ID.
             if (IDs[i] == null)
             {
                IDs[i] = ID;
                counts[i] = 1;
                return;
             }

             // If a matching ID is found, increment the associated element in
             // the counts array to update the census for that ID.
             if (IDs[i].equals(ID))
             {
                counts[i]++;
                return;
             }
          }
       }
    }

    ```

摘要

继承是相似实体类别之间的层次关系，其中一个类别从至少一个其他实体类别继承状态和行为。从单一类别继承称为单一继承，从至少两个类别继承称为多重继承。

Java 支持单继承和多继承以方便代码重用——为什么要多此一举？Java 支持类上下文中的单一继承(通过保留字扩展)，其中一个类通过类扩展从另一个类继承字段和方法。因为涉及到类，Java 把这种继承称为实现继承。Java 只在这样的接口上下文中支持多重继承:一个类通过接口实现(通过保留字实现)从一个或多个接口继承方法模板，或者一个接口通过接口扩展(通过保留字扩展)从一个或多个接口继承方法模板。因为涉及到接口，所以 Java 把这种继承称为接口继承。

一些现实世界的实体有能力改变它们的形态。改变形式的能力被称为多态，这对于用编程语言建模很有用。尽管 Java 支持强制、重载、参数和子类型类型的多态性，但在本章中，我只关注子类型多态性，这是通过向上转换和方法覆盖实现的。

每个类 *X* 都公开了一个接口(一个由构造函数、方法和[可能]字段组成的协议，这些接口对从其他类创建的对象可用，用于创建和与 *X* 的对象通信)。Java 通过提供保留字接口将接口概念形式化，接口用于引入一个没有实现的类型。

尽管许多人认为创建接口语言特性是为了解决 Java 不支持多实现继承的问题，但这并不是它存在的真正原因。相反，Java 的接口特性是通过将接口从实现中分离出来，为开发人员设计应用提供最大的灵活性。您应该始终编写接口代码。

在第 5 章中，我继续通过关注嵌套类型、包、静态导入和异常来探索 Java 语言。